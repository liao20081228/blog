---
title: 输入与输出
tags: 现代操作系统
---

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文章参考了<font color=blue >塔嫩鲍姆的《现代操作系统》、汤子瀛的《 计算机操作系统》。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------


# 1 I/O硬件原理
&emsp;&emsp;程序员关注的是IO硬件提供给软件的接口。
## 1.1 I/O设备
&emsp;&emsp;**块设备**：信息传输以块为单位，每个块可以寻址。如硬盘。
&emsp;&emsp;**字符设备**：信息传输以字符为单位，不可寻址。如打印机。
## 1.2 设备控制器
&emsp;&emsp;I/O设备由机械部件和电子部件组成。机械部件就是设备本身。电子部件叫做设备控制器。
## 1.3 内存映射I/O
&emsp;&emsp;设备控制器用寄存器与CPU通信，设备用数据缓冲区与CPU通信。
&emsp;&emsp;CPU与寄存器和数据缓冲区的通信方式：**I/O端口空间和内存映射I/O**。
> **I/O端口空间**：每个控制寄存器分配一个受保护的I/O端口号。
>**内存映射I/O**：每个控制寄存器分配一个内存地址。
>> **原理**：将地址放到总线中。用另一条总线来识别是内存还是IO设备
>> **优点**：
>>
>> * 不用使用汇编代码。
>> * 不用特殊保护来阻止I/O操作。
>> * 引用内存的每条指令也可以引用控制寄存器。
>>
>>**缺点**:
>>
>> * 不应对控制寄存器高速缓存。**解决**：硬件对每个页面可以禁用高速缓存。
>> * 具有单独的内存总线的机器上，IO设备无法查看内存地址。**解决办法**：
>> * 先送到内存，如果响应失败再送到控制寄存器。
>> * 在内存总线上设置探查器。
>> * 在内存控制器中对地址过滤。

## 1.4 直接存储器存取
&emsp;&emsp;**DMA**：一种是数据由I/O设备直接传送到内存中，不需要CPU参与。另一种，数据由设备传送到DMA控制器，再由DMA控制器写入目标中，更加灵活。
&emsp;&emsp;**要求**：必须具有DMA控制器才能使用DMA。
&emsp;&emsp;**特征**：能够独立于CPU而访问系统总线。
&emsp;&emsp;**DMA评价**：一方面，CPU比DMA控制器快；另一方面，取出CPU节约成本，特别是低端计算机中。
>**磁盘DMA过程**：
> 1. CPU通过设置DMA寄存器对其编程，DMA知道要将数据送往何处。DMA向磁盘控制器发出命令，将磁盘数据读取到内部缓冲区，并检验校验和。
> 2. DMA控制器在总线上发出读请求到磁盘控制器，开始DMA传送。
> 3. 将数据写入内存。
> 4. 写完成时，磁盘控制器发出一个应答信号到DMA控制器。
> 5. DMA步增要使用的内存地址，步减字节数，重复2-4，直到字节数为0.
> 6. DMA控制器中断CPU，以便告知CPU传输完成。
>![1](https://www.github.com/liao20081228/blog/raw/master/图片/输入与输出/1.png)


&emsp;&emsp;总线操作模式：字模式，块模式。
>&emsp;&emsp;字模式中，DMA控制器请求传送一个字并得到这个字，如果CPU也需使用总线，则必须等待。称为**周期窃取**。评价：会轻微的延迟CPU。
>&emsp;&emsp;块模式中，DMA控制器通知设备获得总线，发起一连串的传送，然后释放总线。称为**突发模式**。评价：效率高，但是长时间的突发传送会阻塞CPU和其它设备。

&emsp;&emsp;多数DMA控制器使用物理地址，少数DMA控制器使用虚拟地址，然后用MMU将虚拟地址转为物理地址。

&emsp;&emsp;使用磁盘设备缓冲区的原因：
&emsp;&emsp;（1）在传送前检验校验和。
&emsp;&emsp;（2）一旦传输开始，数据就能以固定速率到达。

## 1.5 中断
&emsp;&emsp;当一个I/O设备完成工作时，就产生一个中断。中断导致CPU停止正在做的工作而开始另一个工作。

![2](https://www.github.com/liao20081228/blog/raw/master/图片/输入与输出/2.png)
>**原理**：
>1. 设备通过分配的一条信号总线置起信号，由中断控制器检测该信号，并决定做什么。
>2. 如果没有其它中断未响应，则中断控制器立即处理；否则，就在总线上置起信号，直到得到响应。
>3. 为了处理中断，中断控制器在地址线上放置一个数字（指向中断向量的表格的索引）表明是哪个设备，并置起一个中断CPU的信号。
>4. 中断服务开始后，CPU立刻将一个确定值写入中断控制器的I/O端口以对中断作出应答，告知中断控制器可以自由地发出另一个中断。

&emsp;&emsp;中断服务开始前，需要保存一些信息：
&emsp;&emsp;（1）寄存器。问题：为了避免随后的中断会重写寄存器，所以不能响应随后的中断。
&emsp;&emsp;（2）堆栈。问题：当前堆栈可能是用户堆栈，而内核堆栈要切换MMU上下文。

&emsp;&emsp;流水线技术导致中断发生时，程序计数器的值无法正确反映已经执行和未执行指令的边界。超标量技术导致中断发生时，许多指令处于不同状态。

&emsp;&emsp;**精确中断和非精确中断**：将机器留在一个明确状态的中断叫做精确中断，否则，叫做非精确中断。
&emsp;&emsp;**精确中断的特点**：
&emsp;&emsp;（1）程序计数器PC保存在一个已知地方。
&emsp;&emsp;（2）PC所指指令之前的指令都已执行。
&emsp;&emsp;（3）PC所指指令之后的指令都没有执行。
&emsp;&emsp;（4）PC所指指令的执行状态已知。

# 2 I/O软件原理
## 2.1 I/O软件目标

* **设备独立性**：可以访问任意I/O设备而无需事先指定设备。
* **统一命名**：文件或设备的名字是字符串或整数，不依赖设备。
* **错误处理**：接近硬件层得到处理。
* **同步和异步**：
* **缓冲**
* **共享设备和独占设备**

## 2.2 三种I/O方式

* **程序控制I/O**：I/O的最简单形式是让CPU做全部工作。**缺点**:直到全部IO完成前要占用CPU的全部时间。
* **中断驱动I/O**：使CPU在等待设备变为就绪的同时做某些其他事情。**缺点**是中断发生在每个字符上，浪费时间。
* **使用DMA的I/O**：由DMA控制器处理全部的I/O工作，使CPU可以在I/O期间做其他工作。**缺点**：当DMA不能以全速驱动设备或CPU等待DMA中断时无其它事情要做，则使用程序控制IO或中断驱动IO更好。

# ３ I/O软件层次
![3](https://www.github.com/liao20081228/blog/raw/master/图片/输入与输出/3.jpg)

## 3.1 中断处理程序
&emsp;&emsp;将中断隐藏在OS内部，**方式**：将启动IO的驱动程序阻塞到IO操作完成，并且产生中断。
&emsp;&emsp;**中断处理过程**：
>1. 保存没有被中断硬件保存的所有寄存器（包括PSW）。
>2. 为中断服务过程设置上下文，如TLB、MMU、页表等。
>3. 为中断服务过程设置堆栈。
>4. 应答中断控制器，如果不存在几种的中断控制器，则再次开放中断。
>5. 将寄存器从保存的地方复制到进程表中。
>6. 运行中断服务过程，从发出中断的设备控制器的就趁年轻中提取信息。
>7. 选择下一次运行哪个进程。
>8. 为下一次要运行的进程设置MMU、TLB等。
>9. 装入进程的寄存器，PSW。
>10. 运行新进程。

## 3.2 设备驱动程序
&emsp;&emsp;连接到计算机上的设备大多需要特定代码来对其进行控制。这些代码就是**驱动程序**。

&emsp;&emsp;驱动程序大部分位于内核空间；而少数位于用户空间，可以防止驱动干扰内核。

&emsp;&emsp;大多数操作系统都定义了一个所有块设备必须支持的标准接口和一个所有字符设备都必须支持的标准接口。

&emsp;&emsp;**设备驱动程序的功能**：

>  1. 接收上层与设备无关的软件所发出的抽象读写请求，并目睹这些请求被执行。
> 2. 初始化设备。
> 3. 驱动程序启动时，要检查输入参数。
> 4. 将抽象事项转为具体事项。
> 5. 检查设备是否在使用。
> 6. 检查硬件状态。
> 7. 启动设备。

&emsp;&emsp;多数数时候，驱动程序将阻塞自身直到中断到来解除阻塞。少数情况，不需要阻塞。

&emsp;&emsp;驱动程序必须可重入。也不能进行系统调用。

## 3.3 与设备无关的I/O软件
&emsp;&emsp;**基本功能**：执行对所有设备公共的IO功能，并向用户层软件提供一个统一的接口。

>* 设备驱动程序的统一接口
>   * 驱动程序与操作系统的接口可以各自不同，也可以统一。、
>   * 将符号化的设备名映射到适当的驱动程序上。
>   * 访问权限保护。
>* 缓冲
>   * 无缓冲。**缺点**：每次单位数据的到来都要发生中断，频繁的启动用户进程。
>   * 用户空间的缓冲。**缺点**：缓冲区可能调出内存。**解决办法**：禁止缓冲区换出。
>   * 内核空间的缓冲复制到用户空间。缺点：数据到来时正在复制缓冲区。
>   * 内核空间的双缓冲。
>   * 循环缓冲。
>   * 缓冲是一种广泛采用的技术，但如果数据被缓冲太多次，性能就会降低。
>* 错误报告
>   * 编程错误。
>   * 实际IO错误。
>* 分配和释放专用设备
>* 与设备无关的块大小，不同的设备块大小不一样，与设备无关的IO软件隐藏这种区别，并向高层提供统一的块大小。

## 3.4 用户空间的I/O软件
&emsp;&emsp;用户层I/O软件不一定是库函数。
&emsp;&emsp;SPOOLing
&emsp;&emsp;守护进程

# 4 盘
## 4.1 盘硬件
&emsp;&emsp;**基本知识**：硬盘有数个盘片，每盘片两个面，每个面一个磁头，磁头旋转一周的圆形轨迹为**磁道***，每个磁道被等分为若干个弧段，这些弧段便是**扇区**，不同盘片相同半径构成的圆柱面即**柱面** ，存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数 。
&emsp;&emsp;**重叠寻道**：磁盘控制器可以同时控制多个驱动器进行寻道。
&emsp;&emsp;**磁盘几何规格**：柱面数、磁头数、扇区数。物理几何规格与虚拟几何规格往往不同。**原因**：隐藏物理细节，由磁盘控制器重新映射。

&emsp;&emsp;**RAID**：将很多磁盘组成磁盘组，用RAID控制器替换磁盘控制器，将数据切割成许多区段，分别存放在各个硬盘上，提升性能。**产生原因**：CPU与硬盘的性能差距不断增大。**理论**：并行I/O。
&emsp;&emsp;**条带化**：将连续的数据轮转地分布在多个驱动器上。
>![4](https://www.github.com/liao20081228/blog/raw/master/图片/输入与输出/4.png)
>
>* **RAID 0**：RAID 0以位、字节、块或记录为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余，因此并不能算是真正的RAID结构。RAID 0只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据。因此，RAID 0不能应用于数据安全性要求高的场合。
>* **RAID 1**：它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。
>* **RAID 01或者RAID 10**: 实际是将RAID 0和RAID 1标准结合的产物，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘作磁盘镜像进行冗余。它的优点是同时拥有RAID 0的超凡速度和RAID 1的数据高可靠性，但是CPU占用率同样也更高，而且磁盘的利用率比较低。
>* **RAID 2**：将数据条块化地分布于不同的硬盘上，条块单位为位或字节，并使用称为“海明码”的编码技术来提供错误检查及恢复。这种编码技术需要多个磁盘存放检查及恢复信息，使得RAID 2技术实施更复杂，因此在商业环境中很少使用。
>* **RAID 3**：它同RAID 2非常类似，都是将数据条块化分布于不同的硬盘上，区别在于RAID 3使用简单的奇偶校验，并用单块磁盘存放奇偶校验信息。如果一块磁盘失效，奇偶盘及其他数据盘可以重新产生数据；如果奇偶盘失效则不影响数据使用。RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据来说，奇偶盘会成为写操作的瓶颈。
>* **RAID 4**：RAID 4同样也将数据条块化并分布于不同的磁盘上，但条块单位为块或记录。RAID 4使用一块磁盘作为奇偶校验盘，每次写操作都需要访问奇偶盘，这时奇偶校验盘会成为写操作的瓶颈，因此RAID 4在商业环境中也很少使用。
>* **RAID 5**：RAID 5不单独指定的奇偶盘，而是在所有磁盘上交叉地存取数据及奇偶校验信息。在RAID 5上，读/写指针可同时对阵列设备进行操作，提供了更高的数据流量。RAID 5更适合于小数据块和随机读写的数据。RAID 3与RAID 5相比，最主要的区别在于RAID 3每进行一次数据传输就需涉及到所有的阵列盘；而对于RAID 5来说，大部分数据传输只对一块磁盘操作，并可进行并行操作。在RAID 5中有“写损失”，即每一次写操作将产生四个实际的读/写操作，其中两次读旧的数据及奇偶信息，两次写新的数据及奇偶信息。
>* **RAID 6**：与RAID 5相比，RAID 6增加了第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。但RAID 6需要分配给奇偶校验信息更大的磁盘空间，相对于RAID 5有更大的“写损失”，因此“写性能”非常差。较差的性能和复杂的实施方式使得RAID 6很少得到实际应用。
>* **RAID 7**：这是一种新的RAID标准，其自身带有智能化实时操作系统和用于存储管理的软件工具，可完全独立于主机运行，不占用主机CPU资源。RAID 7可以看作是一种存储计算机（Storage Computer），它与其他RAID标准有明显区别。除了以上的各种标准（如表1），我们可以如RAID 0+1那样结合多种RAID规范来构筑所需的RAID阵列，例如RAID 5+3（RAID 53）就是一种应用较为广泛的阵列形式。用户一般可以通过灵活配置磁盘阵列来获得更加符合其要求的磁盘存储系统。
>* **RAID 5E**(RAID 5 Enhencement): RAID 5E是在RAID 5级别基础上的改进，与RAID 5类似，数据的校验信息均匀分布在各硬盘上，但是，在每个硬盘上都保留了一部分未使用的空间，这部分空间没有进行条带化，最多允许两块物理硬盘出现故障。看起来，RAID 5E和RAID 5加一块热备盘好象差不多，其实由于RAID 5E是把数据分布在所有的硬盘上，性能会比RAID5 加一块热备盘要好。当一块硬盘出现故障时，有故障硬盘上的数据会被压缩到其它硬盘上未使用的空间，逻辑盘保持RAID 5级别。
>* **RAID 5EE**: 与RAID 5E相比，RAID 5EE的数据分布更有效率，每个硬盘的一部分空间被用作分布的热备盘，它们是阵列的一部分，当阵列中一个物理硬盘出现故障时，数据重建的速度会更快。
>* **RAID 50**：RAID50是RAID5与RAID0的结合。此配置在RAID5的子磁盘组的每个磁盘上进行包括奇偶信息在内的数据的剥离。每个RAID5子磁盘组要求三个硬盘。RAID50具备更高的容错能力，因为它允许某个组内有一个磁盘出现故障，而不会造成数据丢失。而且因为奇偶位分部于RAID5子磁盘组上，故重建速度有很大提高。优势：更高的容错能力，具备更快数据读取速率的潜力。需要注意的是：磁盘故障会影响吞吐量。故障后重建信息的时间比镜像配置情况下要长。

  
## 4.2 格式化 
&emsp;&emsp;硬盘由一叠铝的、合金的或玻璃的盘片组成，在每个盘片上沉积着薄薄的可磁化的金属氧化物。 
&emsp;&emsp;在使用磁盘之前，每个盘片必须经受由软件完成的低级格式化。格式化的结果是磁盘容量减少，减少的量取决于前导码、扇区间间隙等。通常格式化的容量比未格式化的容量低20% 。 
>&emsp;&emsp;**低级格式化**：将磁盘划分出磁道（柱面），再将磁道划分出扇区，扇区之间有间隙，每个扇区又划分出标识部分ID前导码、数据区和ECC等。
>&emsp;&emsp;**扇区格式**：前导码-数据-ECC。
>>* **前导码**：扇区开始标识、柱面号、扇区号等。
>>* **ECC**：用于恢复读错误。
>>
>&emsp;&emsp;**柱面斜进**：每个此道上的0号扇区与前一此道存在偏差。**目的**：是使磁盘再一次连续的操作中读取多个此道而不丢失数据。当然也存在**磁头斜进**。

&emsp;&emsp;在低级格式化完成后，要对磁盘分区。在逻辑上，每个分区就像是一个独立的磁盘。分区对多个操作系统共存是必需的。包括：**MBR和GPT**。 
&emsp;&emsp;最后，对每个分区进行一次**高级格式化**。这一操作要设置一个引导块、空闲存储管理、根目录和一个空文件系统，还要讲一个代码放在分区表项中，以表明在分区中使用了那种文件系统。
## 4.3 磁盘臂调度算法
&emsp;&emsp;**磁盘IO性能的决定因素**：寻道时间、旋转时间、传输时间。其中寻道时间是主要因素。
&emsp;&emsp;磁盘臂调度算法：先来先服务、最短寻道优先、扫描算法，循环扫描算法。
&emsp;&emsp;**平均寻道长度**：寻找所有磁道所需移动的距离之和除以总的所需访问的磁道数。
>* **FCFS**：按照请求顺序依次处理请求。**评价**：磁盘臂来回移动，寻道时间较长。
>* **SSTF**：下一次总是处理与磁头距离最近的请求。**评价**：大幅减少寻道时间，但磁盘臂来回移动，会出现饥饿。
>* **SCAN**：磁头前进方向上的SSTF算法。**评价**：磁盘臂不会来回移动，消除饥饿，是一种简单、使用且高效的调度算法。但在实现时，不仅要记住读写磁头的当前位置，还必须记住移动臂的当前前进方向。
>* **CSCAN**：返程不处理任何请求的SCAN算法。

&emsp;&emsp;磁盘调度算法是基于虚拟几何规格与物理几何规格相同。

## 4.4 错误处理
&emsp;&emsp;**对坏块的处理**：在控制器中处理，或在操作系统中进行处理。
&emsp;&emsp;**处理办法**：备份扇区重映射，或者所有扇区前移
## 4.5 稳定存储器
&emsp;&emsp;**稳定存储器**：当收到写命令时，要么什么也不做，要么正确的写数据。
&emsp;&emsp;**原因**：扇区可能变坏，磁盘可能出意外，RAID不能处理写错误。
&emsp;&emsp;**理论基础**：
>* 写操作要么正确，要么错误，并且可在读操作中通过ECC检测出。
>* 在一定时间内，两个相同磁盘中存放相同数据的扇区都变坏的可能性几乎为0.
>* CPU故障时，只能停机，磁盘操作也会停止。

&emsp;&emsp;**原理**：用一对完全相同的磁盘，对应的块一同工作，存放相同的数据，以形成无差错的块。并定义三张操作：
> 1. **稳定写**：先写入磁盘1，随后读以检验是否正确。如果不正确，则重复读写，直到正确。如果多次失败，则将该块映射到备用块，用相同的方式直到正确的写入数据。然后，以相同的方式写入磁盘2。
>2. **稳定读**：先从磁盘1读，如果出错则重复读，如果多次出错，则从磁盘2读。
>3. **崩溃恢复**：恢复程序扫描对比两个磁盘，比较对应块：
>    * 若一对对应块都是好的且相同，则什么都不做。
>    * 若其中一个ECC出错，则用好的块覆盖坏的块。
>    * 若一对块都是好的但不同，则用磁盘1的块覆盖磁盘2的块。
>    * 若CPU崩溃：
>       * 发生在写之前。两个块好的且一样，保留旧值。
>       * 发生在写磁盘1期间，坏块，用磁盘2好块覆盖磁盘1坏块，恢复旧值。
>       * 发生在写完磁盘1后，写磁盘2前，从磁盘1拷贝到磁盘2。写成功。
>       * 发生在写磁盘2期间，坏块，用磁盘1好块覆盖磁盘2坏块。写成功。
>       * 发生在写完磁盘2之后。两个块好的且一样，写成功。
>4. **改进**：用非易失RAM跟踪崩溃前所写的块。恢复时不用再比较所有的块。如果没有非易失RAM，则可以在写之前先在某处写入要写的块号，稳定写后再覆盖掉。
# 5 时钟

&emsp;&emsp;**简单时钟**：直接利用电源的周期。
&emsp;&emsp;**现代时钟**：晶体振荡器、计数器、存储寄存器。

&emsp;&emsp;**一次完成模式**：时钟启动时，将存储寄存器的值复制到寄存器，每次脉冲使计数器减1，当计数器为0时，产生一个中断，并停止工作，直到显式重启。
&emsp;&emsp;**方波模式**：当计数器为0并发出中断后，自动将存储寄存器复制到计数器。
&emsp;&emsp;**时钟滴答**：周期性的中断。

>**时钟硬件的作用**：产生中断。
>**时钟驱动程序的作用**：
>
>* 维护实际时间
>* 防止进程超时运行
>* 对CPU使用情况记账
>* 处理用户进程提出的alarm系统调用
>* 为系统本身各部分提供监视定时器
>* 完成概要剖析、监视和统计信息收集

 &emsp;&emsp;管理IO有两种方法：中断和轮询。中断延迟小但开销大，轮序等待时间长。
 &emsp;&emsp;**软定时器**：无论何时，由内核态在返回用户态之前，都要检查实时时钟，看软件定时器是否已经过期。如果已到期，则执行预定事件，而不需要切换到内核模式，因为系统已经在内核态。工作完成后，软计时器复位。所有需要做的就是将当前的时钟值复制到定时器，并为其添加超时间隔。**优点**：避免中断开销。**缺点**：不精确，因为软定时器会随着由于系统调用、TLB未命中、页面错误、IO中断、CPU空闲等原因陷入内核的频率而停顿或下降。 
# 6 键盘、鼠标、监视器
&emsp;&emsp;**终端**：计算机网络中最外围的设备，主要用于信息的输入输出。
## 6.1 输入软件
### 6.1.1 键盘软件
&emsp;&emsp;**键盘硬件功能**：给出键被按下和释放的中断。
&emsp;&emsp;**键盘驱动程序的功能**：确定键入的值，并按原始模式或加工模式提供给用户程序。

>* **原始模式**：接收输入并不加修改的向上层传送。
>* **加工模式**：处理全部行内编辑，将加工后的行向上传送。

&emsp;&emsp;**回显**：刚刚键入的字符出现屏幕上。
### 6.1.2 鼠标软件
&emsp;&emsp;鼠标移动一个最小距离或者按下按键时都会发送一个消息。包括三个项目：x增量，y增量，按键。
## 6.2 输出软件
* 文本窗口
* X窗口系统
* 图形用户界面
* 位图
* 字体
* 触摸屏

# 7 瘦客户机

&emsp;&emsp;**瘦客户机**是使用专业嵌入式处理器、小型本地DOM电子盘、精简版操作系统的基于PC工业标准设计的小型行业专用商用PC。
 
# 8 电源管理
&emsp;&emsp;减少电能消耗的两种方法
>* 某些设备不用时由操作系统将其睡眠、休眠或者关闭。
* 让程序使用较少的电能。


------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文章参考了<font color=blue >塔嫩鲍姆的《现代操作系统》、汤子瀛的《 计算机操作系统》。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------