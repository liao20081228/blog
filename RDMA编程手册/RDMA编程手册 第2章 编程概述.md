---
title: RDMA编程手册 第2章 编程概述
tags: RDMA
---

------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>[《RDMA Aware Networks Programming User Manual v1.7》](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf)、[《Dotan Barak的RDMAmojo博客》](http://www.rdmamojo.com/)、《Ubuntu19.10 rdma-core套件 man手册v24.0》，我所做的工作就是更新、整理一部分内容，删除了一部分废弃的API，添加了一部分新的API。</font><font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------


# 0 简介

VPI架构允许直接以用户模式访问硬件。 Mellanox提供了一个动态加载的库，可通过动词API创建对硬件的访问。本文档包含动词及其通过操作系统编程接口公开的相关输入，输出，描述和功能。

注意：本编程手册及其动词仅对用户空间有效。有关内核空间动词，请参见头文件。

使用动词进行编程可以自定义和优化RDMA-Aware网络。只有具有VPI系统高级知识和经验的程序员才能进行这种自定义和优化。

为了执行RDMA操作，首先需要建立到远程主机的连接以及适当的权限。完成此任务的机制是队列对（QP）。对于那些熟悉标准IP堆栈的人来说，QP大致等同于套接字。 QP需要在连接的两侧进行初始化。在实际设置QP之前，可以使用Communication Manager（CM）来交换有关QP的信息。


一旦建立了QP，动词API即可用于执行RDMA读取，RDMA写入和原子操作。也可以执行类似于套接字read/write的序列化send/receive操作。

# 1 可用的通信操作
## 1.1 发送/带立即数发送

通过发送操作，您可以将数据发送到远程QP的接收队列。 接收者必须事先发布接收缓冲区才能接收数据。 发送方无法控制数据在远程主机中的驻留位置。

可选地是，4字节立即数可与数据缓冲区一起发送。 该立即数作为接收通知的一部分提供给接收器，并且不包含在数据缓冲区中。

## 1.2 接收
这是发送操作的对应操作。 接收主机被通知数据缓冲区已经被接受，可能带有内联的立即数。 接收应用程序负责接收缓冲区的维护和发布。

## 1.3 RDMA读

从远程主机读取一部分内存。 调用者指定远程虚拟地址以及将要复制到的本地内存地址。 在执行RDMA操作之前，远程主机必须提供适当的权限来访问其内存。 一旦设置了这些许可权，就可以进行RDMA读取操作，而不会向远程主机发出任何通知。 对于RDMA读和写，远程端都不知道此操作已完成（除了准备许可和资源外）。

## 1.4 RDMA写/带立即数的RDMA写
类似于RDMA读取，但是数据被写入远程主机。 执行RDMA写操作时不会通知远程主机。 但是，带立即数的RDMA写操作确实会将立即数通知给远程主机。

## 1.5 原子取回和添加/原子比较和交换

这些是RDMA操作的原子扩展。

原子取回和添加操作原子地将指定虚拟地址处的值增加指定量。 增加之前的值将返回给调用方。

原子比较和交换将原子比较指定虚拟地址处的值与指定值，如果它们相等，则指定值将存储在该地址处。

# 2 传输模式

在建立QP时，您可以在几种不同的传输模式中选择一种。每种模式下可用的操作如下表所示。libibverbs不支持RD API。

|操作|UD|UC|RC|RD|
| :-- |:---: | :---: |:---: | :---:|
| SEND（带立即数 )|    V |   V |    V |   V |
| RECV                     |   V  |    V |   V  | V    |
| RDMA WRITE（带立即数）          |     |    V |   V  |   V |
| RDMA READ                      |     |     |   V  |    V |
| atomic：取回和添加/比较和交换 |     |     |    V |    V |
| 最大消息大小                |  MTU   | 2GB    |  2GB    |     2GB |
|可靠性|||V|？|
|连接类型|数据报（一对任何，一对多）|有连接的（一对一）|有连接的（一对一）|？|
|多播|V|||？|

详细信息见ibv_post_send。

## 2.1 可靠连接（RC）

队列对仅与另一个QP相关联。

一个QP的发送队列发送的消息被可靠地传递到另一个QP的接收队列。

数据包按顺序传送。

RC连接与TCP连接非常相似。

## 2.2 不可靠连接（UC）

队列对仅与另一个QP相关联。

连接不可靠，因此数据包可能会丢失。

传输不会重试带有错误的消息，并且错误处理必须由更高级别的协议提供。

## 2.3 不可靠数据报（UD）

队列对可以向/从任何其他UD QP发送/接收单分组消息。

无法保证顺序和交付，并且接收方可能会丢弃已交付的数据包。

支持多播消息（一对多）。

UD连接与UDP连接非常相似。

# 3 关键慨念
## 3.1 发送请求（SR）

SR定义了使用RDMA从何处将多少数据怎样发送到何地。`struct ibv_send_wr`用于实现SR。

## 3.2 接受请求（RR）

RR定义了用于非RDMA操作的接收数据的缓冲区。 如果未定义缓冲区，并且传输企图进行一个带有立即数的发送或RDMA写操作，则将发送一个接受未就绪（RNR）错误。 `struct ibv_recv_wr`用于实现RR。

## 3.3 完成队列（CQ）

完成队列是一个对象，其中包含已发布到工作队列（WQ，包括SQ和RQ）的已完成的工作请求（WR，包括SR和RR）。 每个完成都表示指定的WR已完成（成功完成WR和未成功完成WR）。

完成队列是一种机制，用于通知应用程序关于已结束的工作请求的信息（状态，操作码，大小，源）。

CQs具有n个完成队列条目（CQE）。CQE的数是创建CQ时指定的。

当一个CQE被轮询到时，会将其从CQ中删除。

CQ是CQE的FIFO。

CQ可以为发送队列、接收队列、发送队列和接收队列提供服务。

来自多个QPs的工作队列可以与单个CQ相关联。

`struct ibv_cq`用于实现CQ。

## 3.4 内存注册（MR）

内存注册是一种机制，它允许应用程序描述到网卡的一组虚拟连续内存位置或一组物理连续内存位置为使用虚拟地址的虚拟连续缓冲区。

注册过程将内存页面固定（以防止页面换出并保持物理地址与虚拟地址映射）。

在注册过程中，操作系统会检查已注册内存块的权限。

注册过程将虚拟地址到物理地址的表写入网络适配器。

注册内存时，将为该区域设置权限。权限包括本地写入，远程读取，远程写入，原子和绑定。

每个MR都有一个远程密钥和一个本地密钥（r_key，l_key）。本地HCA使用本地密钥来访问本地内存，例如在接收操作期间。在RDMA操作期间，将远程密钥分配给远程HCA，以允许远程进程访问系统内存。

同一内存缓冲区可以注册多次（即使具有不同的访问权限），并且每次注册都会导致不同密钥集。

`struct ibv_mr`用于实现内存注册。


## 3.5 内存窗口
MW使应用程序可以更灵活地控制对其内存的远程访问。

内存Windows适用于以下情况：

* 希望以动态方式授予和撤销对已注册区域的远程访问权限，与使用注销/注册或重新注册相比，其性能损失要小一些。

* 希望向不同的远程代理授予不同的远程访问权限，或在注册区域内的不同范围内授予这些权限。

将MW与MR相关联的操作称为绑定。

不同的MW可以重叠同一MR（具有不同访问权限的事件）。


## 3.6 地址向量（AH）

地址向量是一个对象，它描述从本地节点到远程节点的路由。

在每个UC/RC QP中，QP上下文中都有一个地址向量。

在UD QP中，应在每个发布的SR中定义地址向量。

`struct ibv_ah`用于实现地址向量。
  
## 3.7 全局路由头部（GRH）

GRH用于子网之间的路由。 使用RoCE时，GRH用于子网内的路由，因此是必需的。 为了使应用程序同时支持IB和RoCE，必须使用GRH。

在UD QPs上使用全局路由时，接收缓冲区的前40个字节中将包含GRH。 该区域用于存储全局路由信息，因此可以生成适当的地址向量以响应收到的数据包。 如果GRH与UD一起使用，则RR应始终为此GRH提供额外的40个字节。

`struct ibv_grh`用于实现GRH。
## 3.8 保护域（PD）

其组件只能彼此交互的对象。 这些组件可以是AH，QP，MR和SRQ。

保护域用于将QP与MR和MW相关联，作为启用和控制网络适配器对主机系统内存的访问的一种方式。

PDs还用于将UD QPs与地址句柄相关联，作为控制对UD目标的访问的一种方式。

`struct ibv_pd`用于实现保护域。

## 3.9 异步事件
网络适配器可以发送异步事件以通知SW有关系统中发生的事件。

异步事件有两种类型：

**关联事件**：个体对象（CQ，QP，SRQ）发生的事件。 这些事件将被发送到特定的进程。

**独立事件**：全局对象发生的事件（网络适配器，端口错误）。 这些事件将发送到所有进程。

## 3.10  分散集中
使用分散集中元素来收集/分散数据，这些元素包括：

地址：将要从中收集或分散数据的本地数据缓冲区的地址。

大小：将从该地址读取/写入的数据的大小。

L_key：已注册到此缓冲区的MR的本地密钥。

`struct ibv_sge`实现分散收集元素。
## 3.11 轮询
为完成而轮询CQ将获取有关已发布的WR（发送或接收）的详细信息。

如果在一个WR中，完成的状态为bad，则其余的完工的状态都将是bad（并且工作队列将移至错误状态）。

每个没有完成（已轮询）的WR仍然是未完成的。

仅在WR有一个完成后，才可以使用/重用/释放 发送/接收缓冲区。

应该始终检查完成状态。

轮询CQE时，会将其从CQ中删除。

轮询是通过`ibv_poll_cq`操作完成的。


# 4 QP状态
由于QP是RDMA中的重要对象之一，我将在接下来的几篇文章中处理它。

## 4.1 QP状态转变
在QP生命周期中，可能的状态为:
* 重置（Reset）
* 初始化 (Init)
* 准备接收 (RTR)
* 准备发送 (RTS)
* 发送队列耗尽(SQD)
* 发送队列出错 (SQE)
* 出错（Error）

QP可以通过两种可能的方式从一种状态转变到另一种状态:

1. 显式调用ibv_modify_qp()。
2. 在处理错误时由设备自动转变。

QP被创建时处于重置状态。

任何状态的任何QP都可以通过调用ibv_modify_qp()转变为为Reset或Error状态。

![图4](https://raw.githubusercontent.com/liao20081228/blog/master/图片/RDMA_Aware网络编程手册.md/图4.jpg)

## 4.2 Reset状态
**描述**

QP被创建时处于重置状态。 在此状态下，QP的所有所需资源都已经分配了。

为了重用QP，可以通过调用ibv_modify_qp（）将其从任何状态转换为重置状态。 如果在此状态转换之前，该QP的发送或接收队列中有任何WR或完成，则会从队列中将其清除。

**工作请求**

工作请求不应发布到发送或接收队列。 尝试这样做将导致立即错误。

发送和接收队列中的工作请求都不会被处理。

**包**

目标为此QP的传入数据包将被静默丢弃。

该QP不会发送任何数据包。

## 4.3 Init状态

**描述**

为了转变到这个状态，必须在Reset状态调用ibv_modify_qp()。

**工作请求**

工作请求仅可以发布到接收队列中。 尝试将工作请求发布到发送队列将导致立即错误。

发送和接收队列中的工作请求都不会被处理。

**包**

目标为此QP的传入数据包将被静默丢弃。

该QP不会发送任何数据包。

## 4.4 RTR状态
**描述**

为了转变到这个状态，必须在Init状态调用ibv_modify_qp()。

在RTR状态下，QP只能用作响应者。

**工作请求**

工作请求可以发布到接收队列中。 尝试将工作请求发布到发送队列将导致立即错误。

仅接收队列中的工作请求会被处理。

**包**

目标为此QP的传入数据包将被保存。 QP将以响应者从该QP发送数据包（即数据，acks和nacks）。

## 4.5 RTS状态
**描述**

为了转变到这个状态，必须在RTR或SQD状态调用ibv_modify_qp()。

在RTS状态下，QP可以用作响应者或请求者。

**工作请求**

工作请求可以发布到接收队列和发送队列中。

接收队列和发布队列中的工作请求都会被处理。

**包**

目标为此QP的传入数据包将被保存。 QP将以响应者从该QP发送数据包（即数据，acks和nacks）。

QP可以作为请求者发出数据包。

## 4.6  SQD状态
**描述**

为了转变到这个状态，必须在RTS状态调用ibv_modify_qp()。

此状态仅影响发送队列: 已经开始处理的WR会继续处理直到完成，新的WR将不会被处理。

这种状态分为两种内部状态:
* 正在消耗——发送队列中仍有将要处理的工作请求。
* 已耗尽——发送队列中没有任何将要处理的工作请求。

仅当QP的内部状态为已耗尽时，才可以将该QP的状态转换为RTS或SQD。

**工作请求**

工作请求可以发布到接收队列和发送队列中。

接收队列中的工作请求将被处理。

已开始处理的发送队列中的工作请求将继续处理直到完成，新工作请求将不被处理。


**包**

目标为此QP的传入数据包将被保存。 QP将以响应者从该QP发送数据包（即数据，存acks和nacks）。

QP可以作为请求者发出数据包。

## 4.7 SQE状态
**描述**

除了RC QPs，对于所有处于RTS状态且发送队列处理了工作请求并以完成错误结束的QP类型，设备姿容转变为SQE状态。该工作请求的状态是未定义的（如果工作请求已经部分或完全处理，则是未知的），并且本地或远程缓冲区的内容（取决于所使用的操作码）是未定义的。

发送队列中的所有后续工作请求将因为错误而被刷新。

可以调用ibv_modify_qp（）返回到RTS状态以恢复发送队列。

**工作请求**

工作请求可以发布到接收队列和发送队列中。

仅接收队列中的工作请求将被处理。

发送队列中的所有后续工作请求将因为错误而被刷新。


**包**

目标为此QP的传入数据包将被保存。QP将以响应者从该QP发送数据包（即数据，存acks和nacks）。





## 4.8 Error状态
**描述**

这是QP状态机中的最后一个状态。

如果RC QP中发送队列中的工作请求因错误完成，或任意QP中接收队列中的工作请求因错误完成，则设备可能会自动将QP自动转变为此状态。 或从任何状态调用ibv_modify_qp（）也可以转为本状态。

如果QP状态自动转换，则此工作请求的状态是未定义的（如果工作请求已经部分或完全处理，则是未知的），并且本地或远程缓冲区的内容（取决于所使用的操作码）是未定义的。

**工作请求**


工作请求可以发布到接收队列和发送队列中。

如果QP自动转换到此状态，则第一个因错误完成的工作请求将指示错误原因。 该队列中的所有后续工作请求，另一个队列中的所有工作请求以及发布到两个队列中的新工作请求都将因错误而被刷新。

如果使用ibv_modify_qp（）将QP转换为此状态，则发送和接收请求中所有未完成的工作请求都将因错误而被刷新。

**包**

目标为此QP的传入数据包将被静默丢弃。

该QP不会发送任何数据包。

## 4.9 总结

在本节，我们讨论了QP的各种状态以及QP的行为。

下表总结了QP的行为取决于它的状态:

||Reset|Init|RTR|RTS|SQD|SQE|Error|
|:--|:--|:--|:--|:--|:--|:--|:--|
|发布到接收队列|禁止|允许|允许|允许|允许|允许|允许|
|发布到发送队列|禁止|禁止|禁止|允许|允许|允许|允许|
|接收请求处理|不处理|不处理|处理|处理|处理|处理|因错误刷新|
|发送请求处理|不处理|不处理|不处理|处理|新的WR不处理|因错误刷新|因错误刷新|
|传入的包|静默丢弃|静默丢弃|处理|处理|处理|处理|静默丢弃|
|响应的包|无|无|有|有|有|有|无|
|传出的包|无|无|无|发出|发出|无|无|

# 5 使用QP状态
在2.4中，我们讨论了各种QP状态。在本节中，我将尝试解释为什么需要这些状态，以及如何在每个状态中使用QP。

## 5.1 Reset状态

QP可以通过两种方式转为Reset状态:

* 创建
* 通过调用ibv_modify_qp()将它从任何其他状态转变为Reset状态

当创建QP时，会花费一些时间（存在上下文切换，工作队列缓冲区的内存分配，QP编号分配等）。

如果需要在快速路径中使用新的QP，以下内容：

* 创建一个QP
* 使用QP（修改为RTS并发送/接收数据）
* 销毁QP

的更好的替代方法是：只创建一次QP，然后在需要时执行以下操作:

* 使用QP（修改为RTS并发送/接收数据）
* 修改QP为Reset状态，以供以后使用

当QP不再需要时，它可以被销毁。

重用相同的QP可能比每次创建它更快。 将QP从任何其他状态转变为Reset状态将清除先前事务中的所有遗留物（例如发送和接收队列中的工作请求和完成）。

但是，不建议在同一节点之间使用相同的QP，因为可能会发生意外结果（数据包丢失）。

将QP移到“reset”状态将阻止QP发送或接收数据包。

## 5.2 Init状态
将QP转变为RTR状态时，QP将处理传入的数据包。 如果在转变到RTR状态后由于某种原因（例如：OS调度程序没有给该进程分配时间），工作请求没有被发布到该QP的接收队列中，则那些数据包的请求者可能发生接收器未就绪（RNR）错误 。 为了防止这种情况的发生，可以将接收请求发布到处于Init状态的QP。 在将QP转换为RTR状态之前，不会处理那些工作请求。

## 5.3 RTR状态
在这种状态下，QP处理传入的数据包。 如果不将QP用作请求者（工作请求不被发布到它的发送队列中），则QP可能会保持RTR状态。

## 5.4 RTS状态

在大多数应用程序中，QP将转变为RTS状态。 在这种状态下，QP可以作为请求者发送数据包并处理传入数据包。

即使您的QP不会充当请求者，也可以将其转换为此状态。

## 5.5 SQD状态
如果希望更改某些发送队列属性，则应将QP转换为SQD状态，修改所需的属性，然后将QP转变回RTS状态以使其能够继续发送数据包。

## 5.6 SQE状态
只有在发送队列中的工作请求因错误而完成的情况下，设备才能自动将QP转换为此状态。 在这种状态下，发送队列无法作为请求者发送数据包。 如果希望从该状态恢复QP，则应将QP修改回RTS状态。

## 5.7 Error状态
QP可以通过两种方式移动到Error状态：

1. RDMA设备在因错误而完成时，自动转变
2. 从其他任何状态将QP转为Error状态

如果发生错误，则在队列（发送或接收队列）的完成队列中第一次获得错误的完成将保持指示错误原因的状态。 该队列和其他队列中的其余工作请求将因错误刷新。

此状态对于回收所有工作请求以释放其缓冲区很有用（例如，如果工作请求中的属性wr_id指定了此工作请求使用的缓冲区）。

将QP转变为“Error”状态将阻止QP发送或接收数据包。

## 5.8 销毁QP

这本身并不是一个QP状态，但是当用户完成了QP的工作，并且希望阻止QP发送或接收数据包时，他可以销毁它。

# 6 典型应用
本文档提供了两个程序示例:
* 第一个代码，RDMA_RC_example，使用VPI动词API，说明如何执行RC：发送，接收，RDMA读取和RDMA写入操作。
* 第二个代码，多播示例，使用RDMA_CM动词API，演示了多播UD。

典型应用程序的结构如下。 编程示例中实现每个步骤的函数以粗体显示。

1. 获取设备列表：
首先你必须或者本地主机上可用IB设备的列表。列表中的每一个设备都含有一个名字和一个GUID。比如设备名可能是：mthca0, mlx4_1。
在编程示例中由**8.1.4 resources_create**实现。

2. 打开请求的设备：
遍历设备列表，根据其GUID或名称选择一个设备并打开它。
在编程示例中由**8.1.4 resources_create**实现。
 
3. 查询设备功能：          
设备功能使用户可以了解支持的功能（APM，SRQ）和打开的设备的功能。
在编程示例中由**8.1.4 resources_create**实现。

4. 分配一个保护域来包含您的资源：
保护域(PD)允许用户限制哪些组件只能相互交互。这些组件可以是AH、QP、MR、MW和SRQ。
在编程示例中由**8.1.4 resources_create**实现。

5. 注册内存区：
VPI仅适用于已注册的内存。在进程的虚拟空间中有效的任何内存缓冲区都可被注册。 在注册过程中，用户设置内存许可权，并接收本地和远程密钥（lkey / rkey），这些密钥稍后将用于引用此内存缓冲区。
在编程示例中由**8.1.4 resources_create**实现。

6. 创建一个完成队列（QP）：
CQ包含完成的工作请求（WR）。 每个WR将生成一个放置在CQ上的完成队列条目（CQE）。 CQE将指示WR是否成功完成。
在编程示例中由**8.1.4 resources_create**实现。

7. 创建队列对（QP）：
创建QP还将创建关联的发送队列和接收队列。
在编程示例中由**8.1.4 resources_create**实现。

8. 培养一个QP：
创建的QP在经过多个状态转换之前仍然无法使用，最终进入准备发送（RTS）。 这提供了QP用来发送/接收数据所需的信息。
在编程示例中由**8.1.6 connect_qp、8.1.7 modify_qp_to_init、8.1.8 post_receive、8.1.10 modify_qp_to_rtr,、8.1.11 modify_qp_to_rts实现**。
9. 发布工作请求和轮询完成：
使用创建的QP进行通信操作。
在编程示例中由**8.1.12 post_send和8.1.13 poll_completion实现**。

10. 清理：
按照与创建对象相反的顺序销毁对象：
删除QP
删除CQ
注销MR
解除分配PD
关闭设备
在编程示例中由**8.1.14 resources_destroy**实现。
 
 
------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>[《RDMA Aware Networks Programming User Manual v1.7》](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf)、[《Dotan Barak的RDMAmojo博客》](http://www.rdmamojo.com/)、《Ubuntu19.10 的rdma-core套件man手册v24.0》，我所做的工作就是更新、整理一部分内容，删除了一部分废弃的API，添加了一部分新的API。</font><font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------

