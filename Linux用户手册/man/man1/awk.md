---
title: awk
tags: Linux用户命令
---


------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《Linux man手册页》</font>当前版本为sed4.7。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------

# 1 名称

gawk——模式扫描和处理语言。

# 2 概要

``` shell
	gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
	gawk [ POSIX or GNU style options ] [ -- ] program-text file ...
```
# 3 说明

Gawk是GNU工程对AWK编程语言的实现。它符合POSIX 1003.1标准。该版本反过来是基于Aho，Kernighan和Weinberger撰写的《AWK编程语言》中的描述。 Gawk提供了Brian Kernighan awk中的额外功能以及许多特定于GNU的扩展。

命令行由gawk本身选项、AWK程序文本（如果未通过-f或--include选项提供）、在ARGC和ARGV预定义的AWK变量中的可用值组成。

使用--profile选项调用gawk时，它将开始从程序的执行中收集性能分析统计信息。 Gawk在这种模式下运行速度较慢，并且在完成后会自动在文件awkprof.out中生成一个执行配置文件。请参阅下面的--profile选项。

Gawk还具有集成的调试器。可以通过在命令行中指定--debug选项来启动交互式调试会话。在这种执行方式下，gawk将加载AWK源代码，然后提示您调试命令。 Gawk只能调试-f和--include选项提供的AWK程序源码。调试器文档在[高效AWK编程]（#effective_awk_programing）中。

# 4 选项格式

Gawk选项可以是POSIX风格的单字符选项，或者GNU风格的长选项。POSIX选项是以“-”开始，而GNU长选项是以“--”开始。GNU特定功能和POSIX必须功能都提供了长选项。

特定于Gawk的选项通常以长选项形式使用。 长选项的参数可以紧跟在选项后的“=”符号之后（中间没有空格），也可以在下一个命令行参数中提供。 只要缩写保持唯一，就可以长选项就可以缩写。

此外，每一个长选项与偶一个相应的短选项，因此可以在 #!可执行脚本中使用该选项的功能。

# 5 选项
Gawk接受以下选项。 首先列出标准选项，然后列出gawk扩展的选项。按短选项按字母顺序列出。
|短选项|长选项|说明|
|:--|:--|:--|
|-b|--characters-as-bytes|将所有输入数据视为单字节字符。 换句话说，在尝试将字符串作为多字节字符处理时，不必特别注意语言环境信息。 --posix选项将覆盖此选项。|
|-c|--traditional|以兼容模式运行。 在兼容模式下，gawk的行为与Brian Kernighan awk相同； 没有特定于GNU的扩展。 有关更多信息，请参见下面的[GNU扩展](#GNU_EXTENSIONS)。|
|-C|--copyright|在标准输出上打印GNU版权信息的简短版本，然后成功退出。|
|-d\[file]|--dump-variables\[=file]|将全局变量以及它们的类型和最终值的排序列表打印到文件file中。如果未提供文件file，则gawk在当前目录中使用名为awkvars.out的文件。列出所有全局变量是在程序中查找打字错误的好方法。如果您的大型程序具有很多函数，并且还希望确保您的函数不会无意中使用本应是局部变量的全局变量，那么您也可以使用此选项。（使用i，j等简单变量名称时，这是一个特别容易犯的错误。）|
|-D\[file]|--debug\[=file]|启用AWK程序调试。默认情况下，调试器从键盘（标准输入）以交互方式读取命令。可选的file参数指定一个文件，其中包含命令列表，以供调试器以非交互方式执行。|
|-e program-text|--source program-text|使用program-text作为AWK程序源代码。通过此选项，可以轻松地将库函数（通过-f和--include选项使用）与在命令行中输入的源代码混合在一起。它主要用于Shell脚本中的中大型AWK程序。通过-e提供的每个参数都被视为以隐式@namespace "awk"语句开头。|
|-E file|--exec file|与-f相似，但是，此选项是最后处理的选项。这个选项与＃!脚本一起使用，以避免在命令行中从URL传递选项或源代码（！），尤其是CGI应用程序脚本。此选项禁用命令行变量赋值。|
|-f program-file|--file program-file|从文件program-file中读取AWK程序，而不是从第一个命令行参数中读取。可以使用多个-f（或--file）选项。使用-f读取的文件被视为以隐式的@namespace "awk"语句开头。|
|-F fs|--field-separator fs|将fs用作输入字段分隔符（预定义变量FS的值）。|
|-g|--gen-pot|扫描并解析AWK程序，并在标准输出上生成GNU .pot（可移植对象模板）格式文件，其中包含该程序中所有可本地化字符串条目。程序本身未执行。有关.pot文件的更多信息，请参见[GNU gettext](#gnu_gettext)分发。|
|-h|--help|在标准输出上打印可用选项的简短摘要。 （根据GNU编码标准，这选项会导致立即成功退出。）
|-i include-file|--include include-file|加载awk源码库。这将使用环境变量AWKPATH来搜索该库。如果首次搜索失败，则在加上.awk后缀之后再次尝试。该文件将仅加载一次（即消除重复），并且这些代码不构成主程序源码。用--include读取的文件被视为以隐式@namespace “awk”语句开头。|
|-l lib|--load lib|从共享库库中加载gawk扩展。 这将使用环境变量AWKLIBPATH来搜索该库。 如果首次搜索失败，则在为加上平台默认共享库后缀后再次尝试。 库的初始化例程应命名为dl_load（）。|
|-L \[value]|--lint\[=value]|提供有关可疑或不可移植到其他AWK实现的构造的警告。 如果使用fatal的可选参数，则温柔警告会变成致命错误。 这可能很激烈，但是使用它肯定会鼓励开发更清洁的AWK程序。 使用invalid可选参数，仅发出有关确实无效的警告。 （这尚未完全实现）使用no-ext可选参数，将禁用有关gawk扩展的警告。|
|-M|--bignum|对数字强制执行任意精度计算。如果编译gawk未使用GNU MPFR和GMP库，则此选项无效。（在这种情况下，gawk会发出警告。）|
| -n|--non-decimal-data|识别输入数据中的八进制和十六进制值。请谨慎使用此选项！|
|-N|--use-lc-numeric|强制gawk在解析输入数据时使用语言环境的小数点字符。尽管POSIX标准要求此行为，并且当--posix生效时gawk会要求这样做，但默认情况是遵循传统行为，并使用句点作为小数点，即使在句点不是小数点字符的语言环境中也是如此。此选项将覆盖默认行为，而没有--posix选项的严格要求。|
|-o\[file]|--pretty-print\[=file]|将程序的完美打印版本输出到文件file中。如果未提供文件file，则gawk在当前目录中使用名为awkprof.out的文件。此选项暗示-no-optimize。|
|-O| --optimize|在程序的内部表示形式上启用gawk的默认优化。当前，这仅包括简单的常量折叠（一种编译优化技术）。默认情况下，此选项处于启用状态。|
|-p\[prof-file]|-profile\[=prof-file]|启动性能分析会话，然后将性能数据发送到prof-file。默认值为awkprof.out。该配置文件在左边包含程序中每个语句的执行计数，以及每个用户定义函数的函数调用计数。此选项暗示--no-optimize。|
|-P|--posix|这将打开兼容模式，并具有以下限制：<br />&emsp;&emsp;无法识别\x转义序列<br />&emsp;&emsp;在?和:后无法继续<br />&emsp;&emsp;无法识别关键字function的同义词func<br />&emsp;&emsp;不能使用\*\*和\*\*=来代替\^和\^=|
|-r|--re-interval|在正则表达式匹配中启用间隔表达式的使用（请参见下面的[正则表达式](#regexp)）。传统上，间隔表达式在AWK语言中不可用。 POSIX标准添加了它们，以使awk和egrep彼此一致。它们是默认启用的，但此选项仍可与--traditional一起使用。|
|-s|--no-optimize|在程序的内部表示形式上禁用gawk的默认优化。|
|-S|--sandbox|在沙盒模式下运行gawk，禁用system()函数、getline输入重定向，print和printf输出重定向，以及加载动态扩展。命令执行（通过管道）也被禁用。这有效地阻止了脚本访问本地资源，命令行上指定的文件除外。|
|-t|--lint-old|提供有关不可移植到UNIX awk原始版本的构造的警告。|
|-v var=val|--assign var=val|在程序开始执行之前，将值val分配给变量var。这样的变量值可用于AWK程序的BEGIN规则。|
|-V|--version|在标准输出上打印该gawk特定副本的版本信息。 这主要用于了解当前系统上的gawk是否是自由软件基金会正在分发的最新版本。 报告bug时，这也很有用。 （根据GNU编码标准，此选项会导致立即成功退出。）|
|--||选项结束信号。 这允许AWK程序的其他参数以“-”开头。 这与大多数其他POSIX程序使用的参数解析约定保持一致。|

在兼容模式下，任何其他选项均标记为无效，否则将被忽略。 在正常操作中，只要提供了程序文本，在ARGV数组中的未知选项会传递给AWK程序进行处理。这对于通过＃!可执行解释器机制运行AWK程序特别有用。|

为了实现POSIX兼容性，可以使用-W选项，后跟长选项的名称。

# 6 AWK程序执行
AWK程序由一系列可选指令、模式操作语句和可选的函数定义组成。

``` awk
	@include "filename"
	@load "filename"
	@namespace "name"
	pattern   { action statements }
	function name(parameter list) { statements }
```
Gawk首先从program-files（如果指定了）、--source的参数、或命令行上的第一个非选项参数中读取程序源码。 -f和--source选项可以在命令行上多次使用。 Gawk读取程序文本就好像所有程序文件和命令行源码都连接在一起一样。这对于构建AWK函数库很有用，而不必在使用它们的每个新AWK程序中都包含它们。它还提供了将库函数与命令行程序混合的功能。

此外，以@include开头的行可用于将其他源文件包括到您的程序中，从而使库的使用更加容易。这等效于使用--include选项。

以@load开头的行可用于将扩展功能加载到您的程序中。这等效于使用--load选项。|

环境变量AWKPATH指定查找-f和--include选项指定的源文件时使用的搜索路径。如果该变量不存在，则默认路径为“.:/usr/local/share/awk”。 （实际目录可能会有所不同，具体取决于gawk的构建和安装方式。）如果给-f选项指定的文件名包含“/”字符，则不会执行路径搜索。

环境变量AWKLIBPATH指定查找--load选项指定的源文件时要使用的搜索路径。如果该变量不存在，则默认路径为“/usr/local/lib/gawk”。 （实际目录可能会有所不同，具体取决于gawk的构建和安装方式。）

Gawk按以下顺序执行AWK程序。首先，执行通过-v选项指定的所有变量赋值。接下来，gawk将程序编译为内部形式。然后，gawk执行BEGIN规则（如果有）中的代码，然后继续读取ARGV数组中的每个文件（直到ARGV\[ARGC-1]）。如果在命令行上没有指定文件，则gawk将读取标准输入。

如果命令行上的文件名格式为var=val，则将其视为变量赋值。变量var将被赋值为val。（这会在任何BEGIN规则被运行之后发生。）命令行变量赋值对于将值动态地赋值给AWK用于控制如何将输入分成字段和记录的变量最有用。如果在单个数据文件上需要多次传递，则命令行变量赋值对于控制状态也很有用。

如果ARGV的特定元素的值为空（“”），则gawk将跳过它。

对于每个输入文件，如果存在BEGINFILE规则，则gawk将在处理文件内容之前执行关联的代码。同样，gawk在处理文件后执行与ENDFILE关联的代码。

对于输入中的每个记录，gawk进行测试以查看其是否与AWK程序中的任何模式匹配。对于记录匹配的每个模式，gawk将执行关联的操作。模式按照它们在程序中出现的顺序进行测试。

最后，在所有输入完毕后，gawk将执行END规则（如果有）中的代码。



## 6.1 命令行目录

根据POSIX，在awk命令行上指定的文件必须是文本文件。 如果不是文本文件，则行为是未定义的。 大多数版本的awk将命令行上的目录视为致命错误。

从gawk的4.0版本开始，命令行的目录会生成警告，但会被跳过。 如果给出了--posix或--traditional选项，则gawk将恢复为将命令行上的目录视为致命错误。

# 7 变量、记录、字段
AWK变量是动态的；它们在首次使用时就存在。它们的值可以是浮点数或字符串，或两者兼有，这取决于它们的使用方式。此外，gawk允许变量具有正则表达式类型。 AWK还有一维数组；可以模拟具有多维数组。 Gawk提供了真正的数组；请参阅后面的[数组](#arrays)。在程序运行时会设置几个预定义的变量；这些内容将根据需要进行描述，并在下面进行汇总。

   记录
       通常，记录由换行符分隔。您可以通过将值分配给内置变量RS来控制记录的分离方式。如果RS是任何单个字符，则该字符将分隔记录。否则，RS是一个正则表达式。输入中与此正则表达式匹配的文本将记录分开。但是，在兼容模式下，仅将其字符串值的第一个字符用于分隔记录。如果将RS设置为空字符串，那么记录将由空行分隔。当RS设置为空字符串时，换行符除FS可能具有的值外，还始终充当字段分隔符。

   领域
       读取每个输入记录时，gawk会将FS变量的值用作字段分隔符，将记录分成多个字段。如果FS是单个字符，则字段由该字符分隔。如果FS是空字符串，则每个单独的字符都将成为一个单独的字段。否则，FS应该是完整的正则表达式。在特殊情况下，FS是单个空格，字段之间用空格和/或制表符和/或换行符隔开。注意：IGNORECASE的值（请参见下文）还影响在FS为正则表达式时如何拆分字段，以及在RS为正则表达式时如何分隔记录。

       如果将FIELDWIDTHS变量设置为以空格分隔的数字列表，则每个字段应具有固定的宽度，并且gawk使用指定的宽度拆分记录。每个字段宽度可以可选地以冒号分隔的值开头，该值指定在字段开始之前要跳过的字符数。 FS的值将被忽略。为FS或FPAT分配新值将覆盖FIELDFIDTHS的使用。

       同样，如果将FPAT变量设置为表示正则表达式的字符串，则每个字段均由与该正则表达式匹配的文本组成。在这种情况下，正则表达式描述字段本身，而不是将字段分开的文本。为FS或FIELDWIDTHS分配新值将覆盖FPAT的使用。

       输入记录中的每个字段都可以通过其位置引用：$ 1，$ 2，依此类推。 $ 0是整个记录，包括前导和尾随空白。字段不必由常量引用：

              n = 5
              打印$ n

       打印输入记录中的第五个字段。

       变量NF设置为输入记录中字段的总数。

       对不存在的字段（即$ NF之后的字段）的引用将产生空字符串。但是，分配给不存在的字段（例如，$（NF + 2）= 5）会增加NF的值，创建任何以空字符串作为中间值的中间字段，并导致重新计算$ 0的值，字段之间用OFS值分隔。引用负数的字段会导致致命错误。递减NF会导致超过新值的字段的值丢失，并重新计算$ 0的值，其中字段之间用OFS值分隔。

       为现有字段分配值会导致在引用$ 0时重建整个记录。同样，为$ 0赋值会导致记录被拆分，从而为字段创建新值。



------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《Linux man手册页》</font>当前版本为sed4.7。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------
