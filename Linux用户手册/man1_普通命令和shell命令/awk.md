---
title: awk
tags: 用户命令,文本流编辑
---


------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《Linux man手册页》</font>当前版本为5.10。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------

# 1 名称

gawk——模式扫描和处理语言。

# 2 概要

``` shell
	gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
	gawk [ POSIX or GNU style options ] [ -- ] program-text file ...
```
# 3 说明

Gawk是GNU工程对AWK编程语言的实现。它符合POSIX 1003.1标准。该版本反过来是基于Aho、Kernighan和Weinberger撰写的《AWK编程语言》中的描述开发。 Gawk提供了Brian Kernighan awk中的额外功能以及许多特定于GNU的扩展。

命令行由gawk本身选项、AWK程序文本（如果未通过 **-f** 或 **--include** 选项提供程序文件）、在 **ARGC** 和 **ARGV** 预定义的AWK变量中的可用值组成。

当使用 **--profile** 选项调用gawk时，gawk将开始从程序的执行中收集性能分析统计信息。 Gawk在这种模式下运行速度较慢，并且在完成后会自动在文件 **awkprof.out** 中生成一个执行配置文件。请参阅下面的 **--profile** 选项。

Gawk还具有集成的调试器。可以通过在命令行中指定--debug选项来启动交互式调试会话。在这种执行方式下，gawk将加载AWK源代码，然后提示您调试程序。 Gawk只能调试-f和--include选项提供的AWK程序源码。调试器在《高效AWK编程》中说明。

# 4 选项格式

Gawk选项可以是POSIX风格的单字符选项，或者GNU风格的长选项。POSIX选项是以“-”开始，而GNU长选项是以“--”开始。GNU特定功能和POSIX必须功能都提供了长选项。

特定于Gawk的选项通常以长选项形式使用。 长选项的参数可以紧跟在选项后的“=”符号之后（中间没有空格），也可以在下一个命令行参数中提供。 只要缩写保持唯一，就可以长选项就可以缩写。

此外，每一个长选项有一个相应的短选项，以便可以在 `#!`可执行脚本中使用该选项。

# 5 选项
Gawk接受以下选项。 首先列出标准选项，然后列出gawk扩展的选项。按短选项按字母顺序列出。
|短选项|长选项|说明|
|:--|:--|:--|
|-b|--characters-as-bytes|将所有输入数据视为单字节字符。 换句话说，在尝试将字符串作为多字节字符处理时，不必特别注意语言环境信息。 **--posix** 选项将覆盖此选项。|
|-c|--traditional|以兼容模式运行。 在兼容模式下，gawk的行为与Brian Kernighan awk相同； 无法识别特定于GNU的扩展。 有关更多信息，请参见下面的[GNU扩展](#GNU_EXTENSIONS)。|
|-C|--copyright|在标准输出上打印GNU版权信息的简短版本，然后成功退出。|
|-d\[file]|--dump-variables\[=file]|将全局变量以及它们的类型和最终值的排序列表打印到文件<u>file</u>中。如果未提供文件<u>file</u>，则gawk在当前目录中输出名为**awkvars.out**的文件。列出所有全局变量是在程序中查找“按错键错误”的好方法。如果您的大型程序具有很多函数，并且还希望确保您的函数不会无意中使用本应是局部变量的全局变量，那么您也可以使用此选项。（使用i，j等简单变量名称时，这是一个特别容易犯的错误。）|
|-D\[file]|--debug\[=file]|启用AWK程序调试。默认情况下，调试器从键盘（标准输入）以交互方式读取命令。可选的<u>file</u>参数指定一个文件，其中包含命令列表，以供调试器以非交互方式执行。|
|-e program-text|--source program-text|使用<u>program-text</u>作为AWK程序源代码。通过此选项，可以轻松地将库函数（通过 **-f** 和 **--include** 选项使用）与在命令行中输入的源代码混合在一起。它主要用于Shell脚本中的中大型AWK程序。通过 **-e** 提供的每个参数都被视为以隐式`@namespace "awk"`语句开头。|
|-E file|--exec file|与 **-f** 相似，但是，此选项是最后处理的选项。这个选项与`＃!`脚本一起使用，以避免在命令行中从URL传入选项或源代码（!），尤其是CGI应用程序脚本。此选项禁用命令行变量赋值。|
|-f program-file|--file program-file|从文件<u>program-file</u>中读取AWK程序，而不是从第一个命令行参数中读取。可以使用多个 **-f**（或 **--file**）选项。使用 **-f** 读取的文件被视为以隐式的`@namespace "awk"`语句开头。|
|-F fs|--field-separator fs|将<u>fs</u>用作输入字段分隔符（预定义变量**FS**的值）。|
|-g|--gen-pot|扫描并解析AWK程序，并在标准输出上生成GNU **.pot**（可移植对象模板）格式文件，其中包含该程序中所有可区域化字符串条目。程序本身未执行。有关 **.pot** 文件的更多信息，请参见[GNU gettext](#gnu_gettext)分发。|
|-h|--help|在标准输出上打印可用选项的简短摘要。 （根据**GNU编码标准**，这选项会导致立即成功退出。）|
|-i include-file|--include include-file|加载awk源码库。这将使用环境变量**AWKPATH**来搜索该库。如果首次搜索失败，则在加上 **.awk** 后缀之后再次尝试。该文件将仅加载一次（消除重复），并且这些代码不构成主程序源码。用 **--include** 读取的文件被视为以隐式`@namespace "awk"`语句开头。|
|-l lib|--load lib|从共享库库中加载gawk扩展。 awk将使用环境变量**AWKLIBPATH**来搜索该库。 如果首次搜索失败，则在为加上平台默认共享库后缀后再次尝试。 库的初始化例程应命名为**dl_load()**。|
|-L \[value]|--lint\[=value]|提供有关可疑或不可移植到其他AWK实现的构造的警告。 如果使用可选参数**fatal**，则温柔警告会变成致命错误。 这可能很激烈，但是使用它肯定会鼓励开发更清洁的AWK程序。 使用可选参数**invalid**，仅发出有关确实无效的警告（这尚未完全实现）。使用可选参数**no-ext**，将禁用有关gawk扩展的警告。|
|-M|--bignum|对数字强制执行任意精度计算。如果编译gawk未使用GNU MPFR和GMP库，则此选项无效。（在这种情况下，gawk会发出警告。）|
| -n|--non-decimal-data|识别输入数据中的八进制和十六进制值。请谨慎使用此选项！|
|-N|--use-lc-numeric|强制gawk在解析输入数据时使用语言环境的小数点字符。尽管POSIX标准要求此行为，并且当 **--posix**生效时gawk会这样做，但默认情况是遵循传统行为，并使用句点作为小数点，即使在句点不是小数点字符的语言环境中也是如此。此选项将覆盖默认行为，而没有 **--posix**选项的严格要求。|
|-o\[file]|--pretty-print\[=file]|将程序的完美打印版本输出到文件<u>file</u>中。如果未提供文件<u>file</u>，则gawk在当前目录中输出名为**awkprof.out**的文件。此选项暗示 **-no-optimize**。|
|-O| --optimize|在程序的内部表示形式上启用gawk的默认优化。当前，这仅包括简单的常量折叠（一种编译优化技术）。默认情况下，此选项处于启用状态。|
|-p\[prof-file]|-profile\[=prof-file]|启动性能分析会话，然后将性能数据发送到<u>prof-file</u>。默认值为**awkprof.out**。该配置文件在左边包含程序中每个语句的执行计数，以及每个用户定义函数的函数调用计数。此选项暗示**--no-optimize**。|
|-P|--posix|这将打开兼容模式，并具有以下限制：<ul><li>无法识别 **\\x** 转义序列</li><li>在 **?** 和 **:** 后无法继续</li><li>无法识别关键字**function**的同义词**func**</li><li>不能使用 \*\* 和 \*\*= 来代替\^和\^=</li></ul>|
|-r|--re-interval|在正则表达式匹配中启用<u>间隔表达式</u>的使用（请参见下面的[正则表达式](#regexp)）。传统上，<u>间隔表达式</u>在AWK语言中不可用。 POSIX标准添加了它们，以使awk和<u>egrep</u>彼此一致。它们是默认启用的，但此选项仍可与 **--traditional**一起使用。|
|-s|--no-optimize|在程序的内部表示形式上禁用gawk的默认优化。|
|-S|--sandbox|在沙盒模式下运行gawk，禁用**system()**函数、**getline**输入重定向，**print**和**printf**输出重定向，以及加载动态扩展。命令执行（通过管道）也被禁用。这有效地阻止了脚本访问本地资源，命令行上指定的文件除外。|
|-t|--lint-old|提供有关不可移植到UNIX awk原始版本的构造的警告。|
|-v var=val|--assign var=val|在程序开始执行之前，将值<u>val</u>分配给变量<u>var</u>。这样的变量值可用于AWK程序的**BEGIN**规则。|
|-V|--version|在标准输出上打印该gawk特定副本的版本信息。 这主要用于了解当前系统上的gawk是否是自由软件基金会正在分发的最新版本。 报告bug时，这也很有用。 （根据**GNU编码标准**，此选项会导致立即成功退出。）
|--||选项结束信号。 这允许AWK程序的其他参数以“-”开头。 这与大多数其他POSIX程序使用的参数解析约定保持一致。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|

在兼容模式下，任何其他选项均标记为无效，否则将被忽略。 在正常操作中，只要提供了程序文本，在**ARGV**数组中的未知选项会传递给AWK程序进行处理。这对于通过`＃!`可执行解释器机制运行AWK程序特别有用。|

为了实现POSIX兼容性，可以使用 **-W**选项，后跟长选项的名称。

# 6 AWK程序执行
AWK程序由一系列可选指令、模式动作语句和可选的函数定义组成。

``` awk
@include "filename"
@load "filename"
@namespace "name"
pattern   { action statements }
function name(parameter list) { statements }
```
Gawk首先从<u>program-files</u>（如果指定了）、**--source**的参数、或命令行上的第一个非选项参数中读取程序源码。 **-f**和 **--source**选项可以在命令行上多次使用。 Gawk读取程序文本就好像所有<u>program-files</u>文件和命令行源码都连接在一起一样。这对于构建AWK函数库很有用，而不必在使用它们的每个新AWK程序中都包含它们。它还提供了将库函数与命令行程序混合的功能。

此外，以 **@include**开头的行可用于将其他源文件包括到您的程序中，从而使库的使用更加容易。这等效于使用 **--include**选项。

以 **@load**开头的行可用于将扩展功能加载到您的程序中。这等效于使用 **--load**选项。|

环境变量**AWKPATH**指定了查找 **-f**和 **--include**选项指定的源文件时使用的搜索路径。如果该变量不存在，则默认路径为 **“.:/usr/local/share/awk”** 。 （实际目录可能会有所不同，具体取决于gawk的构建和安装方式。）如果给 **-f**选项指定的文件名包含“/”字符，则不会执行路径搜索。

环境变量**AWKLIBPATH**指定查找 **--load**选项指定的源文件时要使用的搜索路径。如果该变量不存在，则默认路径为 **“/usr/local/lib/gawk”**。 （实际目录可能会有所不同，具体取决于gawk的构建和安装方式。）

Gawk按以下顺序执行AWK程序。首先，执行通过 **-v**选项指定的所有变量赋值。接下来，gawk将程序编译为内部形式。然后，gawk执行**BEGIN**规则（如果有）中的代码，然后继续读取**ARGV**数组中的每个文件（直到**ARGV\[ARGC-1]**）。如果在命令行上没有指定文件，则gawk将读取标准输入。

如果命令行上的文件名格式为<u>var</u>=<u>val</u>，则将其视为变量赋值。变量<u>var</u>将被赋值为<u>val</u>（这会在**BEGIN**规则被运行之后发生）。命令行变量赋值对于将值动态地赋值给AWK用于控制如何将输入分成字段和记录的变量最有用。如果在单个数据文件上需要多次传递，则命令行变量赋值对于控制状态也很有用。

如果**ARGV**的特定元素的值为空（""），则gawk将跳过它。

对于每个输入文件，如果存在**BEGINFILE**规则，则gawk将在处理文件内容之前执行关联的代码。同样，gawk在处理文件后执行与**ENDFILE**关联的代码。

对于输入中的每个记录，gawk进行测试以查看其是否与AWK程序中的任何模式<u>pattern</u>匹配。对于记录匹配的每个模式，gawk将执行关联的动作<u>action</u>。模式<u>pattern</u>按照它们在程序中出现的顺序进行测试。

最后，在所有输入完毕后，gawk将执行**END**规则（如果有）中的代码。

## 6.1 命令行目录

根据POSIX，在awk命令行上指定的文件必须是文本文件。 如果不是文本文件，则行为是未定义的。 大多数版本的awk将命令行上指定目录视为致命错误。

从gawk的4.0版本开始，命令行上指定目录会生成警告，但会被跳过。 如果给出了 **--posix**或 **--traditional**选项，则gawk将命令行上指定目录视为致命错误。

# 7 变量、记录、字段
AWK变量是动态的；它们在首次使用时就存在。它们的值可以是浮点数或字符串，或两者兼有，这取决于它们的使用方式。此外，gawk允许变量具有正则表达式类型。 AWK还有一维数组；可以模拟具有多维数组。 Gawk提供了真正的数组；请参阅后面的[数组](#arrays)。在程序运行时会设置几个预定义的变量；这些变量由于需要进行了说明，并总结在后面。

## 7.1 记录

通常，记录由换行符分隔。您可以通过给内建变量**RS**赋值来控制记录的分隔方式。如果**RS**是任意单个字符，则该字符将分隔记录。否则，**RS**是一个正则表达式。输入中与此正则表达式匹配的文本将记录分隔开。但是，在兼容模式下，仅将其字符串的第一个字符用于分隔记录。如果将**RS**设置为空字符串，那么记录将由空行分隔。当**RS**设置为空字符串时，除**FS**可能具有的值外，换行符还始终充当字段分隔符。注意：当**RS**为正则表达式时，**IGNORECASE**的值（请[参见下文](#IGNORECASE)）会影响如何分隔记录。
<span id='filed'></span>
## 7.2 字段
当每个输入的记录被读取时，gawk会把**FS**变量的值用作字段分隔符以将记录分成多个字段。如果**FS**是单个字符，则字段由该字符分割。如果**FS**是空字符串，则各个字符都将成为一个单独的字段。否则，**FS**应该是完整的正则表达式。在特殊情况下，**FS**是单个空格，字段之间通过空格、制表符、换行符分割。注意：当**FS**为正则表达式时，**IGNORECASE**的值（请[参见下文](#IGNORECASE)）会影响如何拆分字段。

如果将**FIELDWIDTHS**变量设置为以空格分隔的数字列表，则每个字段应具有固定的宽度，且gawk使用指定的宽度拆分记录。每个字段宽度可以可选地以冒号分隔的值开头，该值指定在字段开始之前要跳过的字符数。 **FS**的值将被忽略。为**FS**或**FPAT**赋新值将覆盖**FIELDFIDTHS**的使用。

类似的，如果将**FPAT**变量设置为表示正则表达式的字符串，则每个字段均由与该正则表达式匹配的文本组成。在这种情况下，正则表达式描述字段本身，而不是分割字段的文本。为**FS**或**FIELDWIDTHS**分配新值将覆盖**FPAT**的使用。

输入的记录中的每个字段都可以通过其位置引用：`$1`，`$2`，依此类推。 `$0`是整个记录，包括前导和尾随空白。字段不需通过常量引用：

``` awk
n = 5
print $n
```

打印输入记录中的第五个字段。

变量**NF**为输入记录中字段的总数。

对不存在的字段（即`$NF`之后的字段）的引用将产生空字符串。但是，赋值给不存在的字段（例如，`$(NF + 2)= 5`）会增加**NF**的值，创建以空字符串作为值的中间字段，并导致重新计算`$0`的值，字段之间用**OFS**的值分割。引用负数字段会导致致命错误。减小**NF**会导致超过新值的字段的值丢失，并重新计算`$0`的值，其字段之间用**OFS**值分割。

为已有字段赋值值会导致在引用`$0`时重建整个记录。 同样，为`$0`赋值会导致记录被重拆分，从而为字段创建新值。

## 7.3 内建变量
Gawk的内置变量如下：

|变量|说明|
|:--|:--|
|ARGC|命令行参数的数量（不包括gawk的选项或程序源码）|
|ARGIND|正在处理的当前文件在**ARGV**中的索引|
|ARGV |命令行参数数组。该数组的索引从0到**ARGC**-1。动态更改**ARGV**的内容可以控制用于数据的文件。|
|BINMODE|在非POSIX系统上，为所有文件I/O指定使用“二进制”模式。数值1、2、3分别指定输入文件、输出文件、所有文件应使用二进制I/O。字符串值"**r**"或"**w**"指定输入文件或输出文件使用二进制I/O。字符串值"**rw**"或"**wr**"指定所有文件应使用二进制I/O。任何其他字符串值都被视为"**rw**"，但会生成警告消息。|
|CONVFMT|默认情况下，数字的转换格式为"**％.6g**"。|
|ENVIRON|包含当前环境值的数组。该数组通过环境变量进行索引，每个元素都是对应环境变量的值（例如**ENVIRON\["HOME"]**可能是"**/home/arnold**"）。<br />在POSIX模式下，更改此数组不会影响gawk通过重定向或system()函数生成的程序所看到的环境。否则，gawk将更新其实际环境，以便其生成的程序可以看到更改。|
| ERRNO|如果在重定向**getline**、读取**getline**、**close**()期间发生错误，则将**ERRNO**设置为描述该错误的字符串。该值可以在非英语语言环境中进行翻译。如果**ERRNO**中的字符串与<u>errno</u>(3)变量中的系统错误相匹配，则可以在 **PROCINFO\["errno"]** 中找到该数值。对于非系统错误，**PROCINFO\["errno"]** 将为零。|
|FIELDWIDTHS|以空白分隔的字段宽度列表。设置后，gawk会将输入解析为固定宽度的字段，而不是使用**FS**变量的值作为字段分隔符。可选地，每个字段宽度前面都可以有一个冒号分隔的值，该值指定在字段开始之前要跳过的字符数。参见前面的[字段](#filed)。|
|FILENAME| 当前输入文件的名称。如果在命令行上未指定文件，则**FILENAME**的值为“-”。但是，**FILENAME**在BEGIN规则内是未定义的（除非由**getline**设置）。|
|**FNR**|当前输入文件中的输入记录号。|
|FPAT|描述记录中字段内容的正则表达式。设置后，gawk会将输入解析为与正则表达式匹配的字段，而不是使用**FS**的值作为字段分割符。参见前面的[字段](#filed)。|
|**FS**|输入字段分割符，默认为空格。参见前面的[字段](#filed)。|
|FUNCTAB |一个数组，其索引和对应值是程序中所有用户定义或扩展函数的名称。注意：您不能与**FUNCTAB**数组一起使用**delete**语句。|
|<span id="IGNORECASE">IGNORECASE</span>|控制所有正则表达式和字符串操作的是否区分大小写。如果**IGNORECASE**具有非零值，则在规则中进行字符串比较和模式匹配，使用**FS**和**FPAT**进行字段拆分，使用**RS**进行记录分隔，使用 **\~** 和 **!\~** 匹配正则表达式，以及内置函数**gensub**()、**gsub**()、**index**()、**match**()、**patsplit**()、**split**()和**sub**()在进行正则表达式操作时都会忽略大小写。注意：数组下标不受影响，但是**asort**()和**asorti**()函数会受到影响。<br /><br />因此，如果**IGNORECASE**不等于零，则 **/aB/** 匹配所有字符串“**ab**”，“**aB**”，“**Ab**”和“**AB**”。与所有AWK变量一样，**IGNORECASE**的初始值为零，因此所有正则表达式和字符串操作通常区分大小写。|
|LINT|在AWK程序中提供 **--lint**选项的动态控制。 如果为**true**，gawk将打印温和警告。 如果为**fasle**，则不会。 当为**LINT**赋值"**fatal**"时，温和警告将成为致命错误，与 **--lint=fatal**一样。 其他任何真值只会显示警告。|
|**NF**|当前输入记录中的字段数。|
|**NR**|到目前为止看到的输入记录总数。|
|OFMT|默认情况下，数字的输出格式为"**％.6g**"。|
|**OFS**|输出字段分隔符，默认为空格。|
|**ORS**|输出记录分隔符，默认情况下为换行符。|
|PREC|任意精度浮点数的有效精度，默认为53。|
|PROCINFO|该数组的元素提供了访问正在运行的AWK程序的信息的接口。参见下面的[PROCINFO](#PROCINFO)。|
|ROUNDMODE|用于对数字进行任意精度算术的舍入模式，默认情况下为"N"（IEEE-754 roundTiesToEven模式）。可接受的值为：<br /><br /> "A" 或 "a"&emsp;&emsp;roundAwayFromZero。仅当您的GNU MPFR库版本支持roundAwayFromZero才可用。<br /><br />"D" 或 "d"&emsp;&emsp; roundTowardNegative。<br /><br />"N" 或 "n"&emsp;&emsp;roundTiesToEven。<br /><br />"U" or "u" &emsp;&emsp;roundTowardPositive。<br /><br />"Z" or "z" &emsp;&emsp;roundTowardZero。|
|**RS**|输入记录分隔符，默认情况下为换行符。|
|**RT**|记录终止符。 Gawk将**RT**设置为与**RS**指定的字符或正则表达式匹配的输入文本。|
|RSTART|**match**()匹配的第一个字符的索引。如果没有匹配，则为0。（这意味着字符索引从1开始。）|
|RLENGTH |**match**()匹配的字符串的长度；如果没有匹配，则为-1。|
|SUBSPEP|默认情况下，用于分隔数组元素中多个下标的字符串“**\034**”。|
|SYMTAB|一个数组，其索引是程序中所有当前定义的全局变量和全局数组的名称。该数组可用于间接访问以读取或写入变量的值：<br />&emsp;&emsp; foo = 5<br />&emsp;&emsp;SYMTAB["foo"] = 4<br />&emsp;&emsp;print foo    # prints 4<br />**typeof**()函数可用于测试**SYMTAB**中的元素是否为数组。您不能将**delete**语句与**SYMTAB**数组一起使用，也不能赋值给索引不是变量名的元素。|
|TEXTDOMAIN |AWK程序的文本域；用于查找程序字符的本地化翻译。|

在某些系统上，**PROCINFO**数组中可能存在一些元素，从"**group1**"到"**groupn**"，<u>n</u>是进程具有的补充组的数量。使用**in**运算符测试这些元素。以下元素保证可以使用：

|<span id='PROCINFO'>PROCINFO数组元素</span>|说明|
|:--|:--|
|PROCINFO["argv"]|gawk在C语言级别上接收到的命令行参数。下标从零开始。|
|PROCINFO["egid"]|系统调用<u>getegid</u>(2)的值。|
|PROCINFO["errno"] |当**ERRNO**设置为关联的错误消息时，<u>errno</u>(3)的值。|
|PROCINFO["euid"]|系统调用<u>geteuid</u>(2)的值。|
|PROCINFO ["FS"]| 如果使用**FS**进行字段拆分则为"**FS**"；如果使用**FPAT**进行字段拆分，则为"**FPAT**"；如果使用**FIELDWIDTHS**进行字段拆分，则为"FIELDWIDTHS"；如果使用**API**输入解析器拆分字段，则为"**API**"。|
|PROCINFO["gid"]|系统调用**getgid**(2)的值。|
|PROCINFO["identifiers"] |子数组，由AWK程序文本中使用的所有标识符的名称索引。这些值表示gawk在完成对程序的解析之后知晓了这些标识符；它们不会在程序运行时更新。对于每个标识符，元素的值是以下值之一：<br />"array"&emsp;&emsp;标识符是一个数组。<br />"builtin"&emsp;&emsp;标识符是内置函数。<br />"extension"&emsp;&emsp; 标识符是通过 **@load**或 **--load**加载的扩展函数。<br />"scalar"&emsp;&emsp;标识符是标量。<br />"untyped"&emsp;&emsp;标识符是无类型的（可以用作标量或数组，gawk尚不知道）。<br />"user"&emsp;&emsp;标识符是用户定义的函数。|
|PROCINFO["pgrpid"]|系统调用<u>getpgrp</u>(2)的值。|
|PROCINFO["pid"]|系统调用<u>getpid</u>(2)的值。
|PROCINFO["platform"]|一个字符串，指示编译gawk的平台。它是以下之一：<br />"djgpp"&emsp;&emsp;Microsoft Windows使用DJGPP<br />"mingw" &emsp;&emsp;Microsoft Windows使用MinGW。<br />"os2"&emsp;&emsp;OS/2。<br />"posix"&emsp;&emsp;GNU/Linux，Cygwin，Mac OS X和传统的Unix系统。<br />"vms"&emsp;&emsp;OpenVMS或Vax/VMS。|
|PROCINFO["ppid"]|系统调用<u>getppid</u>(2)的值。|
|PROCINFO["strftime"]|**strftime**()的默认时间格式字符串。更改其值会影响无参数调用**strftime**()时格式化时间值的方式。|
|PROCINFO["uid"]|系统调用**getuid**(2)的值。|
|PROCINFO["version"]|gawk的版本。|

如果可以加载动态扩展，则存在以下元素：
|PROCINFO数组元素|说明|
|:--|:--|
| PROCINFO["api_major"]|扩展API的主要版本。|
|PROCINFO["api_minor"]|扩展API的次要版本。|

如果将MPFR支持编译到gawk中，则可以使用以下元素：
|PROCINFO数组元素|说明|
|:--|:--|
|PROCINFO["gmp_version"]| Gaw GMP中用于任意精度数字支持的GNU GMP库版本。|
| PROCINFO["mpfr_version"]| Gaw MP中用于任意精度数字支持的GNU MPFR库版本。|
|PROCINFO["prec_max"]|GNU MPFR库支持的任意精度浮点数的最大精度。|
|PROCINFO["prec_min"]|GNU MPFR库允许的任意精度浮点数的最低精度。|

一格程序可以设置以下元素来更改gawk的行为：

|PROCINFO数组元素|说明|
|:--|:--|
|PROCINFO["NONFATAL"]|如果存在，则所有重定向的I/O错误都不会致命。|
|PROCINFO["name", "NONFATAL"]|使<u>name</u>指明的I/O错误非致命。|
|PROCINFO["command", "pty"]|使用伪tty与命令<u>command</u>进行双向通信，而不是设置两个单向管道。|
|PROCINFO["input", "READ_TIMEOUT"]|从输入读取数据的超时时间（以毫秒为单位），其中输入是重定向字符串或文件名。零或小于零的值表示没有超时设置。|
|PROCINFO["input", "RETRY"]|如果从输入读取数据时可能发生重试I/O错误，并且此数组项存在，则**getline**返回-2，而不是遵循默认行为返回-1，并将输入配置为不返回其他数据。可能重试的I/O错误是<u>errno</u>(3)的值为**EAGAIN**，**EWOULDBLOCK**，**EINTR**或**ETIMEDOUT**的错误。这在与 **PROCINFO["input", "READ_TIMEOUT"]** 联用，或在文件描述符已配置为以非阻塞方式运行的情况下很有用。|
|PROCINFO["sorted_in"]|如果**PROCINFO**中存在此元素，则其值控制在**for**循环中遍历数组元素的顺序。 支持的值是"**@ind_str_asc**"、"**@ind_num_asc**"、"**@val_type_asc**"、"**@val_str_asc**"、"**@val_num_asc**"、"**@ind_str_desc**"、"**@ind_num_desc**"、"**@val_type_desc**"、"**@val_str_desc**"、"**@val_num_desc**"和 "**@unsorted**"。 该值也可以是如下定义的比较函数的名称（以字符串形式）：<br />&emsp;&emsp;function cmp_func(i1,v1,i2,v2)<br />其中<u>i1</u>和<u>i2</u>是索引，而<u>v1</u>和<u>v2</u>是要比较的两个元素的对应值。 它应返回小于、等于或大于0的数字，具体取决于数组元素的排序方式。|
<span id='arrays'> </span>
## 7.4 数组

数组用方括号（[]）之间的表达式作为下标。如果表达式是表达式列表（expr，expr ...），则数组下标是由每个表达式的（字符串）值的串联组成的一个字符串，并由**SUBSEP**变量的值分隔。此功能用于模拟多维数组。例如：

``` awk
i = "A"; j = "B"; k = "C"
x[i, j, k] = "hello, world\n"
```
将字符串“**hello，world\n**”赋值给数组**x**的索引为字符串“**A\034B\034C**”的元素。AWK中的所有数组都是关联的，即由字符串值索引。

特殊运算符**in**可用于测试数组是否具有由特定值组成的索引：
```awk
if (val in array)
	print array[val]
```
如果数组有多个下标，请在数组中使用 **(i，j)**。

**in**运算符也可以在**for**循环中使用，以迭代数组的所有元素。 但是，**(i,j) in arrsy** 仅适用于测试，不适用于**for**循环。
可以使用**delete**语句从数组中删除元素。**delete**语句可以通过指定不带下标的数组名来删除数组的全部内容。

gawk支持真正的多维数组。 它不需要像C或C++中那样的数组是“矩形”的。 例如：

``` c++
a[1] = 5
a[2][1] = 6
a[2][2] = 7
```
注意：您可能需要告诉gawk，数组元素真的是一个子数组，以便在gawk需要数组的地方使用它（例如，在**split**()的第二个参数中）。 您可以通过在子数组中创建一个元素，然后使用**delete**语句将其删除来做到这一点。 

## 7.5 命令空间

Gawk提供了一种简单的命名空间功能，可帮助解决AWK中所有变量都是全局变量这一事实。

限定名称由两个简单标识符中间加一个双冒号(::)组成。左侧标识符代表命名空间，右侧标识符是其中的变量。所有简单（非限定）名称都被视为在当前默认命名空间**awk**中。但是，即使当前命名空间不同，仅由大写字母组成的简单标识符也会被放入awk命名空间。

您可以使用`@namespace "name"`指令更改当前命名空间。

标准的预定义内置函数名不能用作命名空间名。由gawk提供的附加函数名可以用作命名空间名或其他命名命名空间中的简单标识符。有关更多详细信息，请参见GAWK：[高效AWK编程](#effective_awk_programing)。

## 7.6 变量键入和转换
 变量和字段可以是（浮点）数字、字符串或两者都是，也可以是正则表达式。变量的值如何解释取决于其上下文。如果在数字表达式中使用，它将被视为数字。如果用作字符串，它将被视为字符串。

要强制将变量视为数字，请向其添加零。要强制将其视为字符串，请将其与空字符串连接。

未初始化的变量的数字值为零，字符串值为""（空字符串）。

当必须将字符串转换为数字时，可以使用<u>strtod</u>(3)来完成。通过将**CONVFMT**的值作为<u>sprintf</u>(3)的格式字符串并将变量的数值作为参数来将数字转换为字符串。然而，即使AWK中的所有数字都是浮点数，整数值始终会转换为整数。因此，给定
```awk
CONVFMT =“％2.2f”
a = 12
b = a""
```
变量**b**的字符串值为“**12**”，而不是“**12.00**”。

注意：在POSIX模式下运行时（例如使用 **--posix**选项），请注意语言环境设置可能会干扰十进制数字的处理方式：输入给gawk的数字的十进制分隔符必须符合您的语言环境，可能是逗(,)或句点(.)。

Gawk执行以下比较：如果两个变量为数字，则将对其进行数字比较。如果一个值是数字，而另一个值是“数字字符串”，则比较也会以数字方式进行。否则，将数值转换为字符串并执行字符串比较。当然，将两个字符串变量是作为字符串进行比较。

请注意，字符串常量（例如“**57**”）不是数字字符串，而是字符串常量。 “数字字符串”的概念仅适用于字段、**getline**输入、**FILENAME**、**ARGV**元素、**ENVIRON**元素以及由**split**()或**patsplit**()创建的数字字符串数组的元素。基本思想是看起来像数字的用户输入且只有看起来像数字的用户输入应该以这种方式处理。

## 7.7 八进制和十六进制常数

您可以在AWK程序源代码中使用C风格的八进制和十六进制常量。例如，八进制值**011**等于十进制**9**，十六进制值**0x11**等于十进制**17**。

## 7.8 字符串常量
AWK中的<span id='stringconstant'>字符串常量</span>是用双引号引起来的字符序列（例如“value”）。在字符串中，可以识别某些转义序列，就像C语言中一样。它们是：
|转义序列|说明|
|:--|:--|
|\\\|反斜杠。|
|\a|“警报”字符；通常是ASCII BEL字符。|
|\b|退格键。|
|\f|换页符。|
|\n|换行符。|
|\r|回车。|
|\t|水平制表符。|
|\v|垂直制表符。|
|\xhex digits|数字。\x后面跟十六进制数字。\x后面跟两个十六进制数字被认为是转义序列的一部分。例如，“**\x1B**”是ASCII ESC（转义）字符。|
|\ddd|数字。由的1位，2位或3位八进制数序列表示的字符。例如，“**\033**”是ASCII ESC（转义）字符。|
|\c|文字字符c。|

在兼容模式下，当在正则表达式常量中使用时，由八进制和十六进制转义序列表示的字符将按字面处理。因此，`/a\52b/`等效于 `/a\*b/`。

## 7.9 正则表达式常量

正则表达式常量是用两个正斜杠（例如 **/value/**）括起来的一系列字符。 正则表达式匹配将在下面regexp更全面地描述。 请参阅[正则表达式](#regexp)。

前面描述的转义序列也可以在正则表达式常量中使用（例如`/[ \t\f\n\r\v]/`匹配空白字符）。

Gawk提供强类型的正则表达式常量。 这些均以 **@** 符号开头（例如：**@/value/**）。 可以将此类常量分配给标量（变量，数组元素），并传递给用户定义的函数。 这样赋值的变量具有正则表达式类型。

# 8 模式和动作
AWK是一种面向行的语言。先模式，后动作。动作语句包含在 **{** 和 **}** 中。可以省略模式或动作，但不能都省略。如果省略模式，则对每条输入记录执行该动作。如果省略动作，则等效于 **{print }** ,打印整个记录。

注释以 **#** 字符开始，直到行尾。空行可用于分隔语句。通常，语句以换行符结尾，但是对于以 **,** 、**{** 、**?** 、**:** 、**&&** 或 **||** 结尾的行，并非如此。 以 **do** 或 **else** 结尾的行也会自动续行。 在其他情况下，可以通过以“**\\**”结尾来续行，在这种情况下，换行符将被忽略。 但是，**#** 后面的“**\\**”并不会自动续行。

多个语句可以放在一行中，语句之间用“**;**”分隔。这既适用于模式-动作对（通常情况）的动作部分的语句，也适用于模式-动作语句本身。


## 8.1 模式

AWK的模式可以是下列之一：
```awk
BEGIN
END
BEGINFILE
ENDFILE
/regular expression/
relational expression
pattern && pattern
pattern || pattern
pattern ? pattern : pattern
(pattern)
! pattern
pattern1, pattern2
```

**BEGIN** 和 **END** 是两种特殊的模式，它们不针对输入进行测试。 所有 **BEGIN** 模式的动作部分都被合并，就好像所有语句都写在单个 **BEGIN** 规则中一样。 它们在读取任何输入之前执行。 类似地，所有的 **END** 规则都被合并，并在所有输入都用完时（或在执行 **exit** 语句时）执行。 **BEGIN** 和 **END** 模式不能与模式表达式中的其他模式组合。 **BEGIN** 和 **END** 模式不能省略动作部分。

**BEGINFILE** 和 **ENDFILE** 是额外的特殊模式，它们的操作在读取每个命令行输入文件的第一条记录之前和读取每个文件的最后一条记录之后执行。 在 **BEGINFILE** 规则中，如果文件打开成功，**ERRNO** 的值为空字符串。 否则，文件有问题，代码应该使用 **nextfile** 跳过它。 如果不这样做，gawk 通常会为无法打开的文件产生致命错误。

对于 **/**<u>regular expression</u>**/** 模式，为匹配正则表达式的每个输入记录执行关联的语句。 正则表达式与 **egrep**(1) 中的相同，总结[如下](#regexp)。

关系表达式relational expression可以使用下面[关于动作的章节](#action)中定义的任何运算符。 这些通常测试某些字段是否与某些正则表达式匹配。

**&&**、**||** 和 **!** 运算符分别是逻辑与、逻辑或和逻辑非，就像在 C 中一样。它们进行短路测试，也和在 C 中一样，用于组合更原始的模式表达式。 与大多数语言一样，括号可用于更改计算顺序。

**?:** 运算符类似于 C 中的相同运算符。如果第一个模式为真，则用于测试的模式是第二个模式，否则为第三个模式。 仅第二和第三模式之一用于匹配。

表达式<u>pattern1, pattern2</u> 称为范围模式。 它匹配如下所有输入记录：从匹配模式<u>pattern1</u>的记录开始，一直持续到匹配模式 <u>pattern2</u>的记录，包括在匹配<u>pattern2</u>的记录在内。 它不与任何其他类型的模式表达式结合。

## 8.2 正则表达式

<span id='regexp'>正则表达式</span>是 **egrep** 中的正则表达式的扩展类型。 它们由以下字符组成：

|正则表达式字符|说明|
|:--|:--|
|c|匹配一个非元字符c|
|\\c| 匹配文字字符 c|
|.|匹配任何字符，包括换行符。|
|^| 匹配字符串的开头。|
|\$| 匹配字符串的结尾。|
|\[abc...\] |字符列表：匹配 abc...字符中的任意一个。您可以通过用破折号分隔字符来包含一格范围的字符。要在列表中包含破折号“-”，请将其放在第一个或最后一个。|
|\[\^abc...\]| 否定字符列表：匹配除abc...之外的任何一个字符。|
|r1\|r2| 二选一：匹配 r1 或 r2。|
|r1r2| 串联：匹配 r1，然后匹配 r2。|
|r+| 匹配一个或多个 r。|
|r\*| 匹配零个或多个 r。|
|r?|匹配零个或一个 r。|
|(r) |分组：匹配 r。|
|r\{n\}，r\{n,\}，r\{n,m\} |大括号内的两个数字表示区间表达式。如果大括号中有一个数字，则前面的正则表达式r重复 n 次。如果有两个数字用逗号分隔，r 重复 n 到 m 次。如果有一个数字后跟逗号，则 r 至少重复 n 次。|
|\\y| 匹配单词开头或结尾的空字符串。|
|\\B|匹配单词中的空字符串。|
|\\<| 匹配单词开头的空字符串。|
|\\>| 匹配单词末尾的空字符串。|
|\\s| 匹配任何空白字符。|
|\\S |匹配任何非空白字符。|
|\\w |匹配任何组成单词的字符（字母、数字或下划线）。|
|\\W |匹配任何不是组成单词的字符。|
|\\\`| 匹配缓冲区开头的空字符串（字符串）。|
|\\\'| 匹配缓冲区末尾的空字符串。|

在字符串常量中有效的转义序列（请参阅[字符串常量](#stringconstant)）在正则表达式中也有效。

字符类是 POSIX 标准中引入的一个特性。 字符类是一种特殊符号，用于描述具有特定属性的字符列表，但实际字符本身可能因国家、地区或字符集而异。 例如，字母字符的概念在美国和法国是不同的。

字符类仅在字符列表括号内的正则表达式中有效。 字符类由 `\[:`、表示类的关键字和 `:\]` 组成。 POSIX 标准定义的字符类是：
|字符|说明|
|:--|:--|
|`[:alnum:]`| 字母和数字字符。|
|`[:alpha:]`| 字母字符。|
|`[:blank:]` |空格或制表符。|
|`[:cntrl:]`|控制字符。|
|`[:digit:]` |数字字符。
|`[:graph:]`| 既可打印又可见的字符。 （空格是可打印的，但不可见，而 a 两者都是。）|
|`[:lower:]` |小写字母字符。|
|`[:print:]`| 可打印字符（不是控制字符的字符。）|
|`[:punct:]`|标点字符（不是字母、数字、控制字符或空白字符的字符）|。
|`[:space:]`| 空白字符（例如空格、制表符和换页符，仅举几例）。|
|`[:upper:]`| 大写字母字符。|
|`[:xdigit:]`|十六进制数字字符。|

例如，在 POSIX 标准之前，要匹配字母和数字字符，您必须写成`/[A-Za-z0-9]/`。 如果您的字符集中有其他字母字符，这将与它们不匹配，并且如果您的字符集与 ASCII 不同，这甚至可能不会匹配 ASCII 字母和数字字符。 使用 POSIX 字符类，您可以写为`/[[:alnum:]]/`，这将匹配你的字符集中的字母和数字字符，无论它是什么。

两个额外的特殊序列可以出现在字符列表中。 这些适用于非 ASCII 字符集，这些字符集可以具有用多个字符表示的单个符号（称为[整理元素](#CollatingSymbols)），以及用于整理或排序目的的多个等价字符。 （例如，在法语中，普通的“e”和带有重音的“\`”是等价的。）

<span id='CollatingSymbols'>**整理符号**</span>

整理符号是包含在 \[. 和 .\] 中的多字符整理元素。 例如，如果 **ch** 是一个整理元素，那么 **\[\[.ch.\]\]** 是一个匹配这个整理元素的正则表达式，而 **\[ch\]** 是一个匹配 c 或 h 的正则表达式。

**等价类**

等价类是等价字符列表的特定于语言环境的名称。 名称包含在 **\[=** 和 **=\]** 中。 例如，名称 e 可能用于表示所有“e”、“´”和“\`”。 在这种情况下，**\[\[=e=\]\]** 是匹配 e、´ 或 \` 中任何一个的正则表达式。

这些功能在非英语语言环境中非常有价值。 gawk 用于正则表达式匹配的库函数目前只能识别 POSIX 字符类； 它们不识别整理符号或等价类。

**\y**、**\B**、**\\<**、**\\>**、**\\s**、**\\**S、**\\w**、**\\**W、**\\`** 和 **\\'** 运算符是 gawk 特有的； 它们是基于 GNU 正则表达式库中的工具的扩展。

各种命令行选项控制 gawk 如何解释正则表达式中的字符。

|选项|说明|
|:--|:--|
|没有选项|在默认情况下，gawk 提供上述 POSIX 正则表达式和 GNU 正则表达式运算符的所有功能。|
|--posix|仅支持 POSIX 正则表达式，GNU 运算符并不特殊。 （例如，\\w 匹配文字 w）。|
|--traditional|传统的 UNIX awk 正则表达式是匹配的。 GNU 运算符并不特殊，并且区间表达式不可用。 八进制和十六进制转义序列描述的字符按字面处理，即使它们表示正则表达式元字符。|
|--traditional|允许在正则表达式中使用区间表达式，即使已提供--traditional选项。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||

## 8.3 动作

<span id='action'>动作</span>语句括在大括号 **{** 和 **}** 中。 动作语句由大多数语言中常见的赋值语句、条件语句和循环语句组成。 可用的运算符、控制语句和输入/输出语句是按照 C 中的模式设计的。

## 8.4 运算符

AWK 中的运算符按优先级递减的顺序是：
|运算符|说明|
|:--|:--|
|(...) |分组。|
|\$| 字段引用。|
|\+\+、--| 递增和递减，前缀和后缀。|
|^|取幂（也可以使用 `**`，而 `**=` 用于赋值运算符）。
|+、-、！|正数、负数和逻辑非。
|\*、 /、 %| 乘法、除法和求余。|
|+、-| 加法和减法。|
|空格| 字符串连接。|
|\|、\|&| 用于 **getline**、**print** 和 **printf** 的管道 I/O。|
|\<、>、\<=、 >= 、=\=、!=|普通的关系运算符。|
|~ 、!~| 正则表达式匹配，不匹配。注意：不要在 **~** 或 **!~** 的左侧使用常量正则表达式 (**/foo/**)。仅在右侧使用。表达式` /foo/ ~ exp` 与 `(($0 ~ /foo/) ~ exp )` 具有相同的含义。这通常不是您想要的。
|in| 数组成员|
|&&| 逻辑与。|
|\|\||逻辑或|
|?：|C 条件运算符，形式为 `expr1 ？expr 2：expr3`。如果 expr1 为真，则表达式的值为 expr2，否则为 expr3。 expr2 和 expr3 中只有一个是评估。
|=、+=、-=、\*=、/=、%=、^=|赋值。支持绝对赋值（var = value）和运算赋值（其他形式）。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||


## 8.5 控制语句

控制语句如下
|控制语句|说明|
|:--|:--|
|if (condition) statement \[ else statement \]|条件语句|
|while (condition) statement|当循环|
|do statement while (condition)|直到循环|
|for (expr1; expr2; expr3) statement|进循环|
|for (var in array) statement|遍历循环|
|break|跳出循环|
|continue|下一次循环|
|delete array\[index]|删除数组元素|
|delete array|删除数组|
|exit \[ expression ]|退出|
|{ statements }|普通语句|
|switch (expression) {<br />&emsp;&emsp;case value\|regex : statement<br />&emsp;&emsp;...<br />&emsp;&emsp;\[ default: statement ]<br />}|开关语句|

## 8.6 I/O语句
输入/输出语句如下：
|I/O语句|说明|
|:--|:--|
|close(file \[, how])|关闭文件、管道或协程。 <u>how </u>是可选的，应该只在将通向协程的双向管道的一端关闭时使用。 它必须是一个字符串值，可以是“**to**”或“**from**”。|
|getline| 从下一个输入记录设置 **\$0**； 设置 **NF**、**NR**、**FNR**、**RT**。|
|getline \<file| 从文件的下一条记录设置 **\$0**； 设置 **NF**，**RT**。|
|getline var| 从下一个输入记录设置 <u>var</u>； 设置 **NR**、**FNR**、**RT**。|
|getline var \<file | 从文件的下一条记录设置<u>var</u>； 设置 **RT**。|
|command \| getline \[var]|运行命令<u>command</u>，将输出通过管道传输到 **\$0** 或 <u>var</u>（如上所述）和 **RT**。|
|command \|& getline \[var]|将命令<u>command</u>作为协进程运行，将输出用管道传输到 \$0 或 <u>var</u>（如上所述）和 **RT**。 协程是一个gawk扩展。 （命令<u>command</u>也可以是一个套接字。请参阅下面的[特殊文件名](#SpecialFileNames)小节。）|
|next|停止处理当前输入记录。 读取下一个输入记录并使用 AWK 程序中的第一个模式重新开始处理。 到达输入数据的末尾后，执行任何**END** 规则(如果有)。|
|nextfile|停止处理当前输入文件。 读取的下一个输入记录来自下一个输入文件。 更新 **FILENAME** 和 **ARGIND**，将 **FNR** 重置为 1，并使用 AWK 程序中的第一个模式重新开始处理。 到达输入数据的末尾后，执行任何 **ENDFILE** 和 **END** 规则(如果有)。|
|print|打印当前记录。 输出记录以 **ORS** 的值终止。|
|print expr-list|打印表达式。 每个表达式都由 **OFS** 的值分隔。 输出记录以 **ORS** 的值终止。|
|print expr-list \>file|打印表达式到文件<u>file</u>。每个表达式都由 **OFS** 的值分隔。 输出记录以 **ORS** 的值终止。|
|printf fmt, expr-list|格式化打印。请参阅下面的[printf](#printf)语句。|
|printf fmt, expr-list \>file|格式化打印到文件中。请参阅下面的[printf](#printf)语句。|
 |system(cmd-line)|执行命令<u>cmd-line</u>，返回退出状态。 （这在非 POSIX 系统上可能不可用。）有关退出状态的完整详细信息，请参阅《高效AWK编程》。
|fflush(\[file]) |冲刷与打开的输出文件或管道文件<u>file</u>关联的所有缓冲区。 如果没有指定<u>file</u>或为空字符串，则冲刷所有打开的输出文件和管道。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|
**print**和 **printf** 允许额外的输出重定向。
|I/O语句|说明|
|:--|:--|
|print ... \>\> file|将输出添加到文件末尾。
|print ... \| command|将输出写到一个管道中
|print ... \|& command|将数据发送到协进程或套接字。 （另请参阅下面的[特殊文件名](#SpecialFileNames)小节。）|

**getline** 命令在成功时返回 1，在文件末尾返回 0，在错误时返回 -1。 如果 <u>errno</u>(3) 值指示 I/O 操作可以重试，并且设置了 **PROCINFO\["input", "RETRY"\]**，则返回 -2，并且可能会尝试再次调用 **getline** . 发生错误时，**ERRNO** 被设置为描述问题的字符串。

注意：打开双向套接字失败会导致向调用函数返回非致命错误。 如果在循环内使用管道、协进程或套接字 输出到 **getline**，或组读取自 **print** 或 **printf**，则必须使用 **close**() 创建命令或套接字的新实例。 AWK 在返回 **EOF** 时不会自动关闭管道、套接字或协进程。

## 8.7 printf语句
AWK 版本的 **<span id='printf'>printf</span>** 语句和 **sprintf**() 函数（见下文）的 接受以下转换规范格式：

|转换标识符|说明|
|:--|:--|
|%a, %A|\[-\]**0x**h.hhhh**p**+-dd 形式的浮点数（C99 十六进制浮点格式）。**%A**，使用大写字母代替小写字母。|
|%c| 单个字符。如果用于 %c 的参数是数字，则将其视为字符并打印。否则，假定参数是一个字符串，且只打印该字符串的第一个字符。|
|%d, %i|一个十进制数（整数部分）。|
|%e, %E|\[-]d.dddddd**e**\[+-]dd 形式的浮点数。**%E** 格式使用 **E** 而不是 **e**。
|%f, %F|\[-]ddd.dddddd 形式的浮点数。 如果系统库支持，**%F** 也可以使用。 这类似于 **%f**，但使用大写字母表示特殊的“非数字”和“无穷大”值。 如果 **%F** 不可用，gawk 使用 **%f**。|
|%g, %G|使用 **%e** 或 **%f**来进行转换，以较短者为准，并抑制输出不重要的零。 %G 格式使用 **%E** 而不是 **%e**。
|%o|一个无符号八进制数（也是一个整数）。|
|%u|一个无符号十进制数（同样是一个整数）。|
|%s| 一个字符串。|
|%x, %X|一个无符号的十六进制数（一个整数）。 **%X** 格式使用 **ABCDEF** 而不是 **abcdef**。|
|%%| % 字符|
|&emsp;&emsp;&emsp;&emsp;&emsp;|

可选的修饰符可位于 % 和转换标识符之间：
|修饰符|说明|
|:--|:--|
|count\$|此时在格式中使用第count个参数。称为位置说明符，主要用于格式字符串的翻译版本，而不是 AWK 程序的原始文本。这是一个gawk扩展。|
|- |表达式应在其字段内左对齐。|
|空格|对于数字转换，正数在前面加一个空格，负数在前面加一个减号。|
|+|在宽度修饰符（见下文）之前使用的加号表示始终为数字转换提供一个符号，即使要格式化的数据是正数。 +会覆盖空格修饰符。|
|#|对某些控制字母使用“替代形式”。对于 **%o**，提供前导零。对于 **%x** 和 **%X**，为非零结果提供前导 **0x** 或 **0X**。对于 **%e**、**%E**、**%f** 和 **%F**，结果始终包含小数点。对于 **%g** 和 **%G**，不会从结果中删除尾随零。|
|0|前导 0（零）指示输出应填充零而不是空格。这仅适用于数字输出格式。仅在字段宽度大于要打印的值时有效。|
|'|单引号字符指示 gawk 将语言环境的千位分隔符插入十进制数，并且还将语言环境的小数点字符与浮点格式一起使用。这需要 C 库和当前语言环境定义中的正确语言环境支持。|
|width|字段应被填充到此宽度width，通常用空格填充。对于 0 标志，它用零填充。|
|.prec|一个数字，指定打印时使用的精度。 对于 **%e**、**%E**、**%f** 和 **%F** 格式，这指定要打印到小数点右侧的位数。 对于 **%g** 和 %**G** 格式，它指定最大有效数字位数。 对于 **%d**、**%i**、**%o**、**%u**、**%x** 和 **%X** 格式，它指定要打印的最小位数。 对于 **%s** 格式，它指定字符串可打印的最大字符数。|

支持 ISO C **printf**()函数的动态宽度和精度功能。 `*` 用于代替宽度或精度，导致宽度或精度的值从参数列表中获取。 要使用具有动态宽度或精度的位置说明符，请在格式字符串中的 `*` 之后提供 `count$`。 例如，`"%3\$\*2\$.\*1\$s"`。

## 8.8 特殊文件名
<span id='SpecialFileNames'>当</span>重定向**print** 或 **printf** 的输出或**getline**的输入到文件时，gawk 在内部识别某些特殊文件名。 这些文件名允许访问从 gawk 的父进程（通常是 shell）继承的打开的文件描述符。 这些文件名也可以在命令行中用于指定数据文件。 文件名是：
|文件名|说明|
|:--|:--|
|-| 标准输入|
|/dev/stdin|标准输入|
|/dev/stdout |标准输出|
|/dev/stderr |标准错误输出|
|/dev/fd/n |与打开的文件描述符 <u>n</u> 关联的文件。 |

这对于错误消息特别有用。 例如：
```awk
print "You blew it!" > "/dev/stderr"

```
否则，你将不得不使用
```awk
print "You blew it!" | "cat 1>&2"
```

以下特殊文件名可以与协处理运算符 **|&** 一起用于创建 TCP/IP 网络连接：

/inet/tcp/lport/rhost/rport
/inet4/tcp/lport/rhost/rport
/inet6/tcp/lport/rhost/rport

表示本地端口 <u>lport</u> 到远程主机 <u>rhost</u>的远程端口 <u>rport</u> 的TCP/IP 连接的文件。 使用 0 端口让系统选择一个端口。 使用 **/inet4** 强制 IPv4 连接，使用 **/inet6** 强制 IPv6 连接。 **/inet**使用系统默认值（很可能是 IPv4）。 仅可与 **|&** 双向 I/O 运算符一起使用。

/inet/udp/lport/rhost/rport
/inet4/udp/lport/rhost/rport
/inet6/udp/lport/rhost/rport

类似，但使用 UDP/IP 而不是 TCP/IP。

## 8.9 数学函数
AWK 具有以下内置输数学函数：
|函数|说明|
|:--|:--|
|atan2(y, x)| 以弧度为单位返回 <u>y</u>/<u>x</u> 的反正切值。|
|cos(expr) |返回 <u>expr</u> 的余弦值，以弧度为单位。|
|exp(expr)| 指数函数。|
|int(expr) |截断为整数。|
|log(expr)| 自然对数函数。|
|rand() |返回一个随机数 <u>N</u>，介于 0 和 1 之间，使得 0 ≤ N < 1。|
|sin(expr) |返回 <u>expr</u> 的正弦值，以弧度为单位。|
|sqrt(expr) |返回 <u>expr</u> 的平方根。|
|srand(\[expr])| 使用 <u>expr</u> 作为随机数生成器的新种子。 如果未提供<u> expr</u>，则使用一天中的时间。 返回随机数生成器的前一个种子。|

## 8.10 字符串函数
Gawk 具有以下内置字符串函数：
|函数|说明|
|:--|:--|
|asort(s \[, d \[, how\] \])|返回源数组 <u>s</u> 中的元素数量。使用gawk比较值的普通规则对<u>s</u>的内容进行排序，并将排序后<u>s</u>的索引替换为从1开始的连续整数。 如果指定了可选目标数组<u>d</u>，则先将<u>s</u>复制到<u>d</u>中，然后对<u>d</u>进行排序，源数组 <u>s</u> 的索引不变。可选字符串<u>how</u>控制排序方向和比较模式。<u>how</u>的有效值是对 `PROCINFO["sorted_in"]` 有效的任意字符串。它也可以是如 `PROCINFO["sorted_in"]` 中所述的用户定义的比较函数的名字。|
|asorti(s \[, d \[, how\] \])|返回源数组 <u>s</u> 中的元素数量。 行为与 **asort**() 相同，除了数组索引用于排序，而不是数组值。 完成排序后，数组以数字索引，值是原始索引的值。 原始值丢失； 因此，如果您希望保留原始数组，请提供第二个数组<u>d</u>。 可选字符串 how 的用途与前面描述的 **asort**() 相同。|
|gensub(r, s, h \[, t\]) | 在目标字符串 <u>t</u> 中搜索正则表达式 <u>r</u> 的匹配项。如果 <u>h</u> 是以 **g** 或 **G** 开头的字符串，则将 <u>r</u> 的所有匹配项替换为 <u>s</u>。否则，<u>h</u> 是一个数字，指示要替换 <u>r</u> 的哪个匹配项。如果未提供 <u>t</u>，则改用 **\$0**。在替换文本 <u>s</u>中，序列 \\<u>n</u>（其中 <u>n</u> 是从 1 到 9 的数字）可用于指示与第 <u>n</u> 个带括号的子表达式匹配的文本。序列 **\\0** 表示整个匹配的文本，字符 **&** 也是如此。与 **sub**() 和 **gsub**() 不同的是，修改后的字符串作为函数的结果返回，而不改变原始目标字符串。|
|gsub(r, s \[, t\])|对于字符串 <u>t</u> 中与正则表达式 <u>r</u> 匹配的每个子字符串，替换为字符串 <u>s</u>，并返回替换次数。如果未提供 <u>t</u>，则使用 **\$0**。替换文本中的 **&** 被替换为实际匹配的文本。使用 **\\&** 获得文字 **&**。 （这必须输入为“**\\\\&**”；请参阅 GAWK：《高效AWK编程》，以更全面地讨论 **sub**()、**gsub**() 和 **gensub**() 的替换文本中“逻辑与符号和反斜杠”的规则。）|
|index(s, t) |返回字符串 <u>s</u> 中的字符串 <u>t</u> 的索引，如果 <u>t</u> 不存在，则返回零。 （这意味着字符索引从 1 开始。）对 t 使用正则表达式常量是一个致命的错误。    |
| length(\[s\])|返回字符串 <u>s</u> 的长度，如果未提供 <u>s</u>，则返回 **\$0** 的长度。作为非标准扩展，使用数组作为参数，**length**() 返回数组中的元素数量。|
|match(s, r \[, a\])|返回 <u>s</u> 中正则表达式 <u>r</u> 出现的位置，如果 <u>r</u> 不出现则返回零，并设置 **RSTART** 和 **RLENGTH** 的值。请注意，参数顺序与 **~** 运算符相同：<u>str</u> **~** <u>re</u>。如果提供了数组 <u>a</u>，则会清空 <u>a</u>，然后用 <u>s</u> 中与 <u>r</u> 中相应括号内的子表达式匹配的部分填充元素 1 到 <u>n</u>。 <u>a</u> 的第零个元素包含<u>s</u> 与整个正则表达式 <u>r</u> 匹配的部分。下标 **a\[** <u>n</u>**, "start"\]** 和 **a\[** <u>n</u>**, "length"\]** 分别提供每个匹配子字符串在字符串中的起始索引和长度。|
|patsplit(s, a \[, r \[, seps\] \])|在正则表达式<u>r</u>上，将字符串 <u>s</u> 拆分为数组 <u>a</u> 和分隔符数组 <u>sep</u>，并返回字段数。元素值是 <u>s</u> 中与 <u>r</u> 匹配的部分。 **seps**\[<u>i</u>\] 的值是出现在 **a**\[<u>i</u>\] 之后的可能为空的分隔符。 **seps\[0\]** 的值是可能为空的前导分隔符。如果省略 <u>r</u>，则使用 **FPAT**替代。首先清除数组 <u>a</u> 和 <u>sep</u>。拆分字符串的行为与使用 **FPAT** 的字段的拆分效果相同，如上所述。|
|split(s, a \[, r \[, seps\] \])|在正则表达式 <u>r</u>上， 将字符串 <u>s</u> 拆分为数组 <u>a</u> 和的分隔符数组 <u>sep</u>，并返回字段数。如果省略 <u>r</u>，则使用 **FS**替代。首先清空数组 <u>a</u> 和 <u>sep</u>。 **seps**\[<u>i</u>\] 是 **a[**<u>i</u>**]** 和 **a[**<u>i</u>**+1]** 之间与 <u>r</u> 匹配的字段分隔符。如果 <u>r</u> 是单个空格，则 <u>s</u> 中的前导空白符进入额外的数组元素 **sep\[0\]**，尾随的空白符进入额外的数组元素 **seps**\[<u>n</u>\]，其中 <u>n</u> 是 **split**(<u>s</u>, <u>a</u>, <u>r</u> , <u>sep</u>)。拆分的行为与上述的字段拆分相同。特别是，如果 <u>r</u> 是单字符字符串，则该字符串充当分隔符，即使它恰好是正则表达式元字符。
|sprintf(fmt, expr-list)| 根据 <u>fmt</u> 打印 <u>expr-list</u>，并返回结果字符串。|
|strtonum(str)  |检查 <u>str</u>，并返回其数值。 如果 <u>str </u>以前导 0 开头，则将其视为八进制数。 如果 <u>str </u>以前导 **0x** 或 **0X** 开头，则将其视为十六进制数。 否则，假设它是一个十进制数。 |
| sub(r, s \[, t\])|就像 **gsub**() 一样，但只替换第一个匹配的子字符串。 返回0或1。|
|substr(s, i \[, n\])|返回<u>s</u>中从位置 <u>i</u> 开始的最多 <u>n</u> 个字符的子串。 如果省略 <u>n</u>，则返回 <u>s</u> 自<u>i</u>开始的其余部分。|
| tolower(str) |返回字符串 <u>str</u> 的副本，其中 <u>str</u> 中的所有大写字符都转换为相应的小写字母。 非字母字符保持不变。|
| toupper(str)|返回字符串 <u>str</u> 的副本，其中 <u>str</u> 中的所有小写字符都转换为相应的大写字母。 非字母字符保持不变。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||

gawk 可以感知多字节。 这意味着 **index**()、**length**()、**substr**() 和 **match**() 都是根据字符而不是字节来工作的。 

## 8.11 时间函数

由于 AWK 程序的主要用途之一是处理包含时间戳信息的日志文件，gawk 提供了以下函数来获取时间戳并对其进行格式化。
|函数|说明|
|:--|:--|
|mktime(datespec \[, utc-flag\])|将 <u>datespec</u> 转换为与 **systime**() 返回的格式相同的时间戳，并返回结果。 <u>datespec</u> 是格式为 <u>YYYY</u> <u>MM</u> <u>DD</u> <u>HH</u> <u>MM</u> <u>SS</u>\[ <u>DST</u>\] 的字符串。字符串的内容是六位或七位数字，分别代表完整的年份，包括世纪、月分（1~12）、月的天数（1~31）、小时（0~23）、分钟（0~59），秒（0 60），以及一个可选的夏令时标志。这些数字的值不必在规定的范围内；例如，-1 小时表示午夜前 1 小时。假定为零起点公历，第 0 年在第 1 年之前，第 -1 年在第 0 年之前。如果 <u>utc-flag</u> 存在且非零或非空，则假定时间在 UTC 时区;否则，时间被假定为本地时区。如果 <u>DST</u> 夏令时标志为正，则假定时间为夏令时；如果为零，则假定时间为标准时间；如果为负值（默认值）， **mktime**() 会尝试确定夏令时是否在指定时间生效。如果 <u>datespec</u> 没有包含足够的元素或者结果时间超出范围，则 **mktime**() 返回 -1。|
|strftime(\[format \[, timestamp\[, utc-flag\]\]\])|根据格式<u>format</u>中的规范格式化时间戳<u>timestamp</u>。 如果 <u>utc-flag</u> 存在且非零或非空，则结果采用 UTC，否则结果采用本地时间。 时间戳应与 **systime**() 返回的格式相同。 如果缺少时间戳<u>timestamp</u>，则使用当前时间。 如果缺少格式<u>format</u>，则使用与 **date**(1) 的输出等效的默认格式。 默认格式在 **PROCINFO\["strftime"\]** 中可用。 有关保证可用的格式转换，请参阅 ISO C 中 **strftime**() 函数的规范。

        systime() 返回当前时间作为自纪元以来的秒数（POSIX 系统上的 1970-01-01 00:00:00 UTC）。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|


## 8.12 位操作函数

## 8.13 类型函数

## 8.14 国际化函数

# 9 用户定义函数

# 10 动态载入新函数

# 11 信号

# 12 国际化

# 13 POSIX兼容

# 14 历史特性

# 15 GNU扩展

# 16 环境变量

# 17 退出状态

# 18 版本信息

# 19 作者

# 20 bug报告
# 21 bug
# 22 另请参阅
# 23 示例
# 24 致谢
# 25 版权许可

------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《Linux man手册页》</font>当前版本为sed4.7。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------
