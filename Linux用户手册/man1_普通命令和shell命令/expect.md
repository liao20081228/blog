---
title: **Expect**
tags: 普通命令
---

------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《Expect manpages》。</font>当前版本为5.45.4。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------

# 1 名称
Expect——使用交互式程序进行程序化对话，版本5。

# 2 概要

``` shell
Expect [ -dDinN ] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args ]
```
# 3 介绍

**Expect**是一个根据脚本来与其他交互式程序“对话”的程序。随着脚本执行，**Expect**知道程序可以期望什么，正确的响应应该是什么。解释型语言提供分支和高级控制结构来引导对话。此外，用户可以根据需要进行控制并直接进行交互，然后将控制权返回给脚本。

**Expect**k是****Expect****和**Tk**的混合物。它的行为就像****Expect****和**Tk**的**wish**。 ****Expect****也可以直接在C或C ++中使用（即不使用Tcl）。参见lib**Expect**(3)。

名称“**Expect**”来自在uucp，kermit和其他调制解调器控制程序中流行的send/**Expect**序列的概念。但是，与uucp不同，****Expect****是通用的，因此可以在考虑任何程序和任务的情况下将其作为用户级命令运行。****Expect****实际上可以同时与多个程序对话。

例如，以下是****Expect****可以做的一些事情：

* 使计算机回拨给您，以便您无需付费即可登录。
* 启动游戏（例如rogue），如果没有出现最佳配置，（一次又一次）重新启动它，直到完成为止，然后将控制权移交给您。
* 运行fsck，并根据预先确定的标准回答问题，回答“yes”，“no”或将控制权还给您。
* 连接到另一个网络或BBS（例如MCI Mail，CompuServe），并自动检索您的邮件，使其看起来就像原本就发送到本地系统一样。
* 在rlogin，telnet，tip，su，chgrp等之间携带环境变量，当前目录或任何类型的信息。

 Shell无法执行这些任务的原因有多种（尝试一下，您会看到的）。使用**Expect**，一切皆有可能。

通常，**Expect**主要用于运行那些需要与用户之间进行交互的程序，前提是可以交互可以字符串化和可以编程话。 如果需要，**Expect**还可以向用户返回控制权（而不会暂停受控制的程序）。 同样，用户可以随时将控制权返回给脚本。

# 4 用法

|Expect&emsp;|Expectk&emsp;&emsp;&emsp;&emsp;|说明|
|:--|:--|:--|
|cmdfile||**Expect**读取cmdfile以获取要执行的命令列表。在支持＃!的系统上，**Expect**也可能被隐式调用。通过将脚本标记为可执行文件，并在脚本的第一行中添加`#!/usr/bin/Expect -f`。<br /><br />当然，路径必须准确地描述**Expect**的安装位置。 /usr/bin只是一个示例。|
|-c cmds|-command cmds|cmds先于cmdfile中命令执行。该命令应加引号，以防止被shell破坏。此选项可以多次使用。通过使用分号将多个命令分开，可以使用单个-c执行多个命令。命令按照它们出现的顺序执行。
|-d|-diag|启用一些诊断输出，该诊断输出主要报告命令的内部活动，例如**Expect**和**interact**。此标志与在**Expect**脚本开头的“exp_internal 1”具有相同的作用，并且还会打印**Expect**的版本。（strace命令对跟踪语句很有用，trace命令对跟踪变量赋值很有用。）|
|-D num|-Debug num|标志启用交互式调试器。应该跟一个整数值。如果该值不为零或按下Ctrl+C（或达到断点，或脚本中出现其他合适的调试器命令），则调试器将在下一个Tcl过程之前获得控制权。有关调试器的更多信息，请参见README文件或另请参阅。| 
|-f| -file|为从中读取命令的文件添加序言。该标志本身是可选的，因为它仅在使用#!表示法时才有用（请参见上文），以便可以在命令行上提供其他参数。|
|-b|-buffer|默认情况下，命令文件被读入内存并完整执行。偶尔需要一次读取一行，例如读取标准输入。为了强制以这种方式处理任意文件，请使用-b标志。请注意，仍可以进行stdio缓冲，但是从fifo或stdin读取时这不会引起问题。
|-||如果字符串“-”作为文件名提供，则改为读取标准输入。 （使用“./-”从实际名为“-”的文件中读取。）
|-i|-interactive|使**Expect**以交互方式提示用户输入命令，而不是从文件中读取命令。通过exit命令或EOF终止提示。有关更多信息，请参见解析器（见后文）。如果既不指定命令文件也不使用-c，则假定为-i。|
|--||可以用来分隔选项的结尾。如果您希望将类似选项的参数传递给脚本而不用**Expect**解释，则这很有用。可以将其放在＃!行中，以防止**Expect**进行任何类似标志的解析。例如，`#!/usr/bin/Expect`会将原始参数（包括脚本名称）保留在变量argv中。<br /><br />请注意，在向#!行添加参数时，必须遵守通常的getopt(3)和execve(2)约定。|
|-N,-n|-NORC,-norc|除非使用-N标志，否则文件\$exp_library/Expect.rc（如果存在）会自动引入。 此后，除非使用-n标志，否则将自动引入文件~/.Expect.rc。如果定义了环境变量**DOTDIR**，则将其视为目录，并从该目录中读取.Expect.rc。仅在执行任何-c标志之后才进行这种引入。
|-v|-version|使**Expect**打印其版本号并退出。|
|args||可选的<u>args</u>被构造到一个列表中，并存储在名为<u>argv</u>的变量中。 <u>argc</u>初始化为<u>argv</u>的长度。<br /><br /><u>argv0</u>定义为脚本的名称（如果未使用脚本，则为二进制）。例如`send_user "$argv0 [lrange $argv 0 2]\n"`打印出脚本的名称和前三个参数。|

# 5 命令
**Expect**使用了Tcl（工具命令语言）。 Tcl提供控制流（例如，if,for,break）、表达式求值和其他一些特性，如递归、过程定义等。本文中使用了但额没有定义的命令（例如，set，if，exec）是Tcl命令（请参阅tcl(3)）。 **Expect**支持其他命令，如下所述。除非另有说明，否则命令将返回空字符串。

命令按字母顺序列出，以便可以快速找到它们。但是，新用户可能会发现通过按**spawn**、**send**、**Expect**和**interact**会更容易开始。

请注意，在“Exploring Expect”一书中提供了对语言（**Expect**和**Tcl**）的最佳介绍（请参阅下面的“另请参阅”）。此手册页包含了一些示例，但由于本手册页主要是作为参考资料，因此它们的使用范围非常有限。

请注意，在此手册页的文本中，带有大写字母“E”的“**Expect**”指的是**Expect**程序，而带有小写字母“e”的“**Expect**”指的是**Expect**程序中的**Expect**命令。

## 5.1 close
```shell
	close [-slave] [-onexec 0|1] [-i spawn_id]
```
关闭与当前进程的连接。大多数交互式程序在其stdin上检测EOF，然后退出；因此，close通常也足以终止该进程。 -i标志声明了对应spawn_id的进程，这个进程也将关闭。

当当前进程退出并隐式关闭时，**Expect**和**interact**会检测到。但是，如果通过“exec kill \$pid”杀死进程，则需要显式调用close。

**-onexec**标志确定是在新生成的进程中关闭spawn ID还是覆盖该进程。要使spawn ID保持打开状态，请使用值0。非0整数值将在所有新进程中强制关闭spawn（默认值）。

**-slave**标志关闭与生成ID关联的从站。 （请参阅“spawn -pty”。）当连接关闭时，从站也会自动关闭（如果仍然打开）。

无论是隐式还是显式关闭连接，都应调用**wait**清除相应的内核进程插槽。 **close**不调用**wait**，因为不能保证关闭进程连接将导致close退出。请参阅下面的**wait**以获取更多信息。

## 5.2 debug
``` shell
	debug [[-now] 0|1]
```
控制Tcl调试器，使您可以单步执行语句，设置断点等。

不带参数的情况下，如果调试器未运行，则返回1，否则返回0。

参数为1时，将启动调试器。如果参数为0，则调试器将停止。如果1参数前面带有-now标志，则调试器将立即启动（即，在debug命令本身中）。否则，调试器将随下一个Tcl语句启动。

debug命令不会更改任何trap。将其与以-D标志开头的**Expect**（请参见上文）进行比较。

有关调试器的更多信息，请参见README文件或另请参阅（以下）。

## 5.3 disconnect
断开fork进程程与终端的连接。它继续在后台运行。该进程还给自己的进程组（如果可能）。标准I/O重定向到/dev/null。

以下片段使用**disconnect**接在后台继续运行脚本。

``` shell
	if {[fork]!=0} exit
		disconnect
		. . .
```

下面的脚本读取一个密码，然后每小时运行一个程序，每次运行该程序都需要输入密码。该脚本提供了密码，因此您只需键入一次即可。 （请参阅stty命令，该命令演示了如何关闭密码回显。）

``` c
	send_user "password?\ "
	expect_user -re "(.*)\n"
	for {} 1 {} {
		if {[fork]!=0} {sleep 3600;continue}
		disconnect
		spawn priv_prog
		expect Password:
		send "$expect_out(1,string)\r"
		. . .
		exit
	}

```
与shell异步进程特性(＆)相比，使用**disconnect**的优点是**Expect**可以在断开连接之前保存终端参数，然后将其应用于新的ptys。使用＆，**Expect**没有机会读取终端的参数，因为在**Expect**收到控制权之前，终端已经断开连接。
## 5.4 exit

``` shell
	exit [-opts] [status]
```
导致**Expect**退出或准备退出。

**-onexit**标志使下一个参数用作退出处理程序。不带参数的情况下，将返回当前的退出处理程序。

**-noexit**标志使Expect准备退出，停止将控制权真正返回给操作系统。用户定义的退出处理程序以及Expect自己的内部处理程序都将运行。不再执行其他Expect命令。如果您在运行带有其他Tcl扩展的Expect，这将很有用。保留当前的解释器（如果在Tk环境中，则保留主窗口），以便其他Tcl扩展可以clean up。如果再次调用Expect的exit（但是可能会发生这种情况），则不会重新运行处理程序。

退出后，与派生进程的所有连接都将关闭。生成的进程会将关闭视为EOF。除了正常的_exit(2)过程，exit不会执行其他任何操作。因此，不检查EOF的派生进程可能会继续运行。 （例如，确定发送信号到到一个派生进程的条件是很重要的，但这些条件取决于系统，通常记录在exit(3)下。）继续运行的spawn进程将被init继承。

返回<u>status</u>（如果未指定，则为0）作为Expect的退出状态。如果到达脚本末尾，则隐式执行**exit**。

## 5.5 exp_continue

``` shell
	exp_continue [-continue_timer]
```
命令**exp_continue**允许**expect**自己继续执行，而不是像往常那样返回。默认情况下，**exp_continue**重置超时计时器。 **-continue_timer**标志可防止重新启动计时器。 （请参阅**expect**以获取更多信息。）
## 5.6 exp_internal

``` shell
	exp_internal [-f file] value
```
如果<u>value</u>非零，则导致其他命令将**Expect**内部的诊断信息发送到stderr。如果<u>value</u>为0，则禁用输出。诊断信息包括接收到的每个字符，以及将当前输出与模式进行匹配的所有尝试。

如果提供了可选file，则所有普通输出和调试输出都将写入该文件（与value的值无关）。任何先前的诊断输出文件都已关闭。

**-info**标志使exp_internal返回给定的最新non-info参数的描述。

## 5.3 exp_open

``` shell
	exp_open [args] [-i spawn_id]
```
返回与原始spawn ID对应的Tcl文件标识符。 然后可以使用文件标识符，就好像它是由Tcl的open命令打开的一样。 （不应再使用spawn ID。不应执行**wait**）。

**-leaveopen**标志使spawn ID保持打开状态，以便通过Expect命令进行访问。 必须在spawn ID上执行**wait**。

## 5.3 exp_pid

``` shell
	exp_pid [-i spawn_id]
```
返回与当前派生进程相对应的进程ID。 如果使用-i标志，则返回给定spawn ID的pid。

## 5.3 exp_send
**send**的别名。
## 5.3 exp_send_error
**send_error**的别名。
## 5.3 exp_send_log
**send_log**的别名。
## 5.3 exp_send_tty
**send_tty**的别名。
## 5.3 exp_send_user
**send_user**的别名。

## 5.3
```shell
exp_version [[-exit] version]
```

对于确保脚本与Expect的当前版本兼容很有用。

不带任何参数的情况下，返回Expect的当前版本。然后可以将此版本编码在您的脚本中。如果您知道自己没有使用最新版本的特性，则可以指定一个较早的版本。

版本由点号分隔的三个数字组成。首先是主版本号。为主版本号与当前版本不同的**Expect**编写的脚本几乎肯定无法工作。如果主数版本号不匹配，则exp_version返回错误。

第二个是次版本号。为次版本号比当前版本更大的**Expect**编写的脚本可能依赖某些新特性，且可能无法运行。如果脚本的主版本号匹配，但次版本号更大，则exp_version返回一个错误。

第三个是在版本比较中不起作用的数字。但是，以任何方式（例如通过附加文档或优化）更改Expect软件发行版时，该值都会增加。每个新的次版本将其重置为0。

**-exit**标志使得版本过时，Expect打印错误并退出。

## 5.x Expect

``` shell
	Expect [[-opts] pat1 body1] ... [-opts] patn [bodyn]
```

一直等待直到其中一个模式与生成的进程的输出匹配、经过了指定的时间段或看到文件结束为止。如果最后的body为空，则可以省略。

最近**Expect**_before命令的模式将在任何其他模式之前隐式使用。最近**Expect**_after命令的模式将在任何其他模式之后隐式使用。

如果整个**Expect**语句的参数需要多行，则所有参数都可以“括起来”为一行，从而避免以反斜杠续行。在这种情况下，尽管有括号，仍会发生一般的Tcl替换。

如果模式是关键字eof，则在文件结束时执行相应的body。如果模式是关键字timeout，则在超时时执行相应的body。如果不使用timeout关键字，则在超时时执行隐式null动作。默认超时时间为10秒，但可以通过命令“set timeout 30”将其设置为30秒，-1表示永不超时。如果模式是关键字default，则在超时或文件结束时执行相应的body。

如果模式匹配了，则执行相应的body。 **Expect**返回body的执行结果（如果没有匹配的模式，则返回空字符串）。如果有多个模式匹配，则执行首先出现的模式的body。

每次到达新输出时，都会按照列出的顺序将其与每个模式进行比较。因此，您可以通过确保最后一个模式（如提示）的出现来测试是否缺少匹配项。在没有提示的情况下，您必须使用超时（就像您手动进行交互一样）。

模式以三种方式指定。默认情况下，使用Tcl的字符串匹配命令指定模式。 （这种模式也类似于通常称为“glob”模式的C shell正则表达式）。 -gl标志可用于保护可能与**Expect**标志匹配的模式。任何以“-”开头的模式都应采用这种方式进行保护。 （所有以“-”开头的字符串都保留用于将来的选项。）

例如，以下片段查找一个成功的登录。 （请注意，推测abort是脚本中其他地方定义的过程。）

```shell
	**Expect** {
		busy               {puts busy\n ; exp_continue}
		failed             abort
		"invalid password" abort
		timeout            abort
		connected
	}

```
第四个模式必须用引号引起来，因为它包含一个空格，否则该空格会将模式与动作分开。 具有相同动作的模式（例如第三和第四）需要再次列出动作。 可以通过使用正则表达式样式的模式来避免这种情况（请参阅下文）。 在Tcl手册中可以找到有关glob-style模式的更多信息。

Regexp风格的模式遵循Tcl的regexp（“正则表达式”的缩写）命令定义的语法。 -re表示要使用正则表达式模式。 可以使用regexp将前面的示例重写为：

``` shell
	**Expect** {
		busy       {puts busy\n ; exp_continue}
		-re "failed|invalid password" abort
		timeout    abort
		connected
	}
```
两种类型的模式都是“未锚定的”。这意味着模式不必匹配整个字符串，但是可以在字符串中的任何位置开始和结束匹配（只要其他所有内容都匹配）。使用\^来匹配字符串的开头，并使用\$来匹配字符串的结尾。请注意，如果您不等待字符串的结尾，则当字符串是从生成的进程中回显时，响应很容易在字符串的中间结束。在仍然产生正确结果的同时，输出看起来可能不自然。因此，如果可以准确地描述字符串末尾的字符，则鼓励使用\$。

请注意，在许多编辑器中，\^和\$分别匹配行的开头和结尾。但是，由于**Expect**不是面向行的，因此这些字符与当前在**Expect**匹配缓冲区中的数据的开头和结尾（与行相对）匹配。 （另请参见下面有关“系统消化不良”的注释。）

-ex标志使模式匹配为“精确”字符串。不对\*，\^等进行解释（尽管仍然必须遵守通常的Tcl约定）。精确模式总是不锚定的。

 -nocase标志使输出的大写字符进行比较，就好像它们是小写字符一样。模式不受影响。

 在读取输出时，超过2000个字节会强制“忘记”较早的字节。这可以通过函数match_max进行更改。 （请注意，太大的值可能会减慢模式匹配器的速度。）如果patlist为full_buffer，则如果已接收到match_max字节且没有匹配其他模式，则将执行相应的body。不管是否使用full_buffer关键字，都会将“忘掉”的字符写到**Expect**_out(buffer)中。

如果patlist是关键字null，并且允许使用nulls（通过remove_nulls命令），则匹配单个ASCII 0时则将执行相应的body。无法通过glob或regexp模式匹配0个字节。

匹配模式（或eof或full_buffer）后，所有匹配的和以前不匹配的输出都将保存在变量**Expect**_out(buffer)中。最多9个正则表达式子字符串匹配项保存在**Expect**_out(1，string)到**Expect**_out（1，string）中。如果在模式之前使用-indices标志，则将10个字符串的开始和结束索引（以适合lrange的形式）存储在变量**Expect**_out(X，start)和**Expect**_out(X，end)中，其中X为数字，对应于缓冲区中子字符串的位置。 0表示与glob模式和regexp整个模式匹配的字符串。例如，如果某个进程的输出为“ abcdefgh\\n”，则：

``` shell
	**Expect** "cd"
```
的结果就像执行了以下语句：

``` shell
	set **Expect**_out(0,string) cd
	set **Expect**_out(buffer) abcd

```
			  
			  
			  
			  
			 
			 


## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3
## 5.3


------

***<font color=blue>版权声明</font>：本文翻译自<font color=blue>《**Expect** manpages》。</font>当前版本为5.45.4。<font color=red>未经作者允许</font>，<font color=blue>严禁用于商业出版</font>，<font color=red>否则追究法律责任。转载请注明出处！！！</font>***

------
