---
title: gawk
tags: 文本流编辑,man1
---


------

***<font color=blue>版权声明：</font>本文翻译自<font color=blue>《gawk manpages》。</font>gawk的版本为5.1.0，手册更新时间为2020-03-23。<font color=red>本文与原文档采用相同的版权许可。</font><font color=blue>转载请注明出处！！！</font>***

------

# 名称

gawk——模式扫描和处理语言。

# 总览
**gawk** \[ POSIX or GNU style options ] **-f** program-file \[ -- ] file ...
**gawk** \[ POSIX or GNU style options ] \[ -- ] program-text file ...

# 说明

<u>Gawk</u>是GNU项目对AWK编程语言的实现。它符合POSIX 1003.1标准中的语言定义。此版本也是基于Aho、Kernighan和Weinberger在《<u>AWK编程语言</u>》中的描述。 <u>Gawk</u>提供了Brian Kernighan awk中的额外功能以及许多特定于GNU的扩展功能。

命令行由<u>gawk</u>本身选项、AWK程序文本（如果未通过 **-f** 或 **--include** 选项提供程序文件）、在预定义的AWK变量 **ARGC** 和 **ARGV** 中的可用值组成。

当使用 **--profile** 选项调用<u>gawk</u>时，<u>gawk</u>将开始从程序的执行中收集性能分析统计信息。 <u>Gawk</u>在这种模式下运行速度较慢，并且在完成后会自动在文件 **awkprof.out** 中生成一个执行性能文件。请参见下面的 [**--profile**](#profile) 选项。

<u>Gawk</u>还具有集成的调试器。可以通过在命令行中指定 **--debug** 选项来启动交互式调试会话。在这种执行方式下，<u>awk</u>将加载AWK源码，然后提示调试命令。 <u>Gawk</u>只能调试 **-f** 和 **--include**  选项提供的AWK程序源码。调试器在《<u>[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)</u>》中有说明。

# 选项格式

<u>gawk</u>选项可以是POSIX风格的单字符选项，或者GNU风格的长选项。POSIX选项是以“-”开始，而GNU长选项是以“--”开始。GNU特定功能和POSIX必须功能都提供了长选项。

特定于<u>gawk</u>的选项通常以长选项形式使用。 长选项的参数可以紧跟在选项后的“=”符号之后（中间没有空格），也可以在下一个命令行参数中提供。 只要缩写保持唯一，长选项就可以缩写。

此外，每一个长选项有一个相应的短选项，以便可以在 **#!** 可执行脚本中使用该选项。

# 选项
<u>gawk</u>接受以下选项。 首先列出标准选项，然后列出<u>gawk</u>扩展的选项。按短选项按字母顺序列出。
|短选项|长选项|说明|
|:--|:--|:--|
|-b|--characters-as-bytes|将所有输入数据视为单字节字符。 换句话说，在尝试将字符串作为多字节字符处理时，不必特别注意语言环境信息。 **--posix** 选项将覆盖此选项。|
|-c|--traditional|以兼容模式运行。 在兼容模式下，<u>gawk</u>的行为与Brian Kernighan awk相同； 无法识别特定于GNU的扩展。 有关更多信息，请参见下面的[GNU扩展](#GNUEXTENSIONS)。|
|-C|--copyright|在标准输出上打印GNU版权信息的简短版本，然后成功退出。|
|-d\[file]|--dump-variables\[=file]|将全局变量以及它们的类型和最终值的排序列表打印到文件<u>file</u>中。如果未提供文件<u>file</u>，则<u>gawk</u>在当前目录中输出名为**awkvars.out**的文件。列出所有全局变量是在程序中查找“按错键错误”的好方法。如果您的大型程序具有很多函数，并且还希望确保您的函数不会无意中使用本应是局部变量的全局变量，那么您也可以使用此选项。（使用i，j等简单变量名称时，这是一个特别容易犯的错误。）|
|-D\[file]|--debug\[=file]|启用AWK程序调试。默认情况下，调试器从键盘（标准输入）以交互方式读取命令。可选的<u>file</u>参数指定一个文件，其中包含命令列表，以供调试器以非交互方式执行。|
|-e program-text|--source program-text|使用<u>program-text</u>作为AWK程序源代码。通过此选项，可以轻松地将库函数（通过 **-f** 和 **--include** 选项使用）与在命令行中输入的源代码混合在一起。它主要用于Shell脚本中的中大型AWK程序。通过 **-e** 提供的每个参数都被视为以隐式 **@namespace "awk"** 语句开头。|
|-E file|--exec file|与 **-f** 相似，但是，此选项是最后处理的选项。这个选项与 **＃!** 脚本一起使用，以避免在命令行中从URL传入选项或源代码（!），尤其是CGI应用程序脚本。此选项禁用命令行变量赋值。|
|-f program-file|--file program-file|从文件<u>program-file</u>中读取AWK程序，而不是从第一个命令行参数中读取。可以使用多个 **-f**（或 **--file**）选项。使用 **-f** 读取的文件被视为以隐式的 **@namespace "awk"** 语句开头。|
|-F fs|--field-separator fs|将<u>fs</u>用作输入字段分隔符（预定义变量**FS**的值）。|
|-g|--gen-pot|扫描并解析AWK程序，并在标准输出上生成GNU **.pot**（可移植对象模板）格式文件，其中包含该程序中所有可区域化字符串条目。程序本身未执行。有关 **.pot** 文件的更多信息，请参见[GNU gettext](#gnu_gettext)分发。|
|-h|--help|在标准输出上打印可用选项的简短摘要。 （根据**GNU编码标准**，这选项会导致立即成功退出。）|
|-i include-file|--include include-file|加载awk源码库。这将使用环境变量**AWKPATH**来搜索该库。如果首次搜索失败，则在加上 **.awk** 后缀之后再次尝试。该文件将仅加载一次（消除重复），并且这些代码不构成主程序源码。用 **--include** 读取的文件被视为以隐式 **@namespace "awk"** 语句开头。|
|-l lib|--load lib|从共享库库中加载<u>gawk</u>扩展。 awk将使用环境变量**AWKLIBPATH**来搜索该库。 如果首次搜索失败，则在为加上平台默认共享库后缀后再次尝试。 库的初始化例程应命名为**dl_load()**。|
|-L \[value]|--lint\[=value]|提供有关可疑或不可移植到其他AWK实现的构造的警告。 如果使用可选参数**fatal**，则温柔警告会变成致命错误。 这可能很激烈，但是使用它肯定会鼓励开发更清洁的AWK程序。 使用可选参数**invalid**，仅发出有关确实无效的警告（这尚未完全实现）。使用可选参数**no-ext**，将禁用有关<u>gawk</u>扩展的警告。|
|-M|--bignum|对数字强制执行任意精度计算。如果编译<u>gawk</u>未使用GNU MPFR和GMP库，则此选项无效。（在这种情况下，<u>gawk</u>会发出警告。）|
| -n|--non-decimal-data|识别输入数据中的八进制和十六进制值。请谨慎使用此选项！|
|-N|--use-lc-numeric|强制<u>gawk</u>在解析输入数据时使用语言环境的小数点字符。尽管POSIX标准要求此行为，并且当 **--posix**生效时<u>gawk</u>会这样做，但默认情况是遵循传统行为，并使用句点作为小数点，即使在句点不是小数点字符的语言环境中也是如此。此选项将覆盖默认行为，而没有 **--posix**选项的严格要求。|
|-o\[file]|--pretty-print\[=file]|将程序的完美打印版本输出到文件<u>file</u>中。如果未提供文件<u>file</u>，则<u>gawk</u>在当前目录中输出名为**awkprof.out**的文件。此选项暗示 **-no-optimize**。|
|-O| --optimize|在程序的内部表示形式上启用<u>gawk</u>的默认优化。当前，这仅包括简单的常量折叠（一种编译优化技术）。默认情况下，此选项处于启用状态。|
|-p\[prof-file]|-profile\[=prof-file]|<span id="profile">启动</span>性能分析会话，然后将性能数据发送到<u>prof-file</u>。默认值为**awkprof.out**。该配置文件在左边包含程序中每个语句的执行计数，以及每个用户定义函数的函数调用计数。此选项暗示 **--no-optimize**。|
|-P|--posix|这将打开兼容模式，并具有以下限制：<ul><li>无法识别 **\\x** 转义序列</li><li>在 **?** 和 **:** 后无法继续</li><li>无法识别关键字**function**的同义词**func**</li><li>不能使用 \*\* 和 \*\*= 来代替\^和\^=</li></ul>|
|-r|--re-interval|在正则表达式匹配中启用<u>间隔表达式</u>的使用（请参见下面的[正则表达式](#regexp)）。传统上，<u>间隔表达式</u>在AWK语言中不可用。 POSIX标准添加了它们，以使awk和<u>egrep</u>彼此一致。它们是默认启用的，但此选项仍可与 **--traditional**一起使用。|
|-s|--no-optimize|在程序的内部表示形式上禁用<u>gawk</u>的默认优化。|
|-S|--sandbox|在沙盒模式下运行<u>gawk</u>，禁用**system()**函数、**getline**输入重定向，**print**和**printf**输出重定向，以及加载动态扩展。命令执行（通过管道）也被禁用。这有效地阻止了脚本访问本地资源，命令行上指定的文件除外。|
|-t|--lint-old|提供有关不可移植到UNIX awk原始版本的构造的警告。|
|-v var=val|--assign var=val|在程序开始执行之前，将值<u>val</u>分配给变量<u>var</u>。这样的变量值可用于AWK程序的**BEGIN**规则。|
|-V|--version|在标准输出上打印该<u>gawk</u>特定副本的版本信息。 这主要用于了解当前系统上的<u>gawk</u>是否是自由软件基金会正在分发的最新版本。 报告bug时，这也很有用。 （根据**GNU编码标准**，此选项会导致立即成功退出。）
|--||选项结束信号。 这允许AWK程序的其他参数以“-”开头。 这与大多数其他POSIX程序使用的参数解析约定保持一致。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|

在兼容模式下，任何其他选项均标记为无效，否则将被忽略。 在正常操作中，只要提供了程序文本，在**ARGV**数组中的未知选项会传递给AWK程序进行处理。这对于通过 **＃!** 可执行解释器机制运行AWK程序特别有用。

为了实现POSIX兼容性，可以使用 **-W**选项，后跟长选项的名称。

# AWK程序执行
AWK程序由一系列可选指令、模式动作语句和可选的函数定义组成。

``` awk
@include "filename"
@load "filename"
@namespace "name"
pattern   { action statements }
function name(parameter list) { statements }
```
<u>gawk</u>首先从<u>program-files</u>（如果指定了）、**--source**的参数、或命令行上的第一个非选项参数中读取程序源码。 **-f**和 **--source**选项可以在命令行上多次使用。 <u>gawk</u>读取程序文本就好像所有<u>program-files</u>文件和命令行源码都连接在一起一样。这对于构建AWK函数库很有用，而不必在使用它们的每个新AWK程序中都包含它们。它还提供了将库函数与命令行程序混合的功能。

此外，以 **@include**开头的行可用于将其他源文件包括到您的程序中，从而使库的使用更加容易。这等效于使用 **--include**选项。

以 **@load**开头的行可用于将扩展功能加载到您的程序中。这等效于使用 **--load**选项。

环境变量**AWKPATH**指定了查找 **-f**和 **--include**选项指定的源文件时使用的搜索路径。如果该变量不存在，则默认路径为 **“.:/usr/local/share/awk”** 。 （实际目录可能会有所不同，具体取决于<u>gawk</u>的构建和安装方式。）如果给 **-f**选项指定的文件名包含“/”字符，则不会执行路径搜索。

环境变量**AWKLIBPATH**指定查找 **--load**选项指定的源文件时要使用的搜索路径。如果该变量不存在，则默认路径为 **“/usr/local/lib/gawk”**。 （实际目录可能会有所不同，具体取决于<u>gawk</u>的构建和安装方式。）

<u>gawk</u>按以下顺序执行AWK程序。首先，执行通过 **-v**选项指定的所有变量赋值。接下来，<u>gawk</u>将程序编译为内部形式。然后，<u>gawk</u>执行**BEGIN**规则（如果有）中的代码，然后继续读取**ARGV**数组中的每个文件（直到**ARGV\[ARGC-1]**）。如果在命令行上没有指定文件，则<u>gawk</u>将读取标准输入。

如果命令行上的文件名格式为<u>var</u>=<u>val</u>，则将其视为变量赋值。变量<u>var</u>将被赋值为<u>val</u>（这会在**BEGIN**规则被运行之后发生）。命令行变量赋值对于将值动态地赋值给AWK用于控制如何将输入分成字段和记录的变量最有用。如果在单个数据文件上需要多次传递，则命令行变量赋值对于控制状态也很有用。

如果**ARGV**的特定元素的值为空（""），则<u>gawk</u>将跳过它。

对于每个输入文件，如果存在**BEGINFILE**规则，则<u>gawk</u>将在处理文件内容之前执行关联的代码。同样，<u>gawk</u>在处理文件后执行与**ENDFILE**关联的代码。

对于输入中的每个记录，<u>gawk</u>进行测试以查看其是否与AWK程序中的任何模式<u>pattern</u>匹配。对于记录匹配的每个模式，<u>gawk</u>将执行关联的动作<u>action</u>。模式<u>pattern</u>按照它们在程序中出现的顺序进行测试。

最后，在所有输入完毕后，<u>gawk</u>将执行**END**规则（如果有）中的代码。

## 命令行目录

根据POSIX，在awk命令行上指定的文件必须是文本文件。 如果不是文本文件，则行为是未定义的。 大多数版本的awk将命令行上指定目录视为致命错误。

从<u>gawk</u>的4.0版本开始，命令行上指定目录会生成警告，但会被跳过。 如果给出了 **--posix**或 **--traditional**选项，则<u>gawk</u>将命令行上指定目录视为致命错误。

# 变量、记录、字段
AWK变量是动态的；它们在首次使用时就存在。它们的值可以是浮点数或字符串，或两者兼有，这取决于它们的使用方式。此外，<u>gawk</u>允许变量具有正则表达式类型。 AWK还有一维数组；可以模拟具有多维数组。 <u>gawk</u>提供了真正的数组；请参阅后面的[数组](#arrays)。在程序运行时会设置几个预定义的变量；这些变量由于需要进行了说明，并总结在后面。

## 记录

通常，记录由换行符分隔。您可以通过给内建变量**RS**赋值来控制记录的分隔方式。如果**RS**是任意单个字符，则该字符将分隔记录。否则，**RS**是一个正则表达式。输入中与此正则表达式匹配的文本将记录分隔开。但是，在兼容模式下，仅将其字符串的第一个字符用于分隔记录。如果将**RS**设置为空字符串，那么记录将由空行分隔。当**RS**设置为空字符串时，除**FS**可能具有的值外，换行符还始终充当字段分隔符。注意：当**RS**为正则表达式时，**IGNORECASE**的值（请[参见下文](#IGNORECASE)）会影响如何分隔记录。
<span id='filed'></span>
## 字段
当每个输入的记录被读取时，<u>gawk</u>会把**FS**变量的值用作字段分隔符以将记录分成多个字段。如果**FS**是单个字符，则字段由该字符分割。如果**FS**是空字符串，则各个字符都将成为一个单独的字段。否则，**FS**应该是完整的正则表达式。在特殊情况下，**FS**是单个空格，字段之间通过空格、制表符、换行符分割。注意：当**FS**为正则表达式时，**IGNORECASE**的值（请[参见下文](#IGNORECASE)）会影响如何拆分字段。

如果将**FIELDWIDTHS**变量设置为以空格分隔的数字列表，则每个字段应具有固定的宽度，且<u>gawk</u>使用指定的宽度拆分记录。每个字段宽度可以可选地以冒号分隔的值开头，该值指定在字段开始之前要跳过的字符数。 **FS**的值将被忽略。为**FS**或**FPAT**赋新值将覆盖**FIELDFIDTHS**的使用。

类似的，如果将**FPAT**变量设置为表示正则表达式的字符串，则每个字段均由与该正则表达式匹配的文本组成。在这种情况下，正则表达式描述字段本身，而不是分割字段的文本。为**FS**或**FIELDWIDTHS**分配新值将覆盖**FPAT**的使用。

输入的记录中的每个字段都可以通过其位置引用：**\$1**，**\$2**，依此类推。 **\$0**是整个记录，包括前导和尾随空白。字段不需通过常量引用：

``` awk
n = 5
print $n
```

打印输入记录中的第五个字段。

变量**NF**为输入记录中字段的总数。

对不存在的字段（即 **\$NF** 之后的字段）的引用将产生空字符串。但是，赋值给不存在的字段（例如，**\$(NF + 2)= 5**）会增加 **NF** 的值，创建以空字符串作为值的中间字段，并导致重新计算 **\$0** 的值，字段之间用**OFS**的值分割。引用负数字段会导致致命错误。减小**NF**会导致超过新值的字段的值丢失，并重新计算 **\$0** 的值，其字段之间用**OFS**值分割。

为已有字段赋值值会导致在引用 **\$0** 时重建整个记录。 同样，为 **\$0** 赋值会导致记录被重拆分，从而为字段创建新值。

## 内建变量
<u>gawk</u>的内置变量如下：

|变量|说明|
|:--|:--|
|ARGC|命令行参数的数量（不包括<u>gawk</u>的选项或程序源码）|
|ARGIND|正在处理的当前文件在**ARGV**中的索引|
|ARGV |命令行参数数组。该数组的索引从0到**ARGC**-1。动态更改**ARGV**的内容可以控制用于数据的文件。|
|BINMODE|在非POSIX系统上，为所有文件I/O指定使用“二进制”模式。数值1、2、3分别指定输入文件、输出文件、所有文件应使用二进制I/O。字符串值"**r**"或"**w**"指定输入文件或输出文件使用二进制I/O。字符串值"**rw**"或"**wr**"指定所有文件应使用二进制I/O。任何其他字符串值都被视为"**rw**"，但会生成警告消息。|
|CONVFMT|默认情况下，数字的转换格式为"**％.6g**"。|
|ENVIRON|包含当前环境值的数组。该数组通过环境变量进行索引，每个元素都是对应环境变量的值（例如**ENVIRON\["HOME"]**可能是"**/home/arnold**"）。<br />在POSIX模式下，更改此数组不会影响<u>gawk</u>通过重定向或system()函数生成的程序所看到的环境。否则，<u>gawk</u>将更新其实际环境，以便其生成的程序可以看到更改。|
| ERRNO|如果在重定向**getline**、读取**getline**、**close**()期间发生错误，则将**ERRNO**设置为描述该错误的字符串。该值可以在非英语语言环境中进行翻译。如果**ERRNO**中的字符串与<u>errno</u>(3)变量中的系统错误相匹配，则可以在 **PROCINFO\["errno"]** 中找到该数值。对于非系统错误，**PROCINFO\["errno"]** 将为零。|
|FIELDWIDTHS|以空白分隔的字段宽度列表。设置后，<u>gawk</u>会将输入解析为固定宽度的字段，而不是使用**FS**变量的值作为字段分隔符。可选地，每个字段宽度前面都可以有一个冒号分隔的值，该值指定在字段开始之前要跳过的字符数。参见前面的[字段](#filed)。|
|FILENAME| 当前输入文件的名称。如果在命令行上未指定文件，则**FILENAME**的值为“-”。但是，**FILENAME**在BEGIN规则内是未定义的（除非由**getline**设置）。|
|**FNR**|当前输入文件中的输入记录号。|
|FPAT|描述记录中字段内容的正则表达式。设置后，<u>gawk</u>会将输入解析为与正则表达式匹配的字段，而不是使用**FS**的值作为字段分割符。参见前面的[字段](#filed)。|
|**FS**|输入字段分割符，默认为空格。参见前面的[字段](#filed)。|
|FUNCTAB |一个数组，其索引和对应值是程序中所有用户定义或扩展函数的名称。注意：您不能与**FUNCTAB**数组一起使用**delete**语句。|
|<span id="IGNORECASE">IGNORECASE</span>|控制所有正则表达式和字符串操作的是否区分大小写。如果**IGNORECASE**具有非零值，则在规则中进行字符串比较和模式匹配，使用**FS**和**FPAT**进行字段拆分，使用**RS**进行记录分隔，使用 **\~** 和 **!\~** 匹配正则表达式，以及内置函数**gensub**()、**gsub**()、**index**()、**match**()、**patsplit**()、**split**()和**sub**()在进行正则表达式操作时都会忽略大小写。注意：数组下标不受影响，但是**asort**()和**asorti**()函数会受到影响。<br /><br />因此，如果**IGNORECASE**不等于零，则 **/aB/** 匹配所有字符串“**ab**”，“**aB**”，“**Ab**”和“**AB**”。与所有AWK变量一样，**IGNORECASE**的初始值为零，因此所有正则表达式和字符串操作通常区分大小写。|
|LINT|在AWK程序中提供 **--lint**选项的动态控制。 如果为**true**，<u>gawk</u>将打印温和警告。 如果为**fasle**，则不会。 当为**LINT**赋值"**fatal**"时，温和警告将成为致命错误，与 **--lint=fatal**一样。 其他任何真值只会显示警告。|
|**NF**|当前输入记录中的字段数。|
|**NR**|到目前为止看到的输入记录总数。|
|OFMT|默认情况下，数字的输出格式为"**％.6g**"。|
|**OFS**|输出字段分隔符，默认为空格。|
|**ORS**|输出记录分隔符，默认情况下为换行符。|
|PREC|任意精度浮点数的有效精度，默认为53。|
|PROCINFO|该数组的元素提供了访问正在运行的AWK程序的信息的接口。参见下面的[PROCINFO](#PROCINFO)。|
|ROUNDMODE|用于对数字进行任意精度算术的舍入模式，默认情况下为"N"（IEEE-754 roundTiesToEven模式）。可接受的值为：<br /><br /> "A" 或 "a"&emsp;&emsp;roundAwayFromZero。仅当您的GNU MPFR库版本支持roundAwayFromZero才可用。<br /><br />"D" 或 "d"&emsp;&emsp; roundTowardNegative。<br /><br />"N" 或 "n"&emsp;&emsp;roundTiesToEven。<br /><br />"U" or "u" &emsp;&emsp;roundTowardPositive。<br /><br />"Z" or "z" &emsp;&emsp;roundTowardZero。|
|**RS**|输入记录分隔符，默认情况下为换行符。|
|**RT**|记录终止符。 <u>gawk</u>将**RT**设置为与**RS**指定的字符或正则表达式匹配的输入文本。|
|RSTART|**match**()匹配的第一个字符的索引。如果没有匹配，则为0。（这意味着字符索引从1开始。）|
|RLENGTH |**match**()匹配的字符串的长度；如果没有匹配，则为-1。|
|SUBSPEP|默认情况下，用于分隔数组元素中多个下标的字符串“**\034**”。|
|SYMTAB|一个数组，其索引是程序中所有当前定义的全局变量和全局数组的名称。该数组可用于间接访问以读取或写入变量的值：<br />&emsp;&emsp; foo = 5<br />&emsp;&emsp;SYMTAB["foo"] = 4<br />&emsp;&emsp;print foo    # prints 4<br />**typeof**()函数可用于测试**SYMTAB**中的元素是否为数组。您不能将**delete**语句与**SYMTAB**数组一起使用，也不能赋值给索引不是变量名的元素。|
|TEXTDOMAIN |AWK程序的文本域；用于查找程序字符的本地化翻译。|

在某些系统上，**PROCINFO**数组中可能存在一些元素，从"**group1**"到"**groupn**"，<u>n</u>是进程具有的补充组的数量。使用**in**运算符测试这些元素。以下元素保证可以使用：

|<span id='PROCINFO'>PROCINFO数组元素</span>|说明|
|:--|:--|
|PROCINFO["argv"]|<u>gawk</u>在C语言级别上接收到的命令行参数。下标从零开始。|
|PROCINFO["egid"]|系统调用<u>getegid</u>(2)的值。|
|PROCINFO["errno"] |当**ERRNO**设置为关联的错误消息时，<u>errno</u>(3)的值。|
|PROCINFO["euid"]|系统调用<u>geteuid</u>(2)的值。|
|PROCINFO ["FS"]| 如果使用**FS**进行字段拆分则为"**FS**"；如果使用**FPAT**进行字段拆分，则为"**FPAT**"；如果使用**FIELDWIDTHS**进行字段拆分，则为"FIELDWIDTHS"；如果使用**API**输入解析器拆分字段，则为"**API**"。|
|PROCINFO["gid"]|系统调用**getgid**(2)的值。|
|PROCINFO["identifiers"] |子数组，由AWK程序文本中使用的所有标识符的名称索引。这些值表示<u>gawk</u>在完成对程序的解析之后知晓了这些标识符；它们不会在程序运行时更新。对于每个标识符，元素的值是以下值之一：<br />"array"&emsp;&emsp;标识符是一个数组。<br />"builtin"&emsp;&emsp;标识符是内置函数。<br />"extension"&emsp;&emsp; 标识符是通过 **@load**或 **--load**加载的扩展函数。<br />"scalar"&emsp;&emsp;标识符是标量。<br />"untyped"&emsp;&emsp;标识符是无类型的（可以用作标量或数组，<u>gawk</u>尚不知道）。<br />"user"&emsp;&emsp;标识符是用户定义的函数。|
|PROCINFO["pgrpid"]|系统调用<u>getpgrp</u>(2)的值。|
|PROCINFO["pid"]|系统调用<u>getpid</u>(2)的值。
|PROCINFO["platform"]|一个字符串，指示编译<u>gawk</u>的平台。它是以下之一：<br />"djgpp"&emsp;&emsp;Microsoft Windows使用DJGPP<br />"mingw" &emsp;&emsp;Microsoft Windows使用MinGW。<br />"os2"&emsp;&emsp;OS/2。<br />"posix"&emsp;&emsp;GNU/Linux，Cygwin，Mac OS X和传统的Unix系统。<br />"vms"&emsp;&emsp;OpenVMS或Vax/VMS。|
|PROCINFO["ppid"]|系统调用<u>getppid</u>(2)的值。|
|PROCINFO["strftime"]|**strftime**()的默认时间格式字符串。更改其值会影响无参数调用**strftime**()时格式化时间值的方式。|
|PROCINFO["uid"]|系统调用**getuid**(2)的值。|
|PROCINFO["version"]|<u>gawk</u>的版本。|

如果可以加载动态扩展，则存在以下元素：
|PROCINFO数组元素|说明|
|:--|:--|
| PROCINFO["api_major"]|扩展API的主要版本。|
|PROCINFO["api_minor"]|扩展API的次要版本。|

如果将MPFR支持编译到<u>gawk</u>中，则可以使用以下元素：
|PROCINFO数组元素|说明|
|:--|:--|
|PROCINFO["gmp_version"]| Gaw GMP中用于任意精度数字支持的GNU GMP库版本。|
| PROCINFO["mpfr_version"]| Gaw MP中用于任意精度数字支持的GNU MPFR库版本。|
|PROCINFO["prec_max"]|GNU MPFR库支持的任意精度浮点数的最大精度。|
|PROCINFO["prec_min"]|GNU MPFR库允许的任意精度浮点数的最低精度。|

一格程序可以设置以下元素来更改<u>gawk</u>的行为：

|PROCINFO数组元素|说明|
|:--|:--|
|PROCINFO["NONFATAL"]|如果存在，则所有重定向的I/O错误都不会致命。|
|PROCINFO["name", "NONFATAL"]|使<u>name</u>指明的I/O错误非致命。|
|PROCINFO["command", "pty"]|使用伪tty与命令<u>command</u>进行双向通信，而不是设置两个单向管道。|
|PROCINFO["input", "READ_TIMEOUT"]|从输入读取数据的超时时间（以毫秒为单位），其中输入是重定向字符串或文件名。零或小于零的值表示没有超时设置。|
|PROCINFO["input", "RETRY"]|如果从输入读取数据时可能发生重试I/O错误，并且此数组项存在，则**getline**返回-2，而不是遵循默认行为返回-1，并将输入配置为不返回其他数据。可能重试的I/O错误是<u>errno</u>(3)的值为**EAGAIN**，**EWOULDBLOCK**，**EINTR**或**ETIMEDOUT**的错误。这在与 **PROCINFO["input", "READ_TIMEOUT"]** 联用，或在文件描述符已配置为以非阻塞方式运行的情况下很有用。|
|PROCINFO["sorted_in"]|如果**PROCINFO**中存在此元素，则其值控制在**for**循环中遍历数组元素的顺序。 支持的值是"**@ind_str_asc**"、"**@ind_num_asc**"、"**@val_type_asc**"、"**@val_str_asc**"、"**@val_num_asc**"、"**@ind_str_desc**"、"**@ind_num_desc**"、"**@val_type_desc**"、"**@val_str_desc**"、"**@val_num_desc**"和 "**@unsorted**"。 该值也可以是如下定义的比较函数的名称（以字符串形式）：<br />&emsp;&emsp;function cmp_func(i1,v1,i2,v2)<br />其中<u>i1</u>和<u>i2</u>是索引，而<u>v1</u>和<u>v2</u>是要比较的两个元素的对应值。 它应返回小于、等于或大于0的数字，具体取决于数组元素的排序方式。|
<span id='arrays'> </span>
## 数组

数组用方括号（[]）之间的表达式作为下标。如果表达式是表达式列表（expr，expr ...），则数组下标是由每个表达式的（字符串）值的串联组成的一个字符串，并由**SUBSEP**变量的值分隔。此功能用于模拟多维数组。例如：

``` awk
i = "A"; j = "B"; k = "C"
x[i, j, k] = "hello, world\n"
```
将字符串“**hello，world\n**”赋值给数组**x**的索引为字符串“**A\034B\034C**”的元素。AWK中的所有数组都是关联的，即由字符串值索引。

特殊运算符**in**可用于测试数组是否具有由特定值组成的索引：
```awk
if (val in array)
	print array[val]
```
如果数组有多个下标，请在数组中使用 **(i，j)**。

**in**运算符也可以在**for**循环中使用，以迭代数组的所有元素。 但是，**(i,j) in arrsy** 仅适用于测试，不适用于**for**循环。
可以使用**delete**语句从数组中删除元素。**delete**语句可以通过指定不带下标的数组名来删除数组的全部内容。

<u>gawk</u>支持真正的多维数组。 它不需要像C或C++中那样的数组是“矩形”的。 例如：

``` c++
a[1] = 5
a[2][1] = 6
a[2][2] = 7
```
注意：您可能需要告诉<u>gawk</u>，数组元素真的是一个子数组，以便在<u>gawk</u>需要数组的地方使用它（例如，在**split**()的第二个参数中）。 您可以通过在子数组中创建一个元素，然后使用**delete**语句将其删除来做到这一点。 

## 命令空间

<u>gawk</u>提供了一种简单的命名空间功能，可帮助解决AWK中所有变量都是全局变量这一事实。

限定名称由两个简单标识符中间加一个双冒号(::)组成。左侧标识符代表命名空间，右侧标识符是其中的变量。所有简单（非限定）名称都被视为在当前默认命名空间**awk**中。但是，即使当前命名空间不同，仅由大写字母组成的简单标识符也会被放入awk命名空间。

您可以使用`@namespace "name"`指令更改当前命名空间。

标准的预定义内置函数名不能用作命名空间名。由<u>gawk</u>提供的附加函数名可以用作命名空间名或其他命名命名空间中的简单标识符。有关更多详细信息，请参见<<GAWK：[effective_awk_programing)>>。

## 变量键入和转换
 变量和字段可以是（浮点）数字、字符串或两者都是，也可以是正则表达式。变量的值如何解释取决于其上下文。如果在数字表达式中使用，它将被视为数字。如果用作字符串，它将被视为字符串。

要强制将变量视为数字，请向其添加零。要强制将其视为字符串，请将其与空字符串连接。

未初始化的变量的数字值为零，字符串值为""（空字符串）。

当必须将字符串转换为数字时，可以使用<u>strtod</u>(3)来完成。通过将**CONVFMT**的值作为<u>sprintf</u>(3)的格式字符串并将变量的数值作为参数来将数字转换为字符串。然而，即使AWK中的所有数字都是浮点数，整数值始终会转换为整数。因此，给定
```awk
CONVFMT =“％2.2f”
a = 12
b = a""
```
变量**b**的字符串值为“**12**”，而不是“**12.00**”。

注意：在POSIX模式下运行时（例如使用 **--posix**选项），请注意语言环境设置可能会干扰十进制数字的处理方式：输入给<u>gawk</u>的数字的十进制分隔符必须符合您的语言环境，可能是逗(,)或句点(.)。

<u>gawk</u>执行以下比较：如果两个变量为数字，则将对其进行数字比较。如果一个值是数字，而另一个值是“数字字符串”，则比较也会以数字方式进行。否则，将数值转换为字符串并执行字符串比较。当然，将两个字符串变量是作为字符串进行比较。

请注意，字符串常量（例如“**57**”）不是数字字符串，而是字符串常量。 “数字字符串”的概念仅适用于字段、**getline**输入、**FILENAME**、**ARGV**元素、**ENVIRON**元素以及由**split**()或**patsplit**()创建的数字字符串数组的元素。基本思想是看起来像数字的用户输入且只有看起来像数字的用户输入应该以这种方式处理。

## 八进制和十六进制常数

您可以在AWK程序源代码中使用C风格的八进制和十六进制常量。例如，八进制值**011**等于十进制**9**，十六进制值**0x11**等于十进制**17**。

## 字符串常量
AWK中的<span id='stringconstant'>字符串常量</span>是用双引号引起来的字符序列（例如“value”）。在字符串中，可以识别某些转义序列，就像C语言中一样。它们是：
|转义序列|说明|
|:--|:--|
|\\\|反斜杠。|
|\a|“警报”字符；通常是ASCII BEL字符。|
|\b|退格键。|
|\f|换页符。|
|\n|换行符。|
|\r|回车。|
|\t|水平制表符。|
|\v|垂直制表符。|
|\xhex digits|数字。\x后面跟十六进制数字。\x后面跟两个十六进制数字被认为是转义序列的一部分。例如，“**\x1B**”是ASCII ESC（转义）字符。|
|\ddd|数字。由的1位，2位或3位八进制数序列表示的字符。例如，“**\033**”是ASCII ESC（转义）字符。|
|\c|文字字符c。|

在兼容模式下，当在正则表达式常量中使用时，由八进制和十六进制转义序列表示的字符将按字面处理。因此，`/a\52b/`等效于 `/a\*b/`。

## 正则表达式常量

正则表达式常量是用两个正斜杠（例如 **/value/**）括起来的一系列字符。 正则表达式匹配将在下面regexp更全面地描述。 请参阅[正则表达式](#regexp)。

前面描述的转义序列也可以在正则表达式常量中使用（例如`/[ \t\f\n\r\v]/`匹配空白字符）。

<u>gawk</u>提供强类型的正则表达式常量。 这些均以 **@** 符号开头（例如：**@/value/**）。 可以将此类常量分配给标量（变量，数组元素），并传递给用户定义的函数。 这样赋值的变量具有正则表达式类型。

# 模式和动作
AWK是一种面向行的语言。先模式，后动作。动作语句包含在 **{** 和 **}** 中。可以省略模式或动作，但不能都省略。如果省略模式，则对每条输入记录执行该动作。如果省略动作，则等效于 **{print }** ,打印整个记录。

注释以 **#** 字符开始，直到行尾。空行可用于分隔语句。通常，语句以换行符结尾，但是对于以 **,** 、**{** 、**?** 、**:** 、**&&** 或 **||** 结尾的行，并非如此。 以 **do** 或 **else** 结尾的行也会自动续行。 在其他情况下，可以通过以“**\\**”结尾来续行，在这种情况下，换行符将被忽略。 但是，**#** 后面的“**\\**”并不会自动续行。

多个语句可以放在一行中，语句之间用“**;**”分隔。这既适用于模式-动作对（通常情况）的动作部分的语句，也适用于模式-动作语句本身。


## 模式

AWK的模式可以是下列之一：
```awk
BEGIN
END
BEGINFILE
ENDFILE
/regular expression/
relational expression
pattern && pattern
pattern || pattern
pattern ? pattern : pattern
(pattern)
! pattern
pattern1, pattern2
```

**BEGIN** 和 **END** 是两种特殊的模式，它们不针对输入进行测试。 所有 **BEGIN** 模式的动作部分都被合并，就好像所有语句都写在单个 **BEGIN** 规则中一样。 它们在读取任何输入之前执行。 类似地，所有的 **END** 规则都被合并，并在所有输入都用完时（或在执行 **exit** 语句时）执行。 **BEGIN** 和 **END** 模式不能与模式表达式中的其他模式组合。 **BEGIN** 和 **END** 模式不能省略动作部分。

**BEGINFILE** 和 **ENDFILE** 是额外的特殊模式，它们的操作在读取每个命令行输入文件的第一条记录之前和读取每个文件的最后一条记录之后执行。 在 **BEGINFILE** 规则中，如果文件打开成功，**ERRNO** 的值为空字符串。 否则，文件有问题，代码应该使用 **nextfile** 跳过它。 如果不这样做，<u>gawk</u> 通常会为无法打开的文件产生致命错误。

对于 **/**<u>regular expression</u>**/** 模式，为匹配正则表达式的每个输入记录执行关联的语句。 正则表达式与 **egrep**(1) 中的相同，总结[如下](#regexp)。

关系表达式relational expression可以使用下面[关于动作的章节](#action)中定义的任何运算符。 这些通常测试某些字段是否与某些正则表达式匹配。

**&&**、**||** 和 **!** 运算符分别是逻辑与、逻辑或和逻辑非，就像在 C 中一样。它们进行短路测试，也和在 C 中一样，用于组合更原始的模式表达式。 与大多数语言一样，括号可用于更改计算顺序。

**?:** 运算符类似于 C 中的相同运算符。如果第一个模式为真，则用于测试的模式是第二个模式，否则为第三个模式。 仅第二和第三模式之一用于匹配。

表达式<u>pattern1, pattern2</u> 称为范围模式。 它匹配如下所有输入记录：从匹配模式<u>pattern1</u>的记录开始，一直持续到匹配模式 <u>pattern2</u>的记录，包括在匹配<u>pattern2</u>的记录在内。 它不与任何其他类型的模式表达式结合。

## 正则表达式

<span id='regexp'>正则表达式</span>是 **egrep** 中的正则表达式的扩展类型。 它们由以下字符组成：

|正则表达式字符|说明|
|:--|:--|
|c|匹配一个非元字符c|
|\\c| 匹配文字字符 c|
|.|匹配任何字符，包括换行符。|
|^| 匹配字符串的开头。|
|\$| 匹配字符串的结尾。|
|\[abc...\] |字符列表：匹配 abc...字符中的任意一个。您可以通过用破折号分隔字符来包含一格范围的字符。要在列表中包含破折号“-”，请将其放在第一个或最后一个。|
|\[\^abc...\]| 否定字符列表：匹配除abc...之外的任何一个字符。|
|r1\|r2| 二选一：匹配 r1 或 r2。|
|r1r2| 串联：匹配 r1，然后匹配 r2。|
|r+| 匹配一个或多个 r。|
|r\*| 匹配零个或多个 r。|
|r?|匹配零个或一个 r。|
|(r) |分组：匹配 r。|
|r\{n\}，r\{n,\}，r\{n,m\} |大括号内的两个数字表示区间表达式。如果大括号中有一个数字，则前面的正则表达式r重复 n 次。如果有两个数字用逗号分隔，r 重复 n 到 m 次。如果有一个数字后跟逗号，则 r 至少重复 n 次。|
|\\y| 匹配单词开头或结尾的空字符串。|
|\\B|匹配单词中的空字符串。|
|\\<| 匹配单词开头的空字符串。|
|\\>| 匹配单词末尾的空字符串。|
|\\s| 匹配任何空白字符。|
|\\S |匹配任何非空白字符。|
|\\w |匹配任何组成单词的字符（字母、数字或下划线）。|
|\\W |匹配任何不是组成单词的字符。|
|\\\`| 匹配缓冲区开头的空字符串（字符串）。|
|\\\'| 匹配缓冲区末尾的空字符串。|

在字符串常量中有效的转义序列（请参阅[字符串常量](#stringconstant)）在正则表达式中也有效。

字符类是 POSIX 标准中引入的一个特性。 字符类是一种特殊符号，用于描述具有特定属性的字符列表，但实际字符本身可能因国家、地区或字符集而异。 例如，字母字符的概念在美国和法国是不同的。

字符类仅在字符列表括号内的正则表达式中有效。 字符类由 `\[:`、表示类的关键字和 `:\]` 组成。 POSIX 标准定义的字符类是：
|字符|说明|
|:--|:--|
|`[:alnum:]`| 字母和数字字符。|
|`[:alpha:]`| 字母字符。|
|`[:blank:]` |空格或制表符。|
|`[:cntrl:]`|控制字符。|
|`[:digit:]` |数字字符。
|`[:graph:]`| 既可打印又可见的字符。 （空格是可打印的，但不可见，而 a 两者都是。）|
|`[:lower:]` |小写字母字符。|
|`[:print:]`| 可打印字符（不是控制字符的字符。）|
|`[:punct:]`|标点字符（不是字母、数字、控制字符或空白字符的字符）|。
|`[:space:]`| 空白字符（例如空格、制表符和换页符，仅举几例）。|
|`[:upper:]`| 大写字母字符。|
|`[:xdigit:]`|十六进制数字字符。|

例如，在 POSIX 标准之前，要匹配字母和数字字符，您必须写成`/[A-Za-z0-9]/`。 如果您的字符集中有其他字母字符，这将与它们不匹配，并且如果您的字符集与 ASCII 不同，这甚至可能不会匹配 ASCII 字母和数字字符。 使用 POSIX 字符类，您可以写为`/[[:alnum:]]/`，这将匹配你的字符集中的字母和数字字符，无论它是什么。

两个额外的特殊序列可以出现在字符列表中。 这些适用于非 ASCII 字符集，这些字符集可以具有用多个字符表示的单个符号（称为[整理元素](#CollatingSymbols)），以及用于整理或排序目的的多个等价字符。 （例如，在法语中，普通的“e”和带有重音的“\`”是等价的。）

<span id='CollatingSymbols'>**整理符号**</span>

整理符号是包含在 \[. 和 .\] 中的多字符整理元素。 例如，如果 **ch** 是一个整理元素，那么 **\[\[.ch.\]\]** 是一个匹配这个整理元素的正则表达式，而 **\[ch\]** 是一个匹配 c 或 h 的正则表达式。

**等价类**

等价类是等价字符列表的特定于语言环境的名称。 名称包含在 **\[=** 和 **=\]** 中。 例如，名称 e 可能用于表示所有“e”、“´”和“\`”。 在这种情况下，**\[\[=e=\]\]** 是匹配 e、´ 或 \` 中任何一个的正则表达式。

这些功能在非英语语言环境中非常有价值。 <u>gawk</u> 用于正则表达式匹配的库函数目前只能识别 POSIX 字符类； 它们不识别整理符号或等价类。

**\y**、**\B**、**\\<**、**\\>**、**\\s**、**\\**S、**\\w**、**\\**W、**\\`** 和 **\\'** 运算符是 <u>gawk</u> 特有的； 它们是基于 GNU 正则表达式库中的工具的扩展。

各种命令行选项控制 <u>gawk</u> 如何解释正则表达式中的字符。

|选项|说明|
|:--|:--|
|没有选项|在默认情况下，<u>gawk</u> 提供上述 POSIX 正则表达式和 GNU 正则表达式运算符的所有功能。|
|--posix|仅支持 POSIX 正则表达式，GNU 运算符并不特殊。 （例如，\\w 匹配文字 w）。|
|--traditional|传统的 UNIX awk 正则表达式是匹配的。 GNU 运算符并不特殊，并且区间表达式不可用。 八进制和十六进制转义序列描述的字符按字面处理，即使它们表示正则表达式元字符。|
|--traditional|允许在正则表达式中使用区间表达式，即使已提供--traditional选项。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||

## 动作

<span id='action'>动作</span>语句括在大括号 **{** 和 **}** 中。 动作语句由大多数语言中常见的赋值语句、条件语句和循环语句组成。 可用的运算符、控制语句和输入/输出语句是按照 C 中的模式设计的。

## 运算符

AWK 中的运算符按优先级递减的顺序是：
|运算符|说明|
|:--|:--|
|(...) |分组。|
|\$| 字段引用。|
|\+\+、--| 递增和递减，前缀和后缀。|
|^|取幂（也可以使用 `**`，而 `**=` 用于赋值运算符）。
|+、-、！|正数、负数和逻辑非。
|\*、 /、 %| 乘法、除法和求余。|
|+、-| 加法和减法。|
|空格| 字符串连接。|
|\|、\|&| 用于 **getline**、**print** 和 **printf** 的管道 I/O。|
|\<、>、\<=、 >= 、=\=、!=|普通的关系运算符。|
|~ 、!~| 正则表达式匹配，不匹配。注意：不要在 **~** 或 **!~** 的左侧使用常量正则表达式 (**/foo/**)。仅在右侧使用。表达式` /foo/ ~ exp` 与 `(($0 ~ /foo/) ~ exp )` 具有相同的含义。这通常不是您想要的。
|in| 数组成员|
|&&| 逻辑与。|
|\|\||逻辑或|
|?：|C 条件运算符，形式为 `expr1 ？expr 2：expr3`。如果 expr1 为真，则表达式的值为 expr2，否则为 expr3。 expr2 和 expr3 中只有一个是评估。
|=、+=、-=、\*=、/=、%=、^=|赋值。支持绝对赋值（var = value）和运算赋值（其他形式）。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||


## 控制语句

控制语句如下
|控制语句|说明|
|:--|:--|
|if (condition) statement \[ else statement \]|条件语句|
|while (condition) statement|当循环|
|do statement while (condition)|直到循环|
|for (expr1; expr2; expr3) statement|进循环|
|for (var in array) statement|遍历循环|
|break|跳出循环|
|continue|下一次循环|
|delete array\[index]|删除数组元素|
|delete array|删除数组|
|exit \[ expression ]|退出|
|{ statements }|普通语句|
|switch (expression) {<br />&emsp;&emsp;case value\|regex : statement<br />&emsp;&emsp;...<br />&emsp;&emsp;\[ default: statement ]<br />}|开关语句|

## I/O语句
输入/输出语句如下：
|I/O语句|说明|
|:--|:--|
|close(file \[, how])|关闭文件、管道或协程。 <u>how </u>是可选的，应该只在将通向协程的双向管道的一端关闭时使用。 它必须是一个字符串值，可以是“**to**”或“**from**”。|
|getline| 从下一个输入记录设置 **\$0**； 设置 **NF**、**NR**、**FNR**、**RT**。|
|getline \<file| 从文件的下一条记录设置 **\$0**； 设置 **NF**，**RT**。|
|getline var| 从下一个输入记录设置 <u>var</u>； 设置 **NR**、**FNR**、**RT**。|
|getline var \<file | 从文件的下一条记录设置<u>var</u>； 设置 **RT**。|
|command \| getline \[var]|运行命令<u>command</u>，将输出通过管道传输到 **\$0** 或 <u>var</u>（如上所述）和 **RT**。|
|command \|& getline \[var]|将命令<u>command</u>作为协进程运行，将输出用管道传输到 \$0 或 <u>var</u>（如上所述）和 **RT**。 协程是一个<u>gawk</u>扩展。 （命令<u>command</u>也可以是一个套接字。请参阅下面的[特殊文件名](#SpecialFileNames)小节。）|
|next|停止处理当前输入记录。 读取下一个输入记录并使用 AWK 程序中的第一个模式重新开始处理。 到达输入数据的末尾后，执行任何**END** 规则(如果有)。|
|nextfile|停止处理当前输入文件。 读取的下一个输入记录来自下一个输入文件。 更新 **FILENAME** 和 **ARGIND**，将 **FNR** 重置为 1，并使用 AWK 程序中的第一个模式重新开始处理。 到达输入数据的末尾后，执行任何 **ENDFILE** 和 **END** 规则(如果有)。|
|print|打印当前记录。 输出记录以 **ORS** 的值终止。|
|print expr-list|打印表达式。 每个表达式都由 **OFS** 的值分隔。 输出记录以 **ORS** 的值终止。|
|print expr-list \>file|打印表达式到文件<u>file</u>。每个表达式都由 **OFS** 的值分隔。 输出记录以 **ORS** 的值终止。|
|printf fmt, expr-list|格式化打印。请参阅下面的[printf](#printf)语句。|
|printf fmt, expr-list \>file|格式化打印到文件中。请参阅下面的[printf](#printf)语句。|
 |system(cmd-line)|执行命令<u>cmd-line</u>，返回退出状态。 （这在非 POSIX 系统上可能不可用。）有关退出状态的完整详细信息，请参阅《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》。
|fflush(\[file]) |冲刷与打开的输出文件或管道文件<u>file</u>关联的所有缓冲区。 如果没有指定<u>file</u>或为空字符串，则冲刷所有打开的输出文件和管道。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|
**print**和 **printf** 允许额外的输出重定向。
|I/O语句|说明|
|:--|:--|
|print ... \>\> file|将输出添加到文件末尾。
|print ... \| command|将输出写到一个管道中
|print ... \|& command|将数据发送到协进程或套接字。 （另请参阅下面的[特殊文件名](#SpecialFileNames)小节。）|

**getline** 命令在成功时返回 1，在文件末尾返回 0，在错误时返回 -1。 如果 <u>errno</u>(3) 值指示 I/O 操作可以重试，并且设置了 **PROCINFO\["input", "RETRY"\]**，则返回 -2，并且可能会尝试再次调用 **getline** . 发生错误时，**ERRNO** 被设置为描述问题的字符串。

注意：打开双向套接字失败会导致向调用函数返回非致命错误。 如果在循环内使用管道、协进程或套接字 输出到 **getline**，或组读取自 **print** 或 **printf**，则必须使用 **close**() 创建命令或套接字的新实例。 AWK 在返回 **EOF** 时不会自动关闭管道、套接字或协进程。

## printf语句
AWK 版本的 **<span id='printf'>printf</span>** 语句和 **sprintf**() 函数（见下文）的 接受以下转换规范格式：

|转换标识符|说明|
|:--|:--|
|%a, %A|\[-\]**0x**h.hhhh**p**+-dd 形式的浮点数（C99 十六进制浮点格式）。**%A**，使用大写字母代替小写字母。|
|%c| 单个字符。如果用于 %c 的参数是数字，则将其视为字符并打印。否则，假定参数是一个字符串，且只打印该字符串的第一个字符。|
|%d, %i|一个十进制数（整数部分）。|
|%e, %E|\[-]d.dddddd**e**\[+-]dd 形式的浮点数。**%E** 格式使用 **E** 而不是 **e**。
|%f, %F|\[-]ddd.dddddd 形式的浮点数。 如果系统库支持，**%F** 也可以使用。 这类似于 **%f**，但使用大写字母表示特殊的“非数字”和“无穷大”值。 如果 **%F** 不可用，<u>gawk</u> 使用 **%f**。|
|%g, %G|使用 **%e** 或 **%f**来进行转换，以较短者为准，并抑制输出不重要的零。 %G 格式使用 **%E** 而不是 **%e**。
|%o|一个无符号八进制数（也是一个整数）。|
|%u|一个无符号十进制数（同样是一个整数）。|
|%s| 一个字符串。|
|%x, %X|一个无符号的十六进制数（一个整数）。 **%X** 格式使用 **ABCDEF** 而不是 **abcdef**。|
|%%| % 字符|
|&emsp;&emsp;&emsp;&emsp;&emsp;|

可选的修饰符可位于 % 和转换标识符之间：
|修饰符|说明|
|:--|:--|
|count\$|此时在格式中使用第count个参数。称为位置说明符，主要用于格式字符串的翻译版本，而不是 AWK 程序的原始文本。这是一个<u>gawk</u>扩展。|
|- |表达式应在其字段内左对齐。|
|空格|对于数字转换，正数在前面加一个空格，负数在前面加一个减号。|
|+|在宽度修饰符（见下文）之前使用的加号表示始终为数字转换提供一个符号，即使要格式化的数据是正数。 +会覆盖空格修饰符。|
|#|对某些控制字母使用“替代形式”。对于 **%o**，提供前导零。对于 **%x** 和 **%X**，为非零结果提供前导 **0x** 或 **0X**。对于 **%e**、**%E**、**%f** 和 **%F**，结果始终包含小数点。对于 **%g** 和 **%G**，不会从结果中删除尾随零。|
|0|前导 0（零）指示输出应填充零而不是空格。这仅适用于数字输出格式。仅在字段宽度大于要打印的值时有效。|
|'|单引号字符指示 <u>gawk</u> 将语言环境的千位分隔符插入十进制数，并且还将语言环境的小数点字符与浮点格式一起使用。这需要 C 库和当前语言环境定义中的正确语言环境支持。|
|width|字段应被填充到此宽度width，通常用空格填充。对于 0 标志，它用零填充。|
|.prec|一个数字，指定打印时使用的精度。 对于 **%e**、**%E**、**%f** 和 **%F** 格式，这指定要打印到小数点右侧的位数。 对于 **%g** 和 %**G** 格式，它指定最大有效数字位数。 对于 **%d**、**%i**、**%o**、**%u**、**%x** 和 **%X** 格式，它指定要打印的最小位数。 对于 **%s** 格式，它指定字符串可打印的最大字符数。|

支持 ISO C **printf**()函数的动态宽度和精度功能。 `*` 用于代替宽度或精度，导致宽度或精度的值从参数列表中获取。 要使用具有动态宽度或精度的位置说明符，请在格式字符串中的 `*` 之后提供 `count$`。 例如，`"%3\$\*2\$.\*1\$s"`。

## 特殊文件名
<span id='SpecialFileNames'>当</span>重定向**print** 或 **printf** 的输出或**getline**的输入到文件时，<u>gawk</u> 在内部识别某些特殊文件名。 这些文件名允许访问从 <u>gawk</u> 的父进程（通常是 shell）继承的打开的文件描述符。 这些文件名也可以在命令行中用于指定数据文件。 文件名是：
|文件名|说明|
|:--|:--|
|-| 标准输入|
|/dev/stdin|标准输入|
|/dev/stdout |标准输出|
|/dev/stderr |标准错误输出|
|/dev/fd/n |与打开的文件描述符 <u>n</u> 关联的文件。 |

这对于错误消息特别有用。 例如：
```awk
print "You blew it!" > "/dev/stderr"

```
否则，你将不得不使用
```awk
print "You blew it!" | "cat 1>&2"
```

以下特殊文件名可以与协处理运算符 **|&** 一起用于创建 TCP/IP 网络连接：

/inet/tcp/lport/rhost/rport
/inet4/tcp/lport/rhost/rport
/inet6/tcp/lport/rhost/rport

表示本地端口 <u>lport</u> 到远程主机 <u>rhost</u>的远程端口 <u>rport</u> 的TCP/IP 连接的文件。 使用 0 端口让系统选择一个端口。 使用 **/inet4** 强制 IPv4 连接，使用 **/inet6** 强制 IPv6 连接。 **/inet**使用系统默认值（很可能是 IPv4）。 仅可与 **|&** 双向 I/O 运算符一起使用。

/inet/udp/lport/rhost/rport
/inet4/udp/lport/rhost/rport
/inet6/udp/lport/rhost/rport

类似，但使用 UDP/IP 而不是 TCP/IP。

## 数学函数
AWK 具有以下内置输数学函数：
|函数|说明|
|:--|:--|
|atan2(y, x)| 以弧度为单位返回 <u>y</u>/<u>x</u> 的反正切值。|
|cos(expr) |返回 <u>expr</u> 的余弦值，以弧度为单位。|
|exp(expr)| 指数函数。|
|int(expr) |截断为整数。|
|log(expr)| 自然对数函数。|
|rand() |返回一个随机数 <u>N</u>，介于 0 和 1 之间，使得 0 ≤ N < 1。|
|sin(expr) |返回 <u>expr</u> 的正弦值，以弧度为单位。|
|sqrt(expr) |返回 <u>expr</u> 的平方根。|
|srand(\[expr])| 使用 <u>expr</u> 作为随机数生成器的新种子。 如果未提供<u> expr</u>，则使用一天中的时间。 返回随机数生成器的前一个种子。|

## 字符串函数
<u>gawk</u> 具有以下内置字符串函数：
|函数|说明|
|:--|:--|
|asort(s \[, d \[, how\] \])|返回源数组 <u>s</u> 中的元素数量。使用<u>gawk</u>比较值的普通规则对<u>s</u>的内容进行排序，并将排序后<u>s</u>的索引替换为从1开始的连续整数。 如果指定了可选目标数组<u>d</u>，则先将<u>s</u>复制到<u>d</u>中，然后对<u>d</u>进行排序，源数组 <u>s</u> 的索引不变。可选字符串<u>how</u>控制排序方向和比较模式。<u>how</u>的有效值是对 `PROCINFO["sorted_in"]` 有效的任意字符串。它也可以是如 `PROCINFO["sorted_in"]` 中所述的用户定义的比较函数的名字。|
|asorti(s \[, d \[, how\] \])|返回源数组 <u>s</u> 中的元素数量。 行为与 **asort**() 相同，除了数组索引用于排序，而不是数组值。 完成排序后，数组以数字索引，值是原始索引的值。 原始值丢失； 因此，如果您希望保留原始数组，请提供第二个数组<u>d</u>。 可选字符串 how 的用途与前面描述的 **asort**() 相同。|
|gensub(r, s, h \[, t\]) | 在目标字符串 <u>t</u> 中搜索正则表达式 <u>r</u> 的匹配项。如果 <u>h</u> 是以 **g** 或 **G** 开头的字符串，则将 <u>r</u> 的所有匹配项替换为 <u>s</u>。否则，<u>h</u> 是一个数字，指示要替换 <u>r</u> 的哪个匹配项。如果未提供 <u>t</u>，则改用 **\$0**。在替换文本 <u>s</u>中，序列 \\<u>n</u>（其中 <u>n</u> 是从 1 到 9 的数字）可用于指示与第 <u>n</u> 个带括号的子表达式匹配的文本。序列 **\\0** 表示整个匹配的文本，字符 **&** 也是如此。与 **sub**() 和 **gsub**() 不同的是，修改后的字符串作为函数的结果返回，而不改变原始目标字符串。|
|gsub(r, s \[, t\])|对于字符串 <u>t</u> 中与正则表达式 <u>r</u> 匹配的每个子字符串，替换为字符串 <u>s</u>，并返回替换次数。如果未提供 <u>t</u>，则使用 **\$0**。替换文本中的 **&** 被替换为实际匹配的文本。使用 **\\&** 获得文字 **&**。 （这必须输入为“**\\\\&**”；请参阅《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》，以更全面地讨论 **sub**()、**gsub**() 和 **gensub**() 的替换文本中“逻辑与符号和反斜杠”的规则。）|
|index(s, t) |返回字符串 <u>s</u> 中的字符串 <u>t</u> 的索引，如果 <u>t</u> 不存在，则返回零。 （这意味着字符索引从 1 开始。）对 t 使用正则表达式常量是一个致命的错误。    |
| length(\[s\])|返回字符串 <u>s</u> 的长度，如果未提供 <u>s</u>，则返回 **\$0** 的长度。作为非标准扩展，使用数组作为参数，**length**() 返回数组中的元素数量。|
|match(s, r \[, a\])|返回 <u>s</u> 中正则表达式 <u>r</u> 出现的位置，如果 <u>r</u> 不出现则返回零，并设置 **RSTART** 和 **RLENGTH** 的值。请注意，参数顺序与 **~** 运算符相同：<u>str</u> **~** <u>re</u>。如果提供了数组 <u>a</u>，则会清空 <u>a</u>，然后用 <u>s</u> 中与 <u>r</u> 中相应括号内的子表达式匹配的部分填充元素 1 到 <u>n</u>。 <u>a</u> 的第零个元素包含<u>s</u> 与整个正则表达式 <u>r</u> 匹配的部分。下标 **a\[** <u>n</u>**, "start"\]** 和 **a\[** <u>n</u>**, "length"\]** 分别提供每个匹配子字符串在字符串中的起始索引和长度。|
|patsplit(s, a \[, r \[, seps\] \])|在正则表达式<u>r</u>上，将字符串 <u>s</u> 拆分为数组 <u>a</u> 和分隔符数组 <u>sep</u>，并返回字段数。元素值是 <u>s</u> 中与 <u>r</u> 匹配的部分。 **seps**\[<u>i</u>\] 的值是出现在 **a**\[<u>i</u>\] 之后的可能为空的分隔符。 **seps\[0\]** 的值是可能为空的前导分隔符。如果省略 <u>r</u>，则使用 **FPAT**替代。首先清除数组 <u>a</u> 和 <u>sep</u>。拆分字符串的行为与使用 **FPAT** 的字段的拆分效果相同，如上所述。|
|split(s, a \[, r \[, seps\] \])|在正则表达式 <u>r</u>上， 将字符串 <u>s</u> 拆分为数组 <u>a</u> 和的分隔符数组 <u>sep</u>，并返回字段数。如果省略 <u>r</u>，则使用 **FS**替代。首先清空数组 <u>a</u> 和 <u>sep</u>。 **seps**\[<u>i</u>\] 是 **a[**<u>i</u>**]** 和 **a[**<u>i</u>**+1]** 之间与 <u>r</u> 匹配的字段分隔符。如果 <u>r</u> 是单个空格，则 <u>s</u> 中的前导空白符进入额外的数组元素 **sep\[0\]**，尾随的空白符进入额外的数组元素 **seps**\[<u>n</u>\]，其中 <u>n</u> 是 **split**(<u>s</u>, <u>a</u>, <u>r</u> , <u>sep</u>)。拆分的行为与上述的字段拆分相同。特别是，如果 <u>r</u> 是单字符字符串，则该字符串充当分隔符，即使它恰好是正则表达式元字符。
|sprintf(fmt, expr-list)| 根据 <u>fmt</u> 打印 <u>expr-list</u>，并返回结果字符串。|
|strtonum(str)  |检查 <u>str</u>，并返回其数值。 如果 <u>str </u>以前导 0 开头，则将其视为八进制数。 如果 <u>str </u>以前导 **0x** 或 **0X** 开头，则将其视为十六进制数。 否则，假设它是一个十进制数。 |
| sub(r, s \[, t\])|就像 **gsub**() 一样，但只替换第一个匹配的子字符串。 返回0或1。|
|substr(s, i \[, n\])|返回<u>s</u>中从位置 <u>i</u> 开始的最多 <u>n</u> 个字符的子串。 如果省略 <u>n</u>，则返回 <u>s</u> 自<u>i</u>开始的其余部分。|
| tolower(str) |返回字符串 <u>str</u> 的副本，其中 <u>str</u> 中的所有大写字符都转换为相应的小写字母。 非字母字符保持不变。|
| toupper(str)|返回字符串 <u>str</u> 的副本，其中 <u>str</u> 中的所有小写字符都转换为相应的大写字母。 非字母字符保持不变。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||

<u>gawk</u> 可以感知多字节。 这意味着 **index**()、**length**()、**substr**() 和 **match**() 都是根据字符而不是字节来工作的。 

## 时间函数

由于 AWK 程序的主要用途之一是处理包含时间戳信息的日志文件，<u>gawk</u> 提供了以下函数来获取时间戳并对其进行格式化。
|函数|说明|
|:--|:--|
|mktime(datespec \[, utc-flag\])|将 <u>datespec</u> 转换为与 **systime**() 返回的格式相同的时间戳，并返回结果。 <u>datespec</u> 是格式为 <u>YYYY</u> <u>MM</u> <u>DD</u> <u>HH</u> <u>MM</u> <u>SS</u>\[ <u>DST</u>\] 的字符串。字符串的内容是六位或七位数字，分别代表完整的年份，包括世纪、月分（1 ~ 12）、月的天数（1 ~ 31）、小时（0 ~ 23）、分钟（0 ~ 59），秒（0 ~ 60），以及一个可选的夏令时标志。这些数字的值不必在规定的范围内；例如，-1 小时表示午夜前 1 小时。假定为零起点公历，第 0 年在第 1 年之前，第 -1 年在第 0 年之前。如果 <u>utc-flag</u> 存在且非零或非空，则假定时间在 UTC 时区;否则，时间被假定为本地时区。如果 <u>DST</u> 夏令时标志为正，则假定时间为夏令时；如果为零，则假定时间为标准时间；如果为负值（默认值）， **mktime**() 会尝试确定夏令时是否在指定时间生效。如果 <u>datespec</u> 没有包含足够的元素或者结果时间超出范围，则 **mktime**() 返回 -1。|
|strftime(\[format \[, timestamp\[, utc-flag\]\]\])|根据格式<u>format</u>中的规范格式化时间戳<u>timestamp</u>。 如果 <u>utc-flag</u> 存在且非零或非空，则结果采用 UTC，否则结果采用本地时间。 时间戳应与 **systime**() 返回的格式相同。 如果缺少时间戳<u>timestamp</u>，则使用当前时间。 如果缺少格式<u>format</u>，则使用与 **date**(1) 的输出等效的默认格式。 默认格式在 **PROCINFO\["strftime"\]** 中可用。 有关保证可用的格式转换，请参阅 ISO C 中 **strftime**() 函数的规范。
|systime()| 返回当前时间，自纪元以来的秒数（POSIX 系统上的 1970-01-01 00:00:00 UTC）。|
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||


## 位操作函数

<u>gawk</u> 提供以下位操作函数。 它们的工作方式是将双精度浮点值转换为 uintmax_t 整数，执行运算，然后将结果转换回浮点数。

注意：将负的操作数传递给这些函数中的任何一个都会导致致命错误。

这些函数是：
|函数|说明|
|:--|:--|
|and(v1, v2 \[, ...\]) |返回参数列表中提供的值的按位与后的结果。 必须至少有两个参数。|
|compl(val) |返回 <u>val</u> 的按位补码。|
|lshift(val, count) |返回 <u>val</u> 左移<u>count</u>位后的值|
|or(v1, v2 \[, ...\]) |返回参数列表中提供的值的按位或后的结果。 必须至少有两个参数。|
|rshift(val, count)  |返回 <u>val</u> 右移<u>count</u>位后的值|
|xor(v1, v2 \[, ...\])|返回参数列表中提供的值的按位异或后的记过。 必须至少有两个参数。|

## 类型函数
以下函数提供有关其参数的类型相关信息。
|函数|说明|
|:--|:--|
|isarray(x)|如果 <u>x</u> 是一个数组，则返回 true，否则返回 false。 该函数主要用于多维数组的元素和函数参数|
|typeof(x)|返回一个表示 <u>x</u> 类型的字符串。 字符串将是“**array**”、“**number**”、“**regexp**”、“**string**”、“**strnu**m”、“**unassigned**”或“**undefined**”之一。|


## 国际化函数
可以在 AWK 程序中使用以下函数在运行时翻译字符串。 有关完整的详细信息，请参阅 《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》。


|函数|说明|
|:--|:--|
|bindtextdomain(directory \[, domain\])|指定 <u>gawk</u> 查找 **.gmo** 文件的目录，以防它们不会或不能放置在“标准”位置（例如，在测试期间）。它返回<u>domain</u>被“绑定”的目录。<br />默认<u>domain</u>是 **TEXTDOMAIN** 的值。如果目录<u>directory</u>是空字符串 ("")，则 **bindtextdomain**() 返回给定<u>domain</u>的当前绑定。|
|dcgettext(string \[, domain \[, category\]\])|返回语言环境类别<u>category</u>的文本域<u>domain</u>域中的字符串<u>string</u>的翻译。 <u>domain</u> 的默认值是 **TEXTDOMAIN** 的当前值。<u>category</u>的默认值为“**LC_MESSAGES**”。<br />如果您为 <u>category</u> 提供值，则它必须是等于 《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》中描述的已知语言环境类别之一的字符串。您还必须提供文本域。如果您想使用当前域，请使用 **TEXTDOMAIN**。|
|dcngettext(string1, string2, number \[, domain \[, category\]\])|返回用于语言环境类别<u>category</u>的文本域<u>domain</u>中 <u>string1 </u>和 <u>string2</u> 的翻译的数字的复数形式。 <u>domain</u> 的默认值是 **TEXTDOMAIN** 的当前值。 类别<u>category</u>的默认值为“**LC_MESSAGES**”。 <br />如果您为 <u>category</u> 提供值，则它必须是等于《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》中描述的已知语言环境类别之一的字符串。 您还必须提供文本域。 如果您想使用当前域，请使用 **TEXTDOMAIN**。 |
|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||

# 用户定义函数
AWK 中的函数定义如下：
```awk
function name(parameter list) { statements }
```
当函数在模式或动作中的表达式中被调用时，函数就会执行。 函数调用中提供的实际参数用于实例化函数中声明的形式参数。 数组按引用传递，其他变量按值传递。

由于函数最初不是 AWK 语言的一部分，因此对局部变量的规定相当笨拙：它们在参数列表中被声明为额外的参数。 约定通过参数列表中的额外空格将局部变量与实际参数分开。 例如：

``` awk
function  f(p, q,     a, b)   # a 和 b 是本地变量
{
    ...
}

/abc/     { ... ; f(1, 2) ; ... }
```
函数调用中的左括号必须紧跟在函数名之后，中间没有任何空格。 这避免了连接运算符的句法歧义。 此限制不适用于上面列出的内置函数。

函数可以相互调用并且可以递归。 用作局部变量的函数参数在函数调用时被初始化为空字符串和数字零。

使用 **return** <u>expr</u> 从函数返回一个值。 如果没有提供任何值，或者如果函数通过“falling off”结束返回，则返回值是未定义的。

作为 <u>gawk</u> 的扩展，函数可以被间接调用。 为此，请将要调用的函数的名称作为字符串赋值给变量。 然后像使用函数名一样使用该变量，并以 @ 符号为前缀，如下所示：

``` awk
function myfunc()
{
     print "myfunc called"
    ...
}

{
     ...
     the_func = "myfunc"
     @the_func()    # call through the_func to myfunc
     ...
}

```
从版本 4.1.2 开始，这适用于用户定义的函数、内置函数和扩展函数。

如果提供了 **--lint**，<u>gawk</u> 会在解析时而不是在运行时警告对未定义函数的调用。 在运行时调用未定义的函数是一个致命错误。

**func** 这个词可以用来代替 **function**，尽管这已被弃用。
# 动态载入新函数
您可以使用`@load` 语句将用 C 或 C++ 编写的新函数动态添加到正在运行的 <u>gawk</u> 解释器中。 完整的细节超出了本手册页的范围； 请参阅 《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》。
# 信号
<u>gawk</u> 分析器接受两个信号。 **SIGUSR1** 使其将配置文件和函数调用堆栈转储到配置文件，该文件是 **awkprof.out** 或任何使用 **--profile** 选项指定的文件。 然后它继续运行。 **SIGHUP** 导致 <u>gawk</u> 转储配置文件和函数调用堆栈，然后退出。
# 国际化
字符串常量是用双引号括起来的字符序列。在非英语环境中，可以将 AWK 程序中的字符串标记为需要翻译为当地自然语言。此类字符串在 AWK 程序中用前导下划线 (“\_”) 标记。例如，

``` awk
gawk 'BEGIN { print "hello, world" }'
```
始终打印 hello, world. 但是,

``` awk
gawk 'BEGIN { print _"hello, world" }'
```
在法国，可能会打印 bonjour, monde。

生成和运行可本地化的 AWK 程序涉及几个步骤。

1. 添加一个 **BEGIN** 动作来为 **TEXTDOMAIN** 变量赋值，从而将文本域设置为与您的程序关联的名称：

	``` awk
	BEGIN { TEXTDOMAIN = "myprog" }
	```
	
	这允许 <u>gawk</u> 找到与您的程序关联的 **.gmo** 文件。如果没有这一步，<u>gawk</u> 使用**messages**文本域，它可能不包含您程序的翻译。

2. 用前导下划线标记所有应翻译的字符串。

3. 如有必要，请根据需要在您的程序中使用 **dcgettext**() 或 **bindtextdomain**() 函数。

4. 运行 **<u>gawk</u> --gen-pot -f myprog.awk > myprog.pot** 为您的程序生成一个 **.pot** 文件。

5. 提供适当的翻译，并构建和安装相应的 **.gmo** 文件。

《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》中详细描述了国际化功能。 
# POSIX兼容
<u>gawk</u> 的主要目标是兼容 POSIX 标准以及Brian Kernighan awk 的最新版本。为此，<u>gawk</u> 结合了以下用户可见的特性，这些特性在 AWK 书中没有描述，但属于 Brian Kernighan 的 awk 版本，并且属于 POSIX 标准。

这本书指出，当 awk 将参数作为文件打开时，就会发生命令行变量赋值，这是在执行 **BEGIN** 规则之后。但是，在早期的实现中，当这样的赋值出现在任何文件名之前时，赋值将在运行 **BEGIN** 规则之前发生。应用程序开始依赖于这个“特性”。当 awk 更改以匹配其文档时，添加了用于在程序执行之前赋值变量的 **-v** 选项，以适应依赖于旧行为的应用程序。 （此功能得到了贝尔实验室开发人员和 GNU 开发人员的同意。）

在处理参数时，<u>gawk</u> 使用特殊选项“--”来表示参数结束。在兼容模式下，它会警告但忽略未定义的选项。在正常操作中，此类参数会传递给 AWK 程序以供其处理。

AWK 书没有定义 **srand**() 的返回值。 POSIX 标准让它返回它正在使用的种子，以允许跟踪随机数序列。因此 <u>gawk</u> 中的 **srand**() 也返回其当前种子。

其他特性是： 使用多个 **-f** 选项（来自 MKS awk）； **ENVIRON** 数组； **\\a** 和 **\\v** 转义序列（最初在 <u>gawk</u> 中完成并反馈到贝尔实验室版本）； **tolower**() 和 **toupper**() 内置函数（来自贝尔实验室版本）；和 **printf** 中的 ISO C 转换规范（首先在贝尔实验室版本中完成）。
# 历史特性
<u>gawk</u> 支持的历史 AWK 实现的一项特性是：可以调用 **length**() 内置函数，不仅可以不带参数，甚至可以不带括号！ 因此，

``` awk
a = length     # Holy Algol 60, Batman!
```
与下面任何一个相同

``` awk
a = length()
a = length($0)
```
使用此功能是一种糟糕的做法，如果在命令行中指定了 **--lint**，<u>gawk</u> 会发出有关其使用的警告。
# GNU扩展
<u>gawk</u> 对 POSIX awk 的<span id='GNUEXTENSIONS'>扩展</span>太多了。本节对它们进行了描述。可以通过使用 **--traditional** 或 **--posix** 选项调用 <u>gawk</u> 来禁用此处描述的所有扩展。

<u>gawk</u> 的以下特性在 POSIX awk 中不可用。

* 不对通过 **-f** 选项指定的文件执行路径搜索。因此变量**AWKPATH** 并不是特殊变量。
* 无法进行文件包含（<u>gawk</u> 的 **@include** 机制）
* 无法动态添加用C 编写的新函数（<u>gawk</u> 的 **@load** 机制）
* **\\x** 转义序列。
* 在 **？** 和 **:** 之后续行的能力。
* AWK 程序中的八进制和十六进制常量。
* 变量**ARGIND**、**BINMODE**、**ERRNO**、**LINT**、**PREC**、**ROUNDMODE**、**RT** 和 **TEXTDOMAIN** 并不是特殊变量。
* **IGNORECASE** 变量及其副作用不可用。
* **FIELDWIDTHS**变量和固定宽度字段拆分。
* **FPAT** 变量和基于字段值的字段拆分。
* **FUNCTAB**、**SYMTAB** 和 **PROCINFO** 数组不可用。
* 使用 RS 作为正则表达式。
* 无法识别用于 I/O 重定向的特殊文件名。
* 用于创建协进程的 **|&** 运算符。
* **BEGINFILE** 和 **ENDFILE** 特殊模式不可用。
* 使用空字符串作为 **FS** 的值以及 **split**() 的第三个参数来拆分单个字符串。
* **split**() 的可选第四个参数，用来接收分隔符文本。
* **close**() 函数的可选第二个参数。
* **match**() 函数的可选第三个参数。
* 在 **printf** 和 **sprintf**() 中使用位置说明符。
* 将数组传递给**length**() 。
* **and**()、**asort**()、**asorti**()、**bindtextdomain**()、**compl**()、**dcgettext**()、**dcngettext**()、**gensub**()、**lshift**()、**mktime**()、**or**()、**patsplit**()、 **rshift**()、**strftime**()、**strtonum**()、**systime**() 和 **xor**() 函数。
* 可本地化的字符串。
* 非致命I/O。
* 可重试的 I/O。

AWK 书没有定义 **close**() 函数的返回值。 在关闭输出文件或管道时，<u>gawk</u> 的 **close**() 分别从 **fclose**(3) 或 **pclose**(3) 返回值。它在关闭输入管道时返回进程的退出状态。如果指定文件、管道或协进程未通过重定向打开，则返回值为 -1。

当使用 **--traditional** 选项调用 <u>gawk</u> 时，如果 **-F** 选项的 **fs** 参数为“t”，则 **FS** 设置为制表符。请注意，键入 **gawk -F\\t ...** 只会导致 shell 引用“t”，而不会将“\\t”传递给 **-F** 选项。由于这是一个相当丑陋的特殊情况，因此它不是默认行为。如果指定了 **--posix**，也不会发生此行为。要真正获得制表符作为字段分隔符，最好使用单引号： **gawk -F'\\t' ....**。
# 环境变量
环境变量 **AWKPATH** 用于提供 <u>gawk</u> 在查找通过 **-f**、**--file**、**-i** 和 **--include** 选项以及 **@include** 指令 指定的文件时的搜索目录列表。如果初始搜索失败，则在将 **.awk** 附加到文件名后再次搜索路径。

**AWKLIBPATH** 环境变量可用于提供 <u>gawk</u> 在查找通过 **-l** 和 **--load** 选项指定的文件时的搜索目录列表。

**<u>gawk</u>_READ_TIMEOUT** 环境变量可用于指定从终端、管道或双向通信（包括套接字）读取输入的超时（以毫秒为单位）。

对于通过套接字连接到远程主机， **GAWK_SOCK_RETRIES** 控制重试次数， **<u>gawk</u>_MSEC_SLEEP** 控制重试间隔。间隔以毫秒为单位。在不支持 **usleep**(3) 的系统上，该值向上取整为整数秒。

如果 **POSIXLY_CORRECT** 存在于环境中，则 <u>gawk</u> 的行为就像在命令行中指定了 **--posix** 一样。如果指定了 **--lint**，<u>gawk</u> 会发出一条警告消息。

# 退出状态
如果 **exit** 语句与一个值一起使用，则 <u>gawk</u> 会以给定的数值退出。

否则，如果在执行过程中没有问题，<u>gawk</u> 会以 C 常量 **EXIT_SUCCESS** 的值退出。 这通常为0。

如果发生错误，<u>gawk</u> 会以 C 常量 **EXIT_FAILURE** 的值退出。 这通常是1。

如果 <u>gawk</u> 由于致命错误而退出，则退出状态为 2。在非 POSIX 系统上，此值可能会映射到 **EXIT_FAILURE**。

# 版本信息
本手册页说明了 <u>gawk</u>，版本 5.0。
# 作者
UNIX awk 的原始版本是由贝尔实验室的 Alfred Aho、Peter Weinberger 和 Brian Kernighan 设计和实现的。 Brian Kernighan 继续维护和增强它。

自由软件基金会的 Paul Rubin 和 Jay Fenlason 编写了 <u>gawk</u>，以便与在 UNIX 第七版中分发的原始版本的 awk 兼容。John Woods 贡献了许多错误修复。 在 Arnold Robbins 的贡献下，David Trueman 使 <u>gawk</u> 与新版本的 UNIX awk 兼容。 Arnold Robbins 是当前的维护者。

有关 <u>gawk</u> 及其文档的贡献者的完整列表，请参阅 《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》。

有关维护者的最新信息以及当前支持的端口，请参阅 <u>gawk</u> 发行版中的 **README** 文件。

# bugs报告

如果您在 <u>gawk</u> 中发现错误，请发送电子邮件至 **bug-<u>gawk</u>@gnu.org**。请包括您的操作系统及其修订版、<u>gawk</u> 的版本（来自 **<u>gawk</u> --version**）、您用来编译它的 C 编译器，以及尽可能小的测试程序和数据以重现问题。

在发送错误报告之前，请执行以下操作。首先，验证您是否拥有最新版本的 <u>gawk</u>。每个版本都修复了许多错误（通常是细微的错误），如果您的错误已经过时，则问题可能已经解决。其次，请查看将环境变量 **LC_ALL** 设置为 **LC_ALL=C** 是否会导致事情按照您的预期运行。如果是这样，那就是语言环境问题，可能是也可能不是真正的错误。最后，请仔细阅读此手册页和参考手册，以确保您认为的错误确实存在，而不仅仅是语言中的怪癖。

无论您做什么，都不要在 **comp.lang.awk** 中发布错误报告。虽然 <u>gawk</u> 开发人员偶尔会阅读这个新闻组，但发布错误报告是一种不可靠的错误报告方式。同样，不要使用网络论坛（例如 Stack Overflow）来报告错误。相反，请使用上面给出的电子邮件地址。

如果您使用的是基于 GNU/Linux 或 BSD 的系统，您可能希望向您的发行版的供应商提交错误报告。没关系，但也请向官方电子邮件地址发送一份副本，因为无法保证将错误报告转发给 <u>gawk</u> 维护者。

# bugs
 命令行变量赋值功能中，**-F** 选项不是必需的；它只是为了向后兼容。
# 另见
 **egrep**(1), **sed**(1), **getpid**(2), **getppid**(2), **getpgrp**(2), **getuid**(2), **geteuid**(2), **getgid**(2), **getegid**(2), **getgroups**(2), **printf**(3)、**strftime**(3)、**usleep**(3)。

《AWK编程语言》，Alfred V. Aho、Brian W. Kernighan、Peter J. Weinberger，Addison-Wesley，1988. ISBN 0-201-07981-X。

《[Gawk:高效AWK编程](https://www.gnu.org/software/gawk/manual)》，5.0 版，随 <u>gawk</u> 源码一起提供。文档的当前版本可在 <https://www.gnu.org/software/gawk/manual> 在线获得。

GNU **gettext** <span id="gnu_gettext">文档</span>，可在 <https://www.gnu.org/software/gettext> 在线获得。
# 示例
打印并排序所有用户的登录名：

``` awk
BEGIN     { FS = ":" }
    { print $1 | "sort" }
```
计算文件中的行数：

``` awk
{ nlines++ }
END  { print nlines }
```
在文件中的每一行前面加上它的编号

``` awk
{ print FNR, $0 }
```
连接和行号（主题的变体）：

``` awk
{ print NR, $0 }
```
为特定的数据行运行外部命令：

``` awk
tail -f access_log |
awk '/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }'
```

# 致谢
Brian Kernighan 在测试和调试期间提供了宝贵的帮助。 我们感谢他。
# 版权
版权所有 © 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005, 2005, 201, 106, 201, 106, 201, 106, 2007, 105, 2007, 105, 2007, 201, 1007, 2007, 1007 2017、2018、2019 年，自由软件基金会，Inc。

如果版权声明和此许可声明保留在所有副本上，则允许制作和分发本手册页的逐字副本。

允许在逐字复制的条件下复制和分发本手册页的修改版本，前提是整个衍生作品是根据与此相同的许可通知条款分发的。

在上述修改版本的条件下，允许将本手册页的翻译版本复制和分发为另一种语言，除非该许可声明在基金会批准的翻译中声明。

------

***<font color=blue>版权声明：</font>本文翻译自<font color=blue>《gawk manpages》。</font>gawk的版本为5.1.0，手册更新时间为2020-03-23。<font color=red>本文与原文档采用相同的版权许可。</font><font color=blue>转载请注明出处！！！</font>***

------
