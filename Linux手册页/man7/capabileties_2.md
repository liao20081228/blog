---
title: capabileties_2 
tags: 新建,模板,小书匠
category: /小书匠/日记/2025-02
grammar_cjkRuby: true
---

# 过去和当前的实现情况

能力的完整实现要求：

- 对于所有的特权操作，内核必须检查线程在其有效集中是否具有所需的能力。
- 内核必须提供允许更改和获取线程能力的系统调用。
- 文件系统必须支持将能力添加到可执行文件，以便进程在执行文件时获得这些能力。

在Linux 2.6.24之前，只满足这些要求中的前两个；从Linux 2.6.24开始，满足所有三个要求。

# 内核开发者须知
在添加新的内核功能时，应考虑以下几点。
 - 能力的目标是将超级用户的权力分成若干块，这样，如果具有一个或多个能力的程序被破坏，它对系统造成破坏的权力将小于以root特权运行的同一程序。
 - 您可以选择为您的新特性创建新能力，或将该特性与现有能力之一关联。为了将能力集保持在可管理的大小，后一种选择是更可取的，除非有令人信服的理由采取前一种选择。（还有一个技术限制：能力集的大小目前被限制在64位。）
 - 要确定哪种现有能力可能最适合与您的新特性相关联，请查看上面的能力列表，以便找到您的新特性最适合的“能力项”。采取的一种方法是确定是否有其他特性要求与新功能一起使用的能力。如果没有这些其他特性，新特性就没用了，则你应该使用与其他特性相同的能力。
 - 如果可以避免，不要选择CAP_SYS_ADMIN! 很大一部分现有的能力检查都与此能力相关联（请参阅上面的部分列表）。它可以被合理地称为“新root”，因为一方面，它赋予了广泛的权力，另一方面，它的广泛范围意味着这是许多特权程序所需要的能力。不要让问题变得更糟。唯一应与CAP_SYS_ADMIN关联的新功能是与该能力中的现有用途非常匹配的功能。
 - 如果您确定确实有必要为您的特性创建新能力，请不要将其命名为“一次使用”能力。因此，例如，添加高度具体的CAP_SYS_PACCT可能是一个错误。相反，尝试将您的新能力标识并命名为更广泛的能力项，其他相关的未来用例可能会融入其中。

# 线程能力集
每个线程具有以下包含零个或多个上述能力的能力集：

## Permitted
这是线程可能承担的effective能力的限制超集。它也是可由在其effective集中不具有CAP_SETPCAP能力的线程添加到inheritable集中的能力的限制超集。

如果一个线程从其permitted集合中删除了一个能力，那么它永远不能重新获得该能力（除非它execve(2）一个set-user-ID-root程序，或者一个关联文件能力授予了该能力的程序)。
## Inheritable
这是通过execve(2)中保留的一组能力。在执行任何程序时Inheritable能力仍然是可继承的，并且当执行一个在文件Inheritable集中设置了相应bit位的程序时，Inheritable集中的能力将被添加到Permitted集中。

由于在以非root用户身份运行时，通常不会execve(2)保留可继承的能力，因此希望运行具有提升功能的助手程序的应用程序应考虑使用环境功能，如下所述。

## Effective
这是内核用来对线程执行权限检查的能力集。

## Bounding

能力Bounding集是一种机制，可用于限制在execve(2)期间获得的能力。

从Linux 2.6.25开始每线程都有此能力集。在较旧的内核中，能力Bounding集是系统范围的属性，由系统上的所有线程共享。

有关更多详细信息，请参阅下面的能力Bounding集。

## Ambient
从Linux 4.3开始每线程都有此能力集。

这是一组在非特权程序execve(2)保留的功能。环境能力集遵循不变式，即如果不能同时被允许和继承，则任何能力都不能是环境能力。

通过fork(2)创建的子进程继承其父的能力集的副本。有关execve(2)如何影响能力的详细信息，请参阅 下面的execve()期间的能力转换。

使用capset(2)，线程可以操作自己的能力集；请参阅下面的以编程方式调整能力集

从Linux 3.2开始，文件/proc/sys/kernel/cap_last_cap公开了运行内核支持的最高能力的数值；这可以用来确定能力集中可能设置的最高位。

# 文件能力
