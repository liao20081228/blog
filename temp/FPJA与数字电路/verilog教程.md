---
title: verilog教程
tags: FPJA
---

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文参考了<font color=blue>[《FPGA编程语言——verilog语法》](http://baijiahao.baidu.com/s?id=1593288042605257892&wfr=spider&for=pc "点击跳转")、[《Verilog学习笔记基本语法篇》](https://www.cnblogs.com/SYoong/p/5849168.html)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------

<style>table{word-break:initial;}</style>





# 1 Verilog HDL简介


&emsp;&emsp;Verilog HDL是一种用于数字系统设计的语言。用**Verilog HDL描述的电路设计就是该电路的Verilog HDL模型也称为模块**。Verilog HDL既是一种行为描述的语言也是一种结构描述的语言。这也就是说，无论描述电路功能行为的模块或描述元器件或较大部件互连的模块都可以用Verilog语言来建立电路模型。如果按照一定的规矩编写，功能行为模块可以通过工具自动地转换为门级互连模块。Verilog模型可以是实际电路的不同级别的抽象。这些抽象的级别和它们对应的模型类型共有以下五种：

* 系统级(system)——用语言提供的高级结构实现设计模块外部性能的模型。
* 算法级(algorithm)——用语言提供的高级结构实现算法运行的模型。
* RTL级(Register Transfer Level)——描述数据在寄存器之间流动和如何处理和控制这些数据流动的模型。
* 门级(gate-level)——描述逻辑门以及逻辑门之间的连接的模型。
* 开关级(switch-level)——描述器件中三极管和储存节点以及它们之间连接的模型。

# 2 Verilog HDL模块
&emsp;&emsp;一个复杂电路系统的**完整Verilog HDL模型是由若干个Verilog HDL模块构成的，每一个模块又可以由若干个子模块构成**。其中有些模块需要综合成具体电路，而有些模块只是与用户所设计的模块有交互联系的现存电路或激励信号源。利用Verilog HDL语言结构所提供的这种功能就可以构造一个模块间的清晰层次结构来描述极其复杂的大型设计，并对所作设计的逻辑电路进行严格的验证。

&emsp;&emsp;Verilog HDL行为描述语言作为一种**结构化和过程性**的语言，其语法结构非常适合于算法级和RTL级的模型设计。这种行为描述语言具有以下功能：

* 可描述**顺序执行或并行执行**的程序结构。
* 用延迟表达式或事件表达式来明确地控制过程的启动时间。
* 通过命名的事件来触发其它过程里的激活行为或停止行为。
* 提供了条件、if-else、case、循环程序结构。
* 提供了可带参数且非零延续时间的任务(task)程序结构。
* 提供了可定义新的操作符的函数结构(function)。
* 提供了用于建立表达式的算术运算符、逻辑运算符、位运算符。


&emsp;&emsp;Verilog HDL作为一种高级的硬件描述编程语言，与C语言的风格有许多类似之处。其中有许多语句如：if语句、case语句等和C语言中的对应语句十分相似。如果读者已经掌握C语言编程的基础，那么学习Verilog HDL并不困难。我们只要对Verilog HDL某些语句的特殊方面着重理解，并加强上机练习就能很好地掌握它，就能利用它的强大功能来设计复杂的数字逻辑电路系统。


### 2.1 Verilog语法简介


&emsp;&emsp;下面先介绍一个个简单的Verilog HDL程序，从中了解Verilog模块的特性。

```verilog
//模块定义
module test_project_top   //模块名

//端口定义
( 
	input clk,           //时钟输入
	input resetn,        //复位
	input [7:0] a,        //信号输入，信号a 位宽为8 bit
	input [7:0] b,        //信号输入，信号b 位宽为8 bit
	input en,            //信号是能输入 信号en 位宽为1 bit
	output reg [8:0] c,  //寄存器类型定义,信号输出 c为9bit
	output reg [15:0] d  //寄存器类型定义，信号输出 d 为16bit
);

//......... 或 /*........*/表示注释部分

/*
 *一个 .v文件中主要由 一个或多个 module ... endmodule块组成
 * 每个module块内包括：模块名，输入端口，输出端口，以及多个时序电路，组合电路等组成
 */

//功能定义-简单的时序电路组成
always@(posedge clk or negedge resetn)
begin
    if(~resetn)              //或者 if(!resetn) 取 resetn 反
    begin
		 d <= 16'h0;
	end
	else
	begin
		if(en)               //如果en ==1 那么 d等于a*b+a/b;否则d<=0
			d <= a*b+a/b;      // + ， - ，* ，/ 加减乘除
		else
			d <= 0;
	end
end

//功能定义-简单的组合电路
always@(a or b)              //只要其中a或b一个变化就执行always块内语句
begin
    if(en)                   // verilog语法 if ... else...,在组合电路中一个if对应一个else，不能缺else，防止产生锁存器
	    c <= a*b+a/b;
	else
		c<=0;
end

//内部变量申明
wire [8:0] sum;              //常见变量定义类型：wire-线网型，reg-寄存器
assign sum = a+b;            // 组合电路赋值，关键字 assign
wire [15:0] multy;
assign multy = (en ) ? a*b :0;  // 如果en ==1,那么multy =a*b,否则multy =0;
wire e;
assign e =& a;             // &按位与
wire f;
assign f =| b;             // | 按位或
wire [8:0] c_sum;



//功能定义-实例化模块
my_add u_add_top( // my_add 模块名 ，u_add_top 实例化名
	.clk(clk), //端口连接输入
	.resetn(resetn),//端口连接输入
	.a(a),//端口连接输入
	.b(b),//端口连接输入
	.c(c_sum)//端口连接输出

);

endmodule
```

&emsp;&emsp;这个小程序表述了一个.v文件包含了常用的verilog语法，变量的定义类型包括：wire，reg等，常见的运算符号跟C语言中相同，理解较容易。在这个例子中存在着两个模块。模块`test_project_top`引用由模块`my_add`定义的实例部件`u_add_top`。模块`test_project_top`是顶层模块。模块`my_add`则被称为子模块。在实例部件`u_add_top`中,带 “.”的表示被引用模块的端口,名称必须与被引用模块`my_add`的端口定义一致,小括号中表示在本模块中与之连接的线路。


### 2.2 Verilog用于仿真


&emsp;&emsp;Verilog还可以用来描述变化的测试信号。描述测试信号的变化和测试过程的模块也叫做**测试平台**（Testbench 或Testfixture）,它可以对上面介绍的电路模块（无论是行为的或结构的）进行动态的全面测试。通过观测被测试模块的输出信号是否符合要求，可以调试和验证逻辑系统的设计和结构正确与否，发现问题及时修改。下面我们来看一个Verilog的测试模块，

```cpp
//测试激励产生
`timescale 1ns / 1ps

module test_project_top;   //测试文件模块名

//信号测试激励，输入变量声明
reg clk ;
reg reset;
reg [7:0] a;
reg [7:0] b;
reg en;

// 输出变量声明
wire [8:0] c;
wire [15:0] d;


//信号变量初始化 ，关键字 initial
initial
begin
    clk =0;
    reset =0;
    a =0;
    b =0;
    en =0;
    #1000; // 在1000 ns后 reset拉高
    reset =1;
end


//时钟生成
always #5 clk =~clk; //时钟周期 10ns ，每隔5ns 取反一次


always @(posedge clk)
begin                      //{$random} 为系统任务，它会产生一个随机数
    #1 a= {$random}%256;   // 产生随机的位信号流a和b ，%256为做模256运算
    #3 b = {$random}%256;  // 分别延迟1和3个时间单位后产生随机的位信号流a和b
end

always #10000 en = !en;    //产生周期为10000个单位时间的选通信号变化



//实例化 被测试模块
test_project_top u_top
(
    .clk(clk), // 时钟输入
    .resetn(reset), // 复位
    .a(a), //信号输入，信号a 位宽为8 bit
    .b(b), //信号输入，信号b 位宽为8 bit
    .en(en), // 信号是能输入 信号en 位宽为1 bit
    .c(c), // 寄存器类型定义,信号输出 c为9bit
    .d(d) // 寄存器类型定义，信号输出 d 为16bit
);

endmodule
```


&emsp;&emsp;本测试例程是对2.1.1中的小程序的测试，属于RTL级功能仿真，主要调试语法及时序信号是否跟设计时一致。对于初学者来说，这是最基本的技能，必须熟练掌握。




### 2.3 总结

通过上面这些的例子可以看到以下几点：

* Verilog HDL程序是由模块构成的。每个模块的内容都是位于module和endmodule两个语句之间，每个模块实现特定的功能。
* 模块是可以进行层次嵌套的。正因为如此,才可以将大型的数字电路设计分割成不同的小模块来实现特定的功能。
* 每个模块都是可以综合(synthesis)的，通过综合工具可以把它们的功能描述全都转换为最基本的逻辑单元描述，最后可以用一个上层模块通过实例引用把这些模块连接起来，把它们整合成一个很大的逻辑系统。
* Verilog 模块可以分为两种类型：**一种是为了让模块最终能生成电路结构（用于综综合、布线、生成），另一种只是为了测试所设计的电路其逻辑功能是否正确（用于仿真）**。
* 每个模块要进行端口定义,并说明输入输出口,然后对模块的功能进行描述。
* Verilog HDL程序的书写格式自由,一行可以写几个语句,一个语句也可以分写多行。
* 除了endmodule语句外,每个语句和数据定义的最后必须有分号。
* 可以用/*.....*/和//.......对Verilog HDL程序的任何部分作注释。一个好的,有使用价值的源程序都应当加上必要的注释,以增强程序的可读性和可维护性。



# 3 verilog语法进阶
## 3.1 模块的结构

&emsp;&emsp;Verilog的基本设计单元是“模块”(block)。一个模块是由两部分组成的，一部分描述接口，另一部分描述逻辑功能，即定义输入是如何影响输出的。下面举例说明：

![1](https://www.github.com/liao20081228/blog/raw/master/图片/verilog教程/1.JPG)


&emsp;&emsp;请看上面的例子: 程序模块旁边有一个电路图的符号。**在许多方面，程序模块和电路图符号是一致的，这是因为电路图符号的引脚也就是程序模块的接口**。而程序模块描述了电路图符号所实现的逻辑功能。以上就是设计一个简单的Verilog程序模块所需的全部内容。从上面的例子可以看出，Verilog结构位于在module和endmodule声明语句之间，**每个Verilog程序包括四个主要部分：端口定义、I/O说明、内部信号声明、功能定义**。

### 3.1.1 端口定义


&emsp;&emsp;模块的端口声明了模块的输入输出口。其格式如下：
```verilog
module 模块名(端口1，端口2，端口3，端口4, ......);
... ...
... ...
endmodule
```
&emsp;&emsp;模块的端口表示的是模块的输入和输出口名，也就是它与别的模块联系端口的标识。在模块被引用时，在引用的模块中，有些信号要输入到被引用的模块中，有的信号需要从被引用的模块中取出来。在引用模块时其端口可以用两种方法连接：

* 在引用时，严格按照模块定义的端口顺序来连接，不用标明原模块定义时规定的端口名,格式如下:
&emsp;&emsp;`模块名 实例化名（连接端口1信号名,连接端口2信号名,连接端口3信号名,…）;`


* 在引用时用“.”标明原模块定义时规定的端口名,格式如下:
&emsp;&emsp;`模块名 实例化名（.端口1名( 连接信号1名),.端口2名( 连接信号2名),…）;`
这样表示的好处在于可以用端口名与被引用模块的端口对应，不必严格按端口顺序对应，提高了程序的可读性和可移植性。

> 注：可以在端口定义时同时进行IO说明和内部型号说明
### 3.1.2 I/O说明
* 格式如下：
```verilog
input [信号位宽-n：0] 端口名;     //输入端口
output [信号位宽-n ：0] 端口名;    //输出端口
inout  [信号位宽-n ：0] 端口名;     //输入输出口
```

* I/O说明也可以写在端口声明语句里。其格式如下：
```verilog
module module_name(input port1,output port1,inout port2… );
```

### 3.1.3 内部信号说明

&emsp;&emsp;在模块内用到的和与端口有关的变量的声明。如：
```verilog
reg [width-n : 0] R变量1，R变量2 。。。。；//声明变量为寄存器型
wire [width-n : 0] W变量1，W变量2 。。。。；//声明变量为线网型
```

### 3.1.4 功能定义

* 模块中最重要的部分是逻辑功能定义部分。有三种方法可在模块中产生逻辑：
	* 用“assign”声明语句，如： `assign a = b & c;`
	* 实例化模块，如： `and u1( q, a, b );`
	* 用“always”块，如：
```verilog
always @(posedge clk or posedge clr)
begin
    if(clr) 
        q <= 0;
    else  if(en) 
        q <= d;
end
```

&emsp;&emsp;采用**assign语句是描述组合逻辑**最常用的方法之一。而**always块既可用于描述组合逻辑也可描述时序逻辑**。上面的例子用“always”块生成了一个带有异步清除端的D触发器。“always”块可用很多种描述手段来表达逻辑，例如上例中就用了if...else语句来表达逻辑关系。如按一定的风格来编写“always”块，可以通过综合工具把源代码自动综合成用门级结构表示的组合或时序逻辑电路。

>**补充**：组合逻辑与时序逻辑
>
>* 组合逻辑
>   * 组合逻辑概念：组合逻辑电路在逻辑功能上的特点是**任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关，不涉及对信号跳变沿的处理，无存储电路，也没有反馈电路**。通常可以通过真值表的形式表达出来。
>   * 组合逻辑的Verilog RTL级描述：第一种是always模块的触发事件为电平敏感信号列表；第二种就是用assign 关键字描述的数据流赋值语句。
 >     * always 模块的敏感表为电平敏感信号的电路
 >      always模块的敏感列表为所有判断条件信号和输入信号，但一定要注意敏感列表的完整性。在always 模块中可以使用if、case 和for 等各种RTL 关键字结构。由于赋值语句有阻塞赋值和非阻塞赋值两类，**建议使用阻塞赋值语句“=”。always 模块中的信号必须定义为reg 型**，不过最终的实现结果中并没有寄存器。这是由于在组合逻辑电路描述中，将信号定义为reg 型，只是为了满足语法要求。
>      * assign语句描述的电路
>     利用条件符“?”可以描述一些相对简单的组合逻辑电路，**信号只能被定义为wire型**。当组合逻辑比较复杂时，需要很多条assign语句或者多重嵌套“?”，使得代码可读性极差，因此此时推荐第一种组合逻辑建模方式。
>      * 组合逻辑电路的注意事项
>          * 敏感信号列表
>        在组合逻辑设计中，读者必须重点对待敏感信号列表。敏感信号列表出现在always块中，其典型行为级的含义为：**只要敏感信号列表内的信号发生电平变化，则always模块中的语句就执行一次**，因此设计人员必须将所有的输入信号和条件判断信号都列在信号列表中。
>         不完整的信号列表会造成不同的仿真和综合结果，因此需要保证敏感信号的完备性。如果缺少信号，则无法触发和该信号相关的仿真进程，也就得不到正确的仿真结果。如果设计人员在设计中，认为列举信号麻烦，则采用下面的语句:`always@(*)`。此时，综合工具和仿真工具会自动将所有的敏感信号自动加入敏感信号列表。
>           * 不要在组合逻辑中引入环路
>         在组合逻辑中引入环路会导致电路产生振荡、毛刺以及冲突等问题，从而降低设计的稳定性和可靠性，因此要彻底避免环路。之所以称逻辑环路是一种高风险设计，其原因如下：
>              * 首先，环回逻辑的延时完全依靠组合逻辑门延迟和布线延迟。一旦这些传播时延有所变化，则环路的整体逻辑将彻底失效。
>              * 其次，环路的时序分析是个死循环过程。目前的EDA 开发工具为了计算环路的时序逻辑都会主动割断时序路径，引入许多不确定的因素。
>* 时序逻辑
>   * 时序逻辑的概念：时序逻辑是Verilog HDL设计中另一类重要应用。从电路特征上看来，其特点为**任意时刻的输出不仅取决于该时刻的输入，而且还和电路原来的状态有关,电路里面有存储元件（各类触发器，在FPGA 芯片结构中只有D 触发器）用于记忆信息。从电路行为上讲，不管输入如何变化，仅当时钟的沿（上升沿或下降沿）到达时，才有可能使输出发生变化**。
>   * 在描述时序电路的always块中的reg型信号都会被综合（synthesis）成寄存器，这是和组合逻辑电路所不同的。
>   * 时序逻辑中**推荐使用非阻塞赋值“<=”**。
>   * 时序逻辑的敏感信号列表只需要加入所用的时钟触发沿即可，其余所有的输入和条件判断信号都不用加入，这是因为时序逻辑是通过时钟信号的跳变沿来控制的。
>* 总结
>   * 组合逻辑只跟当前的状态有关系，例如一根导线 + 逻辑门的组合，输出取决于当前时刻的输入，考虑门延时的话另说。
>   * 时序逻辑的状态跟之前状态、边沿信号有关，边沿信号没来之前，输出保持之前的输入；边沿信号来时，输出状态跟随输入信号变化。
>   * 组合逻辑：always@（敏感信号）或者always@（*）或assign语句，组合逻辑相当于组合电路，与或非门组成的电路，其输出至于当前状态有关，与其他输入状态的函数无关，不涉及信号调变处理（组合逻辑竞争冒险：只要输入信号同时变化，组合逻辑必然产生毛刺）。
>   * 时序逻辑：always@（时钟边沿）是时序电路，输出不仅与当前状态有关，在时钟跳变时才变化，如D触发器**。

>**补充：竞争与冒险**
>
>* 竞争与冒险概念
信号在组合逻辑电路内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。此外，信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，**多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化，往往会出现一些不正确的尖峰信号，这些尖峰信号称为“毛刺”，如果一个组合逻辑电路中有“毛刺”出现，就说明该电路存在“冒险”**。需要注意的是，冒险信号的脉冲宽度很小，常常只有数纳秒或数十纳秒，其频带带宽可达数百兆赫兹或更宽。在板级调试时，如果示波器的上限频率较低，会将幅度较大的毛刺显示为幅度较小的毛刺，甚至不易被察觉。这都是在实际开发中捕获毛刺应该注意的问题。
>* 冒险按产生形式的不同可以分为**静态冒险和动态冒险**两大类。
>   * **静态冒险**是指输入有变化，而输出不应变化时产生的单个窄脉冲；
>   * **动态冒险**则指的是输入变化时，输出也应变化时产生的冒险。
>   * **动态冒险是由静态冒险引起的**，因此存在动态冒险的电路也存在静态冒险。
>* 静态冒险根据产生条件的不同，分为功能冒险和逻辑冒险两大类。
>   * 当有两个或两个以上输入信号同时产生变化时，在输出端产生毛刺，这种冒险称为**功能冒险**。
>   * 如果只有一个变量产生变化时出现的冒险则是**逻辑冒险**。
>   * 冒险往往会影响到逻辑电路的稳定性。清零和置位端口对毛刺信号十分敏感，任何一点毛刺都可能会使系统出错，因此判断逻辑电路中是否存在冒险以及如何避免冒险是设计人员必须要考虑的问题。
>* 冒险产生的原因
由于动态冒险主要是由静态冒险引起的，消除了静态冒险，动态冒险也就自然消除了，因此下面介绍静态冒险的检查和消除。判断一个逻辑电路在某些输入信号发生变化时是否会产生冒险，首先要判断信号是否会同时变化，然后判断在信号同时变化的时候，是否会产生冒险，这可以通过逻辑函数的卡诺图或逻辑函数表达式来进行判断。
>   * 功能冒险的检查
功能冒险是由电路的逻辑功能引起的，只要输入信号不是按照循环码的规律变化，组合逻辑就可能产生功能冒险，且不能通过修改设计加以消除，只能通过对输出采用时钟采样来消除。
>   * 逻辑冒险的检查
检查电路是否产生逻辑冒险的方法有两种，即代数法和卡诺图法。
>      * 代数法。如果一个组合逻辑函数表达式F，在某些条件下能化简成或的形式，在A产生变化时，就可能产生静态逻辑冒险。
>      * 卡诺图法。在组合逻辑的卡诺图中，若存在素项圈相切，则可能会产生逻辑冒险。
### 3.1.5 理解要点

&emsp;&emsp;如果用Verilog模块实现一定的功能，**首先应该清楚哪些是同时发生的,哪些是顺序发生的**。上面分别采用了“assign”语句、实例元件和“always”块，描述的逻辑功能是同时执行的。也就是说，如果把这三项写到一个 VeriIog 模块文件中去，它们的次序不会影响逻辑实现的功能。这三项是同时执行的，也就是并发的。


&emsp;&emsp;然而，在“always”模块内，逻辑是按照指定的顺序执行的。“always”块中的语句称为“顺序语句”，因为它们是顺序执行，所以“always”块也称作“过程块”。请注意，**两个或更多的“always”语句块，它们是同时执行的，而模块内部的语句是顺序执行的**。 看一下“always”块内的语句，你就会明白它是如何实现功能的。 if..else… if必须顺序执行，否则其功能就没有任何意义。如果else语句在if语句之前执行，其功能就会不符合要求！为了能实现上述描述的功能，“always”语句块内部的语句将按照书写的顺序执行。

&emsp;&emsp;在Verilog 模块中所有**过程块（initial块、always块）、连续赋值语句assign、实例引用都是并行的**。它们表示的是一种通过变量名互相连接的关系。在同一模块中这三者出现的先后次序没有关系。**只有连续赋值语句assign 和实例引用语句可以独立于过程块而存在于模块的功能定义部分**。以上是与C语言有很大的不同。许多与C语言类似的语句只能出现在过程块中，而不能随意出现在模块功能定义的范围内。


## 3.2 数据类型及其常量、变量


&emsp;&emsp;Verilog HDL中总共有十九种数据类型,数据类型是用来表示数字电路硬件中的数据储存和传送元素的。先只介绍四个最基本的数据类型,它们是：reg型、wire型、integer型、parameter型。

&emsp;&emsp;其它数据类型也有很多：large型、medium型、scalared型、time型、small型、tri型、trio型、tri1型、triand型、trior型、trireg型、vectored型、wand型、wor型。


### 3.2.1 常量

&emsp;&emsp;在程序运行过程中,其值不能被改变的量称为常量。下面首先对在Verilog HDL语言中使用的数字及其表示方式进行介绍。

* 数字表达式分为三种
   * `<位宽>'<进制><数字>`，这是最完整的形式。
   * `<进制><数字>`，数字的位宽采用默认位宽（不同的机器系统不同，至少32位）。
   * `<数字>`，采用默认进制（十进制）。

*  整数：在Verilog HDL中,整型常量即整常数有以下四种进制表示形式:
	 * 二进制整数(b或B)
	 * 十进制整数(d或D)
	 * 十六进制整数(h或H)
	 * 八进制整数(o或O)
* x和z值：在数字电路中,x代表不定值，z代表高阻值。
	 * 一个x可以用来定义十六进制数的四位二进制数的状态,八进制数的三位,二进制数的一位。
	 * z的表示方式同x类似。z还有一种表达方式是可以写作?。在使用case表达式时建议使用这种写法,以提高程序的可读性。见下例:
```verilog
4'b10x0 //位宽为4的二进制数从低位数起第二位为不定值
4'b101z //位宽为4的二进制数从低位数起第一位为高阻值
12'dz   //位宽为12的十进制数其值为高阻值(第一种表达方式)
12'd?   //位宽为12的十进制数其值为高阻值(第二种表达方式)
8'h4x   //位宽为8的十六进制数其低四位值为不定值
```

* 负数：一个数字可以被定义为负数,只需在位宽表达式前加一个减号,减号必须写在数字定义表达式的最前面。注意减号不可以放在位宽和进制之间也不可以放在进制和具体的数之间。如下：
```verilog
-8'd5 //这个表达式代表5的补数（用八位二进制数表示)
8'd-5 //非法格式
```
* 下划线：用于区别开数字的表达式以提高程序的可读性。不能用在位宽和进制的地方，只能用在数字之间（数字前也不可以）。
```verilog
16'b1010_1011_1111_1010    //合法形式
```

### 3.2.2 参数(Parameter)型

* 在Verilog HDL中**用parameter来定义常量**,即用parameter来定义一个标识符代表一个常量,称为符号常量,即标识符形式的常量,采用标识符代表一个常量可提高程序的可读性和可维护性。parameter型数据是一种常数型的数据，其说明格式如下：
```verilog
parameter 参数名1＝表达式，参数名2＝表达式, …，参数名n＝表达式;
```

* parameter是参数型数据的确认符，确认符后跟着一个用逗号分隔开的赋值语句表。在每一个赋值语句的右边必须是一个常数表达式。也就是说，**该表达式只能包含数字或先前已定义过的参数**。见下例：
```verilog
parameter msb=7;                              //定义参数msb为常量7
parameter e=25, f=29;                          //定义二个常数参数
parameter r=5.7;                               //声明r为一个实型参数
parameter byte_size=8, byte_msb=byte_size-1;     //用常数表达式赋值
parameter average_delay = (r+f)/2;              //用常数表达式赋值

```
* 用法
   * 引用实例时，通过参数的传递来改变已经定义的参数值。
 `Decode   #（4,0） D1（A4，F16）`

   * 在多层次的模块中，改变参数需要使用defparam命令。     
 `defparam   Test.T.B1.P=2；         //Test、T、B1分别是高层模块中的底层模块实例。`

### 3.2.3 变量
#### 3.2.3.1 wire型
&emsp;&emsp;wire型数据**常用来表示用于以assign关键字指定的组合逻辑信号**。Verilog程序模块中输入输出信号类型缺省时自动定义为wire型。**wire型号的数据默认是高阻态z**。wire型信号可以用作任何方程式的输入，也可以用作“assign”语句或实例元件的输出。

&emsp;&emsp;wire型信号的格式同reg型信号的很类似。其格式如下：
```verilog
wire [n-1:0] 数据名1,数据名2,…数据名i;//共有i条总线，每条总线内有n条线路
    
wire [n:1] 数据名1,数据名2,…数据名i;
```

&emsp;&emsp;wire是wire型数据的确认符，[n-1:0]和[n:1]代表该数据的位宽，即该数据有几位。最后跟着的是数据的名字。如果一次定义多个数据，数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。如下格式：

```verilog
wire a;           //定义了一个一位的wire型数据
wire [7:0] b;     //定义了一个八位的wire型数据
wire [4:1] c, d;  //定义了二个四位的wire型数据
```
>**补充：网络类型**
>
>* 网络数据类型**表示结构实体之间的物理连接。网络数据类型的变量不能储存数值**，而且必须受到驱动器（门或连续赋值语句assign）的驱动。包括 wire型 和 tri型 数据。
>   * wire用于表示单个门驱动或者连续赋值语句assign驱动的网络数据类型；
>   * tri型则用来表示多驱动器驱动的网络型数据。
>* 如果没有定义wire和tri的逻辑强度，在多驱动元的情况下逻辑值会发生冲突，从而产生不确定值。(z的优先级最低，x的优先级最高)

#### 3.2.3.2 reg型


&emsp;&emsp;**寄存器是数据储存单元的抽象**。寄存器数据类型的关键字是reg。通过赋值语句可以改变寄存器储存的值，其作用与改变触发器储存的值相当。**reg类型数据的缺省初始值为不定值x**。reg型只表示被定义的信号将用在“always”块内。


&emsp;&emsp;reg型数据**常用来表示用于“always”模块内的指定信号，常代表触发器**。通常，在设计中要由“always”块通过使用行为描述语句来表达逻辑关系。在“always”块内被赋值的每一个信号都必须定义成reg型。reg型数据的格式如下：
```verilog
reg [n-1:0] 数据名1,数据名2,… 数据名i;

reg [n:1] 数据名1,数据名2,… 数据名i;

```
&emsp;&emsp;reg是reg型数据的确认标识符，[n-1:0]和[n:1]代表该数据的位宽，即该数据有几位（bit)。最后跟着的是数据的名字。如果一次定义多个数据，数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。如下：
```
reg rega; //定义了一个一位的名为rega的reg型数据

reg [3:0] regb; //定义了一个四位的名为regb的reg型数据

reg [4:1] regc, regd; //定义了两个四位的名为regc和regd的reg型数据
```
&emsp;&emsp;reg数据可以赋正值，也可以赋负值。但是当一个reg数据是一个表达式的操作式时，它的值被当做无符号值，即正值。如：4位的reg被赋值为-1，在表达式中为+15.

&emsp;&emsp;reg型只是表示被定义的信号将被用在always模块中，并不是说reg型数据就一定是存储器或触发器的输出。

 
#### 3.2.3.3 memory型
&emsp;&emsp;Verilog HDL通过对reg型变量建立数组来对存储器建模，可以**描述RAM型存储器，ROM存储器和reg文件**。数组中的每一个单元通过一个数组索引进行寻址。在Verilog语言中没有多维数组存在。 memory型数据是通过扩展reg型数据的地址范围来生成的。其格式如下：

```verilog
reg [n-1:0] 存储器名[m-1:0]；

reg [n-1:0] 存储器名[m:1]；
```

&emsp;&emsp;在这里，reg [n-1:0]定义了存储器中每一个存储单元的大小，即该存储单元是一个n位的寄存器。存储器名后的[m-1:0]或[m:1]则定义了该存储器中有多少个这样的寄存器。最后用分号结束定义语句。下面举例说明：

```
reg [7:0] mema[255：0];
```

&emsp;&emsp;这个例子定义了一个名为mema的存储器，该存储器有256个8位的存储器。该存储器的地址范围是0到255。**注意：对存储器进行地址索引的表达式必须是常数表达式。**


&emsp;&emsp;另外，在同一个数据类型声明语句里，可以同时定义存储器型数据和reg型数据。见下例：

```verilog
parameter wordsize=16, memsize=256; //定义二个参数

reg [wordsize-1:0] mem[memsize-1:0], writereg, readreg;
```

&emsp;&emsp;尽管memory型数据和reg型数据的定义格式很相似，但要注意其不同之处。如一个由n个1位寄存器构成的存储器组是不同于一个n位的寄存器的。见下例：

```verilog
reg [n-1:0] rega; //一个n位的寄存器
reg mema [n-1:0]; //一个由n个1位寄存器构成的存储器组

```
&emsp;&emsp;**一个n位的寄存器可以在一条赋值语句里进行赋值，而一个完整的存储器则不行**。见下例：

```verilog
rega = 0; //合法赋值语句
mema = 0; //非法赋值语句
```

&emsp;&emsp;如果想对memory中的存储单元进行读写操作，必须指定该单元在存储器中的地址。下面的写法是正确的。
```verilog
mema[3]=0; //给memory中的第3个存储单元赋值为0。
```

&emsp;&emsp;进行寻址的地址索引可以是表达式，这样就可以对存储器中的不同单元进行操作。表达式的值可以取决于电路中其它的寄存器的值。例如可以用一个加法计数器来做RAM的地址索引。


## 3.3 运算符及表达式

* Verilog HDL语言的运算符范围很广，其运算符按其功能可分为以下几类:
	* 算术运算符(+,－,\*，/,％)
	* 赋值运算符(=,<=)
	* 关系运算符(>,<,>=,<=)
	* 逻辑运算符(&&,||,!)
	* 条件运算符(? : )
	* 位运算符(~,|,^,&,^~)
	* 移位运算符(<<,>>)
	* 拼接运算符({ })
	* 其它
* 在Verilog HDL语言中运算符所带的操作数是不同的，按其所带操作数的个数运算符可分为三种:
	* 单目运算符(unary operator):可以带一个操作数,操作数放在运算符的右边。
	* 双目运算符(binary operator):可以带二个操作数,操作数放在运算符的两边。
	* 三目运算符(ternary operator):可以带三个操作,这三个操作数用三目运算符分隔开。
```verilog
clock = ~clock;   // ~是一个单目取反运算符, clock是操作数。
c = a | b;        // |是一个二目按位或运算符, a 和 b是操作数。
r = s ? t : u;    // ?: 是一个三目条件运算符, s,t,u是操作数。
```



### 3.3.1 基本的算术运算符
* 在Verilog HDL语言中，算术运算符又称为二进制运算符，共有下面几种：

|运算符|描述|示例|
|:--|:--|:--|
|+ |加法运算符,或正值运算符|rega＋regb，＋3
|－ |减法运算符，或负值运算符| rega－3,－3
|\*  |乘法运算符，|rega\*3
| / |除法运算符，|5/3
| % |模运算符，或称为求余运算符，要求操作数为整数。|7％3的值为1


* 在进行整数的除法运算时，结果要略去小数部分，只取整数部分；而进行取模运算时（%，亦称作求余运算符）结果的符号位采用模运算符中第一个操作数的符号。

* 在进行算术运算时，如果某一个操作数有不确定的值x，则整个结果也为不确定值x。
### 3.3.2 位运算符
&emsp;&emsp;Verilog HDL作为一种硬件描述语言,是针对硬件电路而言的。在硬件电路中信号有四种状态值1,0,x,z.在电路中信号进行与或非时，反映在Verilog HDL中则是相应的操作数的位运算。

* "取反"运算符`~`——一个单目运算符,用来对一个操作数进行按位取反运算。

| ~|结果|
|--|--|
|**0**|1|
|**1**|0|

```verilog
rega='b1010; //rega的初值为'b1010
rega=~rega; //rega的值进行取反运算后变为'b0101
```

* “按位与”运算符`&`——按位与运算就是将两个操作数的相应位进行与运算,其运算规则见下表:

|&|0|1|x|
|--|--|--|--|
|**0**|0|0|0|
|**1**|0|1|x|
|**x**|0|x|x|





* “按位或”运算符`|`——按位或运算就是将两个操作数的相应位进行或运算。

|&|0|1|x|
|--|--|--|--|
|**0**|0|1|x|
|**1**|1|1|1|
|**x**|x|1|x|

* “按位异或”运算符`^`(也称之为XOR运算符)——按位异或运算就是将两个操作数的相应位进行异或运算。

|&|0|1|x|
|--|--|--|--|
|**0**|0|1|x|
|**1**|1|0|x|
|**x**|x|x|x|


* “按位同或”运算符`^~`——按位同或运算就是将两个操作数的相应位先进行异或运算再进行非运算。

|&|0|1|x|
|--|--|--|--|
|**0**|1|0|x|
|**1**|0|1|x|
|**x**|x|x|x|


* 不同长度的数据进行位运算——两个长度不同的数据进行位运算时,系统会自动的将两者按右端对齐。位数少的操作数会在相应的高位用0填满,以使两个操作数按位进行操作。


### 3.3.3 逻辑运算符

* 在Verilog HDL语言中存在三种逻辑运算符:
	* `&&`，逻辑与
	* `||`，逻辑或
	* `!` ，逻辑非


* “&&”和“||”是二目运算符,它要求有两个操作数,如(a>b)&&(b>c),(a单目运算符,只要求一个操作数,如!(a>b)。

* 逻辑运算符中“&&”和“||”的优先级别低于关系运算符,“!” 高于算术运算符。

|a|b|a&&b|a\|\|b|!a|!b|
|:--:|:--:|:--:|:--:|:--:|:--:|
|真|真|真|真|假|假|
|真|假|假|真|假|真|
|假|真|假|真|假|真|
|假|假|假|假|真|真|

### 3.3.4 关系运算符

* 不等关系运算符
  * 不等关系运算符共有以下四种：
     * `<` ，小于
     * `>`  ，大于
     * `<=`  ，小于等于
     * `>=`  ，大于等于
  * 在进行关系运算时，如果声明的关系是假的(false)，则返回值是0，如果声明的关系是真的(true)，则返回值是1，如果某个操作数的值不定，则关系是模糊的，返回值是不定值。
* 等式运算符
  * 逻辑等式运算符：其结果由两个操作数的值决定。由于操作数中某些位可能是不定值x和高阻值z,结果可能为不定值x。
     * `==`，等于
     * `!=`，不等于
  * case等式运算符：在对操作数进行比较时对某些位的不定值x和高阻值z也进行比较,两个操作数必需完全一致，其结果才是1，否则为0。
     * `a===`b，严格等于
     * `a!==`b，严格不等于


|===|0|1|x|z|
|--|--|--|--|--|
|**0**|1|0|0|0|
|**1**|0|1|0|0|
|**x**|0|0|1|0|
|**z**|0|0|0|1|

|==|0|1|x|z|
|--|--|--|--|--|
|**0**|1|0|x|z|
|**1**|0|1|x|x|
|**x**|x|x|x|x|
|**z**|x|x|x|x|






### 3.3.5 移位运算符

&emsp;&emsp;在Verilog HDL中有两种移位运算符：<< (左移位运算符) 和 >>(右移位运算符)。其使用方法如下：`a >> n 或 a << n`。a代表要进行移位的操作数，n代表要移几位。这两种移位运算都用0来填补移出的空位。


### 3.3.6 位拼接运算符(Concatation)


&emsp;&emsp;在Verilog HDL语言有一个特殊的运算符：位拼接运算符`{}`。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。其使用方法如下：
```verilog
{信号1的某几位，信号2的某几位，..,..,信号n的某几位}
```
&emsp;&emsp;即把某些信号的某些位详细地列出来，中间用逗号分开，最后用大括号括起来表示一个整体信号。见下例：
```verilog
{a,b[3:0], w, 3’b101}

//也可以写成为

{a,b[3],b[2],b[1],b[0],w,1’b1,1’b0,1’b1}
```
* 在**位拼接表达式中不允许存在没有指明位数的信号**。这是因为在计算拼接信号的位宽的大小时必需知道其中每个信号的位宽。

* 位拼接还可以用重复法来简化表达式。见下例：
```verilog
{4{w}} //这等同于{w,w,w,w}
```
* 位拼接还可以用嵌套的方式来表达。见下例：
```verilog
{b,{3{a,b}}} //这等同于{b,a,b,a,b,a,b}
```
* 用于表示重复的表达式如上例中的4和3，必须是常数表达式。


### 3.3.7 缩减运算符(reduction operator)
&emsp;&emsp;缩减运算符是单目运算符,也有与或非运算。其与或非运算规则类似于位运算符的与或非运算规则,但其运算过程不同。位运算是对操作数的相应位进行与或非运算,操作数是几位数则运算结果也是几位数。而缩减运算则不同,**缩减运算是对单个操作数进行或与非递推运算,最后的运算结果是一位的二进制数**。缩减运算的具体运算过程是这样的:

* 第一步先将操作数的第一位与第二位进行或与非运算,
* 第二步将运算结果与第三位进行或与非运算,依次类推,直至最后一位。

```verilog
reg [3:0] B;
reg C;
C = &B;

//相当于

C =( (B[0]&B[1]) & B[2] ) & B[3];
```

&emsp;&emsp;由于缩减运算的与、或 运算规则类似于位运算符与、或 运算规则,这里不再详细讲述,请参照位运算符的运算规则介绍。


### 3.3.8 优先级别

![2](https://www.github.com/liao20081228/blog/raw/master/图片/verilog教程/2.JPG)


## 3.4 关键词

&emsp;&emsp;在Verilog HDL中，所有的关键词是事先定义好的确认符,用来组织语言结构。关键词是用小写字母定义的,因此在编写程序代码时必须注意关键词的书写,以避免出错，**变量的定义不要与这些关键词冲突**。下面是Verilog HDL中使用的关键词。
|关键词|描述|关键词|描述|关键词|描述|关键词|描述|
|:--:|:--|:--:|:--|:--:|:--|:--:|:--|
|always||and||assign||begin||
|buf||bufif0|| bufif1||case||
|casex|| casez|| cmos|| deassign|| 
|default|| defparam|| disable|| edge|| 
|else|| end|| endcase|| endmodule|| 
|endfunction|| endprimitive|| endspecify|| endtable||
|endtask|| event|| for|| force|| 
|forever|| fork|| function|| highz0|| 
|highz1|| if|| initial|| inout|| 
|input|| integer|| join||large|| 
|macromodule||medium|| module|| nand|| 
|negedge|| nmos|| nor|| not|| 
|notif0|| notifl|| or|| output|| 
|parameter|| pmos|| posedge|| primitive|| 
|pull0|| pull1|| pullup|| pulldown|| 
|rcmos|| reg|| releses|| repeat|
| mmos|| rpmos|| rtran|| rtranif0|
| rtranif1|| scalared|| small|| specify|
| specparam|| strength|| strong0|| strong1|
| supply0|| supply1|| table|| task||
| time|| tran|| tranif0|| tranif1||
| tri|| tri0|| tri1|| triand||
| trior|| trireg|| vectored|| wait||
| wand|| weak0|| weak1|| while||
| wire|| wor|| xnor|| xor||





## 3.5 赋值语句

* 在Verilog HDL语言中，信号有两种赋值方式：
  * 阻塞(Blocking)赋值方式( 如 b = a; )
     * 赋值语句执行完后,块才结束；
     * b的值在赋值语句执行完后立刻就改变的
     * 在时序逻辑设计中使用，可能会产生意想不到的结果。
  * 非阻塞(Non_Blocking)赋值方式( 如 b <= a; )
     * 在语句块中，上面语句所赋的变量值不能立即就为下面的语句所用；
     * 块结束后才能完成这次赋值操作，而所赋的变量值是上一次赋值得到的；
     * 在编写可综合（synthesis）的时序逻辑模块时，这是最常用的赋值方法。

* 非阻塞赋值符 “ <= ” 与小于等于符 “<= ” 看起来是一样的，但意义完全不同，小于等于符是关系运算符，用于比较大小。而非阻塞赋值符用于时序赋值操作。
* 非阻塞赋值方式和阻塞赋值方式的区别常给设计人员带来问题。问题主要是给"always"块内的reg型信号的赋值方式不易把握。
  * "always"模块内的reg型信号在描述时序电路时都是采用下面的这种赋值方式:`b <= a;`这种方式的赋值并不是马上执行的，也就是说 "always" 块内的下一条语句执行后，b并不等于a，而是保持原来的值。"always" 块结束后，才进行赋值。
  * 而另一种赋值方式阻塞赋值方式，如下所示:`b = a;`这种赋值方式是马上执行的。也就是说执行下一条语句时，b已等于a。尽管这种方式看起来很直观，但是可能引起麻烦

>**补充：阻塞与非阻塞赋值**
>
>* 首先规定两个缩写：
>   * RHS--赋值等号右边的表达式或变量可以写作RHS表达式或RHS变量；
>   * LHS--赋值等号左边的表达式或变量可以写作LHS表达式或LHS变量。
>* 阻塞赋值
>   * 阻塞赋值的详细过程是先计算等号右手方向的RHS的值，这时**赋值语句不允许别的任何Verilog语句的干扰，直到它的赋值完成**，即把RHS赋给LHS的时刻，才允许别的赋值语句执行。一般可以综合的阻塞赋值不能在RHS设置延迟（零延迟也不可以）。阻塞赋值的执行可以认为是只有一个步骤的操作，即计算RHS的值并更新LHS，此时不允许任何其他语句的干扰，所谓的阻塞的概念就是值在同一个always块中，其后面的赋值语句从概念上来讲是在前面一条语句赋值完成后才执行的。
>   * 如果在一个过程块中阻塞赋值的变量RHS正好是另一个always块中阻塞赋值的LHS变量，这两个过程又通过同一个时钟沿触发，这是阻塞赋值会出现问题，有可能出现竞争。如果这两个赋值语句操作由同一个时钟沿触发，则执行的顺序是无法确定的。
> * 在下例中，如果清零信号已经从1到0(已经reset过)，并且上面的always块比下面的always块的时钟沿早几个皮秒到达，那么最后y1=1，y2=1；但是如果下面的always块的时钟沿先到达，那么输出y1=0，y2=0；这就说明折个模块是不稳定的，肯定会产生竞争和冒险。
>
>```verilog
>module fbosc(y1,y2,clk,rst);
>    input clk,rst;
>    output y1,y2;
>    reg y1,y2;
>    always @(posedge clk or posedge rst)
>    begin
>        if(rst) 
>            y1=0;
>       else 
>            y1=y2;
>    end
>    
>    always @(posedge clk or posedge rst)
>    begin
>        if(rst) 
>            y2=1;
>   else 
>           y2=y1;
>    end
>endmodule
>```
>* 非阻塞赋值
>   * 非阻塞赋值在赋值开始的时刻就开始计算RHS的值，但是到赋值结束的时刻才更新LHS。**在计算RHS和更新LHS的时刻其他的Verilog语句，包括其他非阻塞赋值语句都能同时进行计算RHS和更新LHS**。非阻塞赋值允许其他的Verilog语句同时进行操作。非阻塞赋值只能用于对存储器型变量进行赋值，因此只能用在initial块和always块中，并且不允许用assign赋值。
>   * 非阻塞赋值可以看做两个步骤：
>       * 在赋值开始时刻，计算非阻塞赋值RHS表达式；
>       * 在赋值结束时刻，更新非阻塞赋值LHS的值。
>       * 在下例中，按照IEEE的标准，两个always块是并行执行的。在复位后，无论哪一个always的有效沿先到达，两个always块中的非阻塞赋值都在赋值开始计算RHS的表达式，而在结束时刻才更新LHS。所以复位之后，无论哪个边沿先到达，y1=1;y2=0是确定的，因为实质上y1被赋值的是信号沿上升时刻的y2的值，此时y2还没有改变，而y2被赋的值是信号上升沿时y1的值；若以后保持rst为零的话，每一个时钟沿到来之后，y1和y2被赋值的都是上一个周期的y2和y1，从结果来看两个赋值语句是并行执行的。
>
>```verilog
>module fbosc(y1,y2,clk,rst);
>  input clk,rst;
>  output y1,y2;
>  reg y1,y2;
>  
>  always @(posedge clk or posedge rst)
> begin
>    if(rst) 
>       y1<=0;
>     else 
>        y1<=y2;
>  end
>
>  always @(posedge clk or posedge rst)
>  begin
>  if(rst) 
>        y2<=1;
>  else 
>        y2<=y1;
>  end
>endmodule
>```
>* 在使用阻塞赋值和非阻塞赋值时的八大原则:
>   * 时序电路建模时，采用非阻塞赋值；
>   * 锁存器电路建模时，采用非阻塞赋值；
>   * 用always块建立组合逻辑模型时，采用阻塞赋值；
>   * 用always块建立时序和组合逻辑混合电路时，采用非阻塞赋值；
>   * 不要在同一个always块中同时使用非阻塞赋值和阻塞赋值；
>   * 不要在一个以上的always块中为同一个变量赋值；
>   * 用$strobe系统任务来显示用非阻塞赋值的变量值；
>   * 在赋值时，不要用#0延迟；
 

## 3.6 块语句
* 块语句是指将两条或者两条以上的语句组合在一起，使其在格式上更像一条语句。块语句分为begin...end和fork...join两种。
* 块语句可以是匿名的，也可以是具名的。块名的作用：
  * 可以在块内定义局部变量，即只在块内使用的变量；
  * 可以允许被其他的语句调用，也可以通过层次名进行调用；
  * 在Verilog中，所有的变量都是静态的，即所有的变量都只有一个唯一的存储地址，因此进入或者跳出块并不影响储存在变量内的值。
  * 命令块可以被禁用，关键词为disable，可以用disable跳出循环，处理错误条件以及根据控制信号来控制某些代码是否执行。

### 3.6.1 begin...end语句
* begin...end语句，通常用来标识顺序执行的语句，用它标识的块称作顺序块；
* 块内的语句是按照顺序执行的，即只有上面一条语句执行完后下面的语句才能执行；
* 每条语句的延迟时间都是相对于前一条语句的仿真时间而言的；
* 直到最后一条语句执行完，程序流程控制才跳出该语句块。
* 在begin-end语句块中，begin-end和fork-join块可以相互嵌套，也可以自我嵌套
* 当只有一条语句时可以省略begin...end
```verilog
begin
    语句1；
    语句2；
end

//或

begin：块名
    块内声明语句
   
    语句1；
    语句2；
end
```

### 3.6.2 fork...join语句
* fork...join语句，通常用来标识并行执行的语句，用它标识的块称作并行块。
* 块内语句是同时执行的，即程序流程控制进入该块时刻，块内语句则开始同时并行执行；
* 块内每条语句的延迟时间都是相对于程序流程进入到块内的时刻。
* 延迟时间是用来给赋值语句提供执行时序的；
* 当按时间排序在最后的语句执行完成后，或者一个disable语句执行时，程序流程控制跳出该模块。
*  在fork-join语句块中，begin-end和fork-join块可以相互嵌套，也可以自我嵌套。
*  当只有一条语句时可以省略for...-join

```verilog
fork
    语句1；
    语句2；
join

//或

fork：块名
    块内声明语句
   
    语句1；
    语句2；
join
```



### 3.6.3  顺序块和并行块的性质对比

|对比性质|	顺序块	|并行块|
|:--|:--|:--|
|**块内声明语句变量类型**|	parameter、reg、integer、real	|parameter、reg、integer、real、time、event|
|**开始时间**	|第一条语句开始执行的时间	|流程控制进入该块的时间|
|**结束时间**	|最后一条语句结束执行时间|	按时间排在最后的语句执行结束时间|


```verilog
//举例：（程序功能相同的顺序块和并行块）

parameter  d=50;
reg   [7:0] r;
begin
    #d   r='h35;
    #d   r='hE2;
    #d   r='h00;
    #d   r='hF7;
    #d   ->end_wave;//->表示触发事件end_wave使其翻转
end

//如果d=0，则这个顺序块的执行不需要时间。若d=50，则块语句完成的时间为250，因为每个语句都要等待50个时间单位）

fork
    #250  ->end_wave; 
    #200   r='hF7;
    #150   r='h00;
    #100   r='hE2;
    #50     r='h35;
join

//在并行块中，所有语句都是在程序流程进入并行块时同时开始的，因此这个语句结束的时间为250

```




## 3.7 条件语句
### 3.7.1 if...else语句
```verilog
if（表达式）
    语句1；

//或

if（表达式）              
    语句1；
else
    语句2;

//或

if（表达式1）
    语句1；
else   if（表达式2）    
    语句2；
else   if（表达式3）    
    语句3；

```
* 3种形式的if语句后面都有表达式，一般为逻辑表达式或关系表达式。当表达式的值为1，按真处理，若为0、x、z，按假处理。

* 在每一个else前面，即上面的语句后都有分号（除非上面是begin_end块）。else语句不能单独使用，它是if语句的一部分。

* if 和else后面都可以包含一个内嵌的操作语句，也可以有多个语句，此时可以用begin_end将它们包含起来成为一个复合块语句；（end后不需要再加分号）

* 允许一定形式的表达式的简写方式。如：if（expression）等同于 if（expression==1）

* if语句可以嵌套，即 if 语句中可以再包含if语句，但是应该注意**else总是与它上面的最近的 if 进行配对**。如果不希望else与最近的 if 配对，可以采用begin...end进行分割，如：
```
if （）
begin
    if（） 
        语句1；
end
else
    语句2；
```

* **条件语句必须在过程块中使用**。所谓过程块是指由 initial 和always语句引导的执行语句集合。除了这两种语句引导的begin...end块中可以编写条件语句外，模块中的其他地方都不能编写。

* 在always块内，如果在给定的条件下变量没有赋值，这个变量将保持原值，也就是说会生成一个锁存器。

 

### 3.7.2 case语句
```verilog
case（表达式）      
    分支表达式1：
        语句1；
    分支表达式2：
        语句2；
    默认项（default）      
endcase

//或

casex（表达式）      
    分支表达式1：
        语句1；
    分支表达式2：
        语句2；
    默认项（default）      
endcase

//或

casez（表达式）      
    分支表达式1：
        语句1；
    分支表达式2：
        语句2；
    默认项（default）      
endcase

```
* case后括号内的表达式称为控制表达式，分支项后的表达式称作分支表达式，又称作常量表达式。控制表达式通常表示为控制信号的某些位，分支表达式则用这些控制信号的具体状态值来表示。

* 当控制表达式和分支表达式的值相等时，就执行分支表达式后的语句。

* default项可有可无，一个case语句里只准有一个default项。（为了防止程序自动生成锁存器，一般都要设置default项，P57）

* 每一个case的表达是必须各不相同，执行完case分支项的语句后，跳出case块。

* case语句的所有表达式的值的位宽必须相等。

* case casex 和 casez 的真值 

|case|	0   |1  | x  | z||casez|	0  |  1 |  x |  z	| 	|casex	|0  | 1 |  x  | z|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|**0**| 1  | 0  | 0 |  0|| **0** |1   |0  | 0 |  1|	 	|**0**	|1  | 0  | 1  |1|
|**1**|	0  | 1  | 0 |  0|| **1** |0  | 1  | 0 |  1|	 |	**1**|	0   |1 | 1 |  1|
|**x**|	0  | 0  | 1 |  0|| **x** |	0  | 0  | 1  | 1||	 	**x**|	 1  | 1  | 1  | 1 |
|**z**|	0  | 0  | 0 |  1|| **z** |	1 |  1|   1|   1|	 	|**z**	|1 |  1   |1   |1|
 

* casex和casez是case的特殊情况，用来处理过程中不必考虑的情况（don't care condition）。case用来处理不用考虑高阻值，casex表示不用考虑高阻值和不定值。

* 上述表格说明casez中，可以将z任意匹配，casex中可以将x任意匹配。在case的分支语句中，从上到下开始匹配，输出第一个匹配成功的值


## 3.8 循环语句

* forever语句： 连续执行的语句。常用于产生周期性的波形，用来作为仿真测试信号。它与always的不同之处是不能独立在程序中，必须写在initial块中。
```verilog
forever   
    语句；

//或

forever 
begin 
    多条语句 
end
```
* repeat语句：  连续执行n次的语句。在repeat中，其表达式常为常量表达式。（可实现乘法器）
```verilog
repeat（表达式）   
    语句；

//或

repeat（表达式）   
begin 
    多条语句 
end
```

* while语句：执行语句，直至某个条件不满足。
```verilog
while（表达式）   
    语句；

//或

while（表达式）   
begin 
    多条语句 
end
```
* for 语句：   三个部分，尽量少用或者不用for循环。执行过程与 c 语言中的for循环相同，注意表达式之间要用分号分割。
```verilog
for（表达式1；表达式2；表达式3）
    语句；

//或

for（表达式1；表达式2；表达式3）
begin 
    多条语句 
end
```

## 3.9 生成块语句
&emsp;&emsp;**生成块可以动态的生成Verilog代码**。可以用于对矢量中的多个位进行重复操作、多个模块的实例引用的重复操作、根据参数确定程序中是否包含某段代码。生成语句可以控制变量的声明、任务和函数的调用、还能对实例引用进行全面的控制。在编程时，应用关键字generate...endgenerate来说明生成的实例范围。

* 生成实例可以是一下的以下一种或多种类型：
  * 模块 ；  
  * 用户定语原语 ； 
  * 门级原语 ；  
  * 连续赋值语句；   
  * initial 和 always 块。

* 生成实例中语序的数据类型：
  
  * wire型 reg型；
  * integer型，real型，time型，realtime型；
  * event型。

* 生成的数据、实例、任务、函数都具有唯一的标识名，可以被层次引用。（任务和函数的声明可以出现在生成范围之中，但是不能出现在循环过程当中）

* 不允许出现在生成范围之中的模块项声明：
  * 参数、局部参数；
  * 输入、输出、输入/输出声明；
  * 指定块。

* 在Verilog中有三种常见生成语句的方法：
  * 循环生成——循环生成语句允许使用者对下面的模块或模块项进行多次的实例引用；
     * 变量声明；    
     * 模块；    
     * 用户定义原语、门级原语；  
     * 连续赋值语句；  
     * initial 和 always 块。  
  * 条件生成——条件生成语句类似于 if。。。else if的生成构造，该结构可以在设计模块中根据经过仔细推敲并确定表达式，有条件的调用以下结构：
     * 模块；  
     * 用于定义的原语，门级原语；  
     * 连续赋值语句；  
     * initial 或always 块。
  * case生成 ——case生成语句可以调用以下的结构：
     * 模块；  
     * 用于定义的原语，门级原语；   
     * 连续赋值语句； 
     * initial 或 always块。

  * 由定义来看，在if 和 case的生成语句中，不能够声明变量。

 
```verilog
//例：用循环生成语句描述的脉动加法器

//本地生成一个门级脉动加法器

module ripple_adder(co,sum,a0,a1,ci);
    parameter   N=4;
    output  [N-1,0]   sum;
    output  co;
    input    [N-1,0] a0,a1;
    input    ci;
    wire  [N-1,0] carry       //本地线网生成语句
    assign   carry[0] = ci;   //指定进位变量的第0位等于进位的输入
    genvar i ;                //声明临时变量，该变量只用于生成块的循环中，在确定的仿真代码中是不存在的。
    
    generate  
        for( i=0; i<N; i=i+1)  
        begin:r_loop
            wire t1,t2,t3;
            xor  g1(t1, a0[i], a1[i]);
            xor  g2(sum[i], t1, carry[i]);
            and  g3(t2, a0[i], a1[i])
            and  g4(t3, t1, carry[i])
            or   g5(carry[i=1], t2, t3)
        end
    endgenerate
    
    //根据上面的循环生成，Verilog编译器会自动生成以下相对层次实例名
    //xor: r_loop[0].g1, r_loop[1].g1, r_loop[2].g1, r_loop[3].g1;
    //    r_loop[0].g2, r_loop[1].g2, r_loop[2].g2, r_loop[3].g2;
    //and: r_loop[0].g3, r_loop[1].g3, r_loop[2].g3, r_loop[3].g3;
    //    r_loop[0].g4, r_loop[1].g4, r_loop[2].g4, r_loop[3].g4;
    //or : r_loop[0].g5, r_loop[1].g5, r_loop[2].g5, r_loop[3].g5;
    
    //根据上面的生成实例用下面这些线网连接起来
    //Nets：r_loop[0].t1, r_loop[0].t2, r_loop[0].t3;
    //      r_loop[1].t1, r_loop[1].t2, r_loop[1].t3; 
    //      r_loop[2].t1, r_loop[2].t2, r_loop[2].t3; 
    //      r_loop[3].t1, r_loop[3].t2, r_loop[3].t3;
    
	assign  co=carry[N];
endmodule

```
## 3.10 结构说明语句
Verilog中的任何过程都可以属于以下四种结构的说明语句：initial、always、task  、function。

### 3.10.1 initial说明语句

&emsp;&emsp;一个程序中的 initial 和 always 的次数是不受限制的，他们都是在仿真的一开始同时开始运行的。initial 只执行一次，而 always语句则是不断地重复活动，直到仿真活动结束、但是always 后面的过程块是否运行，则要看他的触发条件是否满足，满足则运行一次，再满足再运行，直至仿真结束。
```verilog
initial 
begin
    语句1；
    语句2；
    ...
    语句n；

end
```
&emsp;&emsp;一个模块中可以有多个initial块，他们都是并行运行的。 initial 块常用于测试文件和虚拟模块的编写，用来产生仿真测试信号和设置信号记录等仿真环境。

 

### 3.10.2 always说明语句
```verilog
always  <时序控制>  <语句>;
```
* 如果always没有时序控制，则会产生仿真器的死锁。 如：always  areg=~areg；这将产生0延迟的无限循环跳变过程，这时发生仿真死锁。

* always 的时序控制可以是**边沿触发也可以是电平触发**，可以单个信号亦可以十多个信号，中间用关键词or链接。

```verilog
always@（posedge clock or posedge reset）
begin
    ....
end

always @（a or b or c）
begin
    ....
end
```
* 上述中，A是由两个边沿触发的always只要其中一个沿出现，就立即执行一次过程块。B是有a b c 三个信号电平触发的，只要a b c 中任何一个发生变化，从高到低或从低到高都会执行过程块。

* 边沿触发的always 块常常描述时序行为，如有限状态机，通常对应于寄存器组和门级组合逻辑的结构。而电平触发的always块常常用来描述组合逻辑的行为。

* 在always语句中，**由关键词or 链接的多个事件名或者信号名组成的列表称为敏感列表。用关键词or或者','表示这种关系。如果输入的逻辑变量较多，那么编写敏感列表会很繁琐而且容易出错。针对这种情况，Verilog中可以用@\* 和 @（\*），他们表示对后面语句块中所有的输入变量的变化是敏感的**。

* 电平敏感的时序控制：Verilog用关键字wait 来表示等待电平敏感的条件为真，如：
```verilog
always  wait  （count_enabal）  #20 count = count+1；
```
* 这个例子中，仿真器连续见识count_enable的值，其值为0，则不执行后面语句。如果其值为1，则20个单位后执行这个语句，如果count_enable始终为1，那么count每20个单位时间+1。

* 在always中，被赋值的只能是寄存器类型的变量，如reg,integer, real, time, realtime.等

## 3.11 任务和函数语句
* task 和 function 说明语句分别用来定义任务和函数，利用任务和函数可以把函数模块分成许多小的任务和函数便于理解和调试。任务和函数往往还是大的程序模块在不同地点多次用到的相同的程序段。输入、输出和总线信号的数据可以传入、传出任务和函数。

* task 和 function 的不同
  * 函数只能与主模块共用同一个仿真的时间单位，而任务可以自己定义自己的仿真时间单位。
  * 函数不能启动任务，但是可以调用其它函数，但是任务可以调用其他函数和任务；
  * 函数至少要有一个输入变量，而任务可以没有或者有多个任何类型的变量。
  * 函数返回一个值，而任务不返回任何值。
  * 函数的目的值通过一个返回值对输入的信号进行响应。而任务可以支持多种目的，能计算多个结果值，这些值只能通过任务的输出端口或者总线端口输出。



### 3.11.1 task说明语句

&emsp;&emsp;如果传给任务的变量和任务完成后接受结果的变量已经定义，就可以用一条语句启动任务，任务完成以后控制就传回启动过程。如果任务内部有定时设置，则启动的时间可以与控制返回的时间不同。

* 任务的定义;
```verilog
task <任务名>;
  <端口及数据类型声明语句>

  <语句1>
  ...
  <语句n>
endtask
```
* 任务的调用以及变量的传递：
```verilog
//任务定义;
task  my_task;
  input a,b;
  inout c;
  output  d,e;

  ....              //执行任务的相应语句
  
  c=foo1;           //对任务的变量赋初始值
  d=foo2;
  e=foo3;
endtask

//任务的调用: 
my_task(v,w,x,y,z) //任务调用变量（v,w,x,y,z）和任务定义的I/O变量（a,b,c,d,e）是一一对应的。任务启动时，v,w和x的值给了a b c，结束时c,d,e的值返回给x,y,z。
```

### 3.11.2 function说明语句

* 函数的目的是返回一个用于表达式的值。定义函数的语法：
```verilog
function <返回值的类型或范围>函数名；
     <端口说明语句>

     <变量类型说明语句>
     
   begin
     <语句>
     ...
   end
endfunction
```
* 在这里，\<返回值的类型或范围>可以不定义，如果缺省则代表一位寄存器类型数据。

* 函数返回的值：函数的定义蕴含声明了一个与函数同名的，函数内部的寄存器，其位数与定义的相同；

* 函数的调用：函数的调用是通过将函数作为表达式中的操作数来实现的。例：`word=control ? {getbyte(msbyte),getbyte(lsbyte)} : 0;`

* 函数的使用规则：
  * 函数的定义不能包含任何的时间控制语句，及任何用`# `，`@`，或`wait`来标识的语句。
  * 函数不能启动任务，定义函数至少输入一个输入参量；
  * 函数的定义中必须有一条赋值语句给函数中的一个内部变量赋以函数的值，该内部变量具有和函数名一样的名字。
  * 函数的输入变量不能像模块的端口那样列在函数名后面的括弧内，在声明输入时把这些输入端口列出即可。函数不能被禁用。
```verilog
module parity；
    reg [31:0]sddr;
    reg parity;
    initial
    begin
           addr=32'b3456_789a;
       #10  addr=32'bc4c6_78ff;
       #10  addr=32'bff56_ff9a;
       #10  addr=32'b3faa_aaaa;
    end
    //每当地址未发生变化，重新计算偶校验位
    always @(addr)
    begin
      parity=cal_parity(addr);
      $display("parity calculated = %b",cal_paraty(addr));
    end
    //定义偶检验函数
    function cal_parity;
        input [31:0]address;
        begin
            cal_parity=^address;
        end
    endfunction
endmodule
```

* 在上例中，函数的定义也可以采用C语言的风格定义，如：function cal_paruty(input [31:0] address);

* **Verilog中的函数是不能进行递归调用的**。在设计模块中如果某个函数在两个不同位置同时并发被调用，由于这两个调用同时对同一地址进行操作，那么计算结果将是不定值。但是可以在函数声明时使用automatic关键字，那么在调用时，仿真器将为函数分配不同的地址。每个函数调用各自的地址。因此：自动函数中声明的局部变量不能通过层次名进行访问，而自动函数本身可以通过层次名进行调用。例：`factorial=factorial（n-1）*n`；

### 3.11.3 关于函数和任务的小结
* 任务和函数都是用来对设计中多处使用的公共代码进行定义，使用任务和函数增强模块的可读性和可维护性。
* 可重入任务用关键词automatic定义，他的每一次调用都对不同的地址进行操作。因此可以多次并发调用时，也可得到正确的结果。

* 函数只能返回一个值，并且至少需要一个输入变量；在函数中不能使用延迟、事件和时序控制结构，但是可以调用其他函数，不能调用任务。
* 任务可以具有任意个输入、输入输出/输出、输出变量，在任务中可以使用延时、事件和时序控制结构，可以自定义时钟，可以调用其他函数和任务。
* 递归函数必须使用automatic关键词进行定义，递归函数的每一次调用都调用不同的地址空间，因此这种函数的递归调用和并发调用可以得到正确结果。

## 3.12 常用系统函数或任务

### 3.12.1 标准输出——`display`、`write`、`strobe`

```verilog
$display (p1,p2,...,pn)

$write (p1,p2,..,pn)

$strobe(p1,p2,...,pn)
```

* **功能描述**：
  * 这三个函数和系统的任务作用是用来输出信息，即将参数p2到pn按照参数p1给的格式输出。这三个任务的作用基本相同，不同之处在于：
     * **\$display自动的在输出后进行换行，而\$write却不是这样**。如果想在一行内输出多个信息，可以使用$write。
     * **如果许多其他语句和\$display在同一个时间单位执行，那么这些语句与\$display任务的执行顺序是不确定的。如果使用\$strobe，该语句总是在相同时刻的其他赋值语句执行完之后才执行**，因此\$strobe提供了一种同步机制，它可以在同一时钟沿赋值的其他语句在执行之后才会显示数据。

* **参数说明**：
  * 参数p1通常称作“格式控制参数”，参数p2至pn通常称作输出表列。
  * 格式控制参数是用双引号括起来的字符串，可以包含以下两种信息：
     * 格式说明，由“%”和格式字符组成。它的作用是将输出的数据转换成指定的格式输出。格式说明总是从%开始的。
     * 普通字符，即需要原样输出的字符。其中一些特殊的字符可以通过转换序列来输出。
  * 如果pn（n>1）为空，则输出一个空格。如：`$display("%d %d %d",8'd10,,8'd10);`

|输出格式|	说明|	输出格式|	说明|
|--|--|--|--|
|%h或%H	|以十六进制形式输出|	%d或%D	|以十进制形式输出
|%o或%O	|以八进制形式输出|	%b或%B	|以二进制形式输出
|%c或%C	|以ASCII码形式输出	|%v或%V	|输出网格型数据信号轻度
|%m或%M	|输出等级层次名字	|%s或%S	|以字符串的形式输出
|%e或%E	|以指数形式输出实型数|	%f或%F	|以十进制的形式输出实型数
|%g或%G	|以指数或十进制数中较短的结果输出实型数|%t或%T|输出当前的时间格式
 
|换码序列|	功能|	换码序列|	功能
|--|--|--|--|
|\n	|换行	|\\"|	双引号字符"
|\t	|水平制表符	|\o|1-3位八进制数代表的字符
|\\\  |反斜杠字符	|%%	|百分符号%
 

* **返回值**：无
* **注意事项**：
  * 在\$siaplay显示中，输出列表中的数据显示宽度是按照输出的格式进行自动调整的。在显示十进制时，输出结果前面的0值用空格来代替。对于其他进制，输出结果前面的0仍然显示出来。为了消去其他进制有效数字前面的0，可以在%和表示进制的字符串中间插入一个0自动调整显示输出数据宽度的方式。
  * 如果在输出列表中表达式的值包含不确定的值或高阻值，其结果遵循以下规则：
     * 输出为十进制的情况下:
         * 如果表达式值的所有位均为不定值，则输出结果为小写的x；
         * 如果表达式中所有的位均为高阻值，则输出结果为小写的z；
         * 如果表达式值的部分位为不定值，则输出结果为大写的X;
         * 如果表达式值的部分为高阻值，则输出的结果位大写的Z;
     * 输出为十六进制和八进制的情况下：
         * 每4位二进制数为一组代表一位十六进制数，每3位二进制数为一组代表一位八进制数。
         * 如果表达式值相对应的某进制的所有位均为不定值，则输出为小写的x；
         * 如果表达式值相对应的某进制数的所有位均为高阻值，则输出小写的z；
         * 如果表达式值相对应的某进制数的部分位为不定值，则该位输出的结果为大写的X；
         * 如果表达式值相对性的某进制数的部分位位高阻值，则该位输出的结果为大写的Z;
     * 对于二进制的情况：
         * 表达式的值每一位的输出结果都用0,1，x，z表示。
 
```verilog

$display("\\\t%%\"\123")             其输出结果为：  \%"S
val=101;
$display("val=%h hex val=%d decimal",val,val);
$display("val=%o otal val=%b binary",val,val);

//其输出的结果为：
val=00000065  hex  val=101 decimal
val=00000000145 otal val=00000000000000000000000001100101 binary
```
### 3.12.2 文件输出——`fopen`、 `fdisplay`、`fmonitor`、`fclose`
```verilog
文件描述符=$fopen("文件名")；
```

* **功能描述**：打开文件。
* **参数说明**：无。
* **返回值**：\$fopen返回一个被称作多通道描述符（multichannel descriptor）的32位值。多通道描述符中只有一位被设置成1。标准输出有一个多通道描述符，其最低位（第0位）被设置成1.标准输出也称作通道0，标准输出一直是开放的。以后对\$fopen的每一次调用开辟一个新的通道，并且返回一个设置了第一位，第二位等，直到32位描述符的第30位。第31位是保留位。信号通道与多通道描述符中被设置为1的位相对应。
* **注意事项**：无。


```verilog
$fdisplay(文件描述符，p1,p2,..pn)

$fmonitor(文件描述符，p1,p2,...pn)
```
* **功能描述**：写文件。
* **参数说明**：p1,p2,pn可以是变量，信号名或者带引号的字符串。文件描述符是一个多通道描述符，他可以是一个文件描述符或者多个文件描述符的按位组合。Verilog会把输出写到文件描述符中值为1 的文件中。
* **返回值**：无
* **注意事项**：无。
```verilog
$fclose(文件描述符)；
```

* **功能描述**：关闭文件。文件一旦被关闭，多通道描述符中的相应位被设置为0，下一次的fopen的调用可以重用这一位。
* **参数说明**：无
* **返回值**：无
* **注意事项**：无。
```verilog
integer handle1,handle2,handle3;
//标准输出是打开的，descrpitor=32'h0000_0001(bit 0 set 1)
initial
begin
    handle1=$fopen("file1.out");  //handle1=32'h0000_0002(bit 1 set 1)
    handle2=$fopen("file2.out");  //handle2=32'h0000_0004(bit 2 set 1)
    handle3=$fopen("file3.out");  //handle3=32'h0000_0008(bit 3 set 1)
end

integer  des1,des2,des3;
initial
begin
    des1=handle1|1;                 //des1=32'h0000_0003
    $fdisplay(des1,"display 1")   //write to file1.out and std.out

    des2=handle1|handle2;       //des1=32'h0000_0006
    $fdisplay(des2,"display 2")   //write to file1.out and file2.out 
  
    des3=handle3;       //des1=32'h0000_0006
    $fdisplay(des3,"display 3")   //write to file3.out 
end
```

### 3.12.3 监视——`monitor`
```verilog
$monitor(p1,p2,p3...pn);
$monitor;
$monitoron;
$monitoroff;
```
* **功能描述**：任务\$monitor提供了监控输出列表中的表达式或变量值的功能。
 * 当启动一个带有一个或多个参数的\$monitor时，仿真器则建立一个处理机制，使得**每当参数列表中变量或者表达式的值发生变化时，整个参数列表中变量或者表达式的值都将输出显示**。
     * 如果同一时刻，两个或多个参数的值发生变化，则该时刻只输出一次。
     * 在\$monitor中，参数可以是\$time系统函数。这样参数列表中变量或表达式的值同时发生变化的时刻可以通过表明同一时刻的多行显示出来。如`$monitor($time,,"tex=%b rex=%b",tex,rex); `
 
* **参数说明**：参数列表中输出格式控制字符串和输出列表的规则和\$display一样。
* **返回值**：无
* **注意事项**：
  * \$monitor和\$display的不同之处在于\$monitor往往直接用在initial语句块中，只要不调用\$monitoroff，\$monitor便不断的对所设定的信号进行监视。\$monitor不能在always块中调用。
  * 再多模块的调试情况下，每一个模块都会默认调用\$monitor语句，但是仿真器只能执行一个\$monitor语句，因此程序会报错，这时需要\$monitoron和\$monitoroff语句，这样可以使得各个模块分开调用\$monitor函数。
 
### 3.12.4 时间——`time`
```
$time;

$realtime;
```
* **功能描述**：这两个系统用函数可以得到当前的仿真时间。
  * \$time可以返回一个64位的整数来表示当前仿真时刻值，该时刻是以模块的仿真时间尺度位基准的。
  * \$realtime返回的时间数字是一个实型数。该数也是以时间尺度为基准的。
 
* **参数说明**：参数列表中输出格式控制字符串和输出列表的规则和\$display一样。
* **返回值**：无。
* **注意事项**：
  * \$time显示时刻受时间尺度的影响。
  * \$time总是输出整数，所以在将经过尺度比例变换的数字输出时，要先进行取整。而\$realtime可以输出实型数。


``` verilog
//模块test想在时间为16ns是设置寄存器set的值为0，在32ns时设置寄存器的set为1。但是由$time疾苦的set变化时刻却和预想的不一样，这是由下面两个原因引起的。 

`timescale 10ns/1ns
module test;
  reg set;
  parameter p=1.6;
  initial
  begin
     $monitor($time,,"set=",set);
     #p  set=0;
     #p  set=1;
  end
endmodule

//输出结果为：
 0 set=x
 2 set=0
 3 set=3
```


 
### 3.12.5 读取文件数据——`readmemb`、` readmemh`
```verilog
$readmemb("<数据文件名>",<存储器名>)；
$readmemb("<数据文件名>",<存储器名>,<起始地址>)；
$readmemb("<数据文件名>",<存储器名>,<起始地址>，<结束地址>)；

$readmemh("<数据文件名>",<存储器名>)；
$readmemh("<数据文件名>",<存储器名>,<起始地址>)；
$readmemh("<数据文件名>",<存储器名>,<起始地址>，<结束地址>)；
```
* **功能描述**：\$readmemb和\$readmemh用来从文件中读取数据到存储器中。这两个系统任务可以在仿真的任何时刻都被执行使用。在这两个系统函数中，被读取的数据文件的内容只能包括：空白字符（空格换行和制表格） 注释行（//和/**/） 二进制和十六进制数字。当地址出现在数据文件中时，其格式为@FF...F。
* **参数说明**：无。
* **返回值**：无。
* **注意事项**：
  * 如果系统任务和数据文件都没有说明地址。则从默认的存储器地址开始写入数据，直至数据写完或者存储器存满。
  * 如果系统任务说明了起始地址，没有说明结束地址，则数据从起始地址开始存放，直至存储器的结束地址为止。
  * 如果系统任务说明了起始地址和结束地址。那么久按任务说明中的地址进行存储，不考虑存储器的默认起始地址。
  * 如果系统任务和数据文件都说明了地址。那么数据文件中的地址说明必须包含在任务地址说明语句中，否则将出现错误信息，并且停止存储。
  * 如果数据文件中的数据个数和系统任务中起始地址和结束地址暗示的数据个数不同，也会报错。



 
```verilog
module test；
    reg [0:7]memory[0:7];   //声明8个8位的存储单元
    integer i;
    initial
        $readmemb("init.dat",memory);
        for(i=0;i<8;i=i+1)
        begin
            $display("memory[%d]=%b",i,memory[i]);
        end
endmodule

//如果文件中的内容为：
@002
11111111 00000000
01010101 10101010
@006
1111xxxx 00001111

//则测试结果为:
memory[0]=xxxxxxxx
memory[1]=xxxxxxxx
memory[2]=11111111
memory[3]=00000000
memory[4]=01010101
memory[5]=10101010
memory[6]=1111xxxx
memory[7]=00001111

```

 

 
### 3.12.6 完成与停止——`finish`、` stop`
 
```verilog
$finish;
$finish(n);


$stop;
$stop(n);

```
* **功能描述**：
  * 系统任务\$finish的作用是退出仿真器，返回主操作系统，也就是结束仿真过程。
  *  \$stop任务的作用是将EDA工具设置为暂停模式，在仿真环境下给出一个交互式的命令，将控制权交给用户。
* **参数说明**：\$finish和\$stop可以带参数，根据参数的值输出不同的特征信息。
  * 如果不带参数，默认其值为1；
  * 0 不输出任何信息。
  * 1 输出当前的仿真时间和位置；
  * 2 输出当前的仿真时间、位置和仿真过程中所用memory和CPU的时间统计。
* **返回值**：无。
* **注意事项**：无。

### 3.12.6 随机数——`random`
```verilog
 $random
```
* **功能描述**：产生随机数.
* **参数说明**：无
* **返回值**：一个32位的随机数。这是一个带符号的整型数。
* **注意事项**：\$random的一般用法是：\$random%b,其中b>0，返回一个范围在（-b+1）：（b-1）中的随机数。下面给出例子：
```verilog
reg [23:0]rand;
rand=$random%60;            //生成-59~59之间的随机数
rand={$random}%60;        //生成0~59之间的随机数

```
## 3.13 编译预处理

&emsp;&emsp;Verilog HDL语言和C语言一样也提供编译预处理的功能。在Verilog中为了和一般的语句相区别，这些预处理语句以符号"\`"开头，注意，这个字符位于主键盘的左上角，其对应的上键盘字符为"~",这个符号并不是单引号"'"。这里简单介绍最常用的\`define 、\`include 、\`timescale。

### 3.13.1 宏定义——`define`
```verilog
`define 标识符_宏名） 字符串_宏内容
```
* **功能描述**：用一个指定的标识符（名字）来代表一个字符串，在编译预处理时，将程序中该标识符替换为字符串。这种替代过程称作宏展开。

* **注意事项**：
  * 宏名可以是大写字母，也可以是小写字母。一般用大写字母，防止与后面的变量名重复。
  * `define可以出现在模块定义里面，也可以出现在外边。其有效范围是从该命令行开始至源文件结束。
  * 在引用已定义的宏名时，必须在宏名的前面加上符号`,表示该名字是一个经过宏定义的名字。
  * 宏定义是用宏名代替一个字符串，只做简单替换不检查语法。
  * 宏定义不是Verilog HDL语句，不必在后面加分号。
  * 在进行宏定义时，可以引用已经定义的宏名，可以层层替换。
  * 宏名和宏内容必须在同一行进行声明。如果在宏内容中包含有注释行，注释行不会作为被置换的内容。
  * 组成宏内容的字符串不能够被以下的语句记号分隔开。注释行+数字+字符串+确认符+关键词+双目或三目运算符。如下面的宏定义声明和引用就是非法的：
```verilog
`define first_half "start of string

$display(`first_half end of string")
```
 

### 3.13.2 文件包含处理——`include`
```verilog
`include"文件名"
```

* **功能描述**：所谓文件包含是指处理一个源文件可以将另一个源文件的全部内容包含进来，即将另外文件包含到本文件之中。在执行命令时，将被包含文件的全部内容复制插入到`include命令出现的地方，然后继续进行下一步的编译。
* **注意事项**：
  * 一个文件包含命令只能制定一个被包含的文件，如果需要包含n个文件，要用n个\`include命令。
  * \`include命令可以出现在Verilog程序的任何位置。被包含文件名可以是相对路径名，也可以是绝对路径名。
  * 可以将多个包含命令卸载同一行，可以出现空格和注释行。
  * 如果文件1 包含文件2，文件2需要用到文件3的内容，可以在文件一中用两个\`include命令分别将文件2和文件3包含进去，而且文件3要在文件2之前。
  * 在一个被包含文件中又可以包含其他的文件，即文件的包含是可以嵌套的。

 

### 3.13.3 时间尺度——`timescale`
```verilog
`timescale<时间单位>/<时间精度>
```
* **功能描述**：\`timescale命令用来说明跟在该命令后面的模块的时间单位和精度。使用\`timescale命令可以在同一个设计中包含不同的时间单位的模块。
* **注意事项**：
  * 在这条命令中，时间单位参量是用来定义模块中的仿真时间和延迟时间的基准单位的。时间精度是用来声明该模块的仿真时间的精确程度的，该参量被用来对延迟时间值进行取整操作，因此又可以称作是取整精度。如果在同一个程序设计里，存在多个\`timescale一样的命令，则用最小的时间精度值来决定仿真的时间单位。另外时间精度不能大于时间单位值。
  * 使用\`timescale时应该注意，\`timescale的有效区域为\`timescale语句处直至下一个\`timescale命令或者\`resetall语句为止。当有多个\`timescale命令时，只有最后一个才起作用，多以在同一个源文件中\`timescale定义的不同的多个模块最好分开编译，不要包含在一起以免出错。
  * 时间单位 和时间精度 由值1、10、和100以及单位s、ms、us、ns、ps和fs组成，用于说明仿真时间单位和时间精度的 数字只能是1、10、100，不能为其它的数字。而且，时间精度不能比时间单位还要大。最多两则一样大。
```verilog
`timescale 1ns/1ps         //时间值都为1ns的整数倍，时间精度为1ps，因此延迟时间可以表达为带三位小数的实型数。

`timescale 10μs/100ns   //时间单位为10μs的整数倍，时间精度位100ns，因此延迟时间可以表达为带两位小数的实型数。

`timescale 10ns/1ns module test;   
    reg =set;   
    parameter p=1.55;
    initial 
    begin
       $monitor($time,,"set=",set);
       #p set=0;
       #p set=1;
    end
endmodule

//根据时间精度，参数p的值从1.55取整为1.6；
//因为时间单位是10ns，时间精度为1ns，所以延迟时间#p作为事件单位的整数倍为16ns；
//可以用$printtimescale函数来输出显示一个模块的时间单位和时间精度。
```
 

### 3.13.4 条件编译命令——`ifdef `、`else`、`endif`

```verilog
`ifdef 宏名 (标识符)
      程序段1
`else
      程序段2
`endif
```
* **功能描述**：它的作用是当宏名已经被定义过（`define定义），则对程序1进行编译，程序段2被忽略。其中else部分可以没有。注意:忽略掉的程序段也要符合语法规则。






------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文参考了<font color=blue>[《FPGA编程语言——verilog语法》](http://baijiahao.baidu.com/s?id=1593288042605257892&wfr=spider&for=pc "点击跳转")、[《Verilog学习笔记基本语法篇》](https://www.cnblogs.com/SYoong/p/5849168.html)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------
