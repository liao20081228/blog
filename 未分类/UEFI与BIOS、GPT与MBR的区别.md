---
title: UEFI与BIOS、GPT与MBR的区别
tags: 其它
---

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：<font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------


# 1 磁盘分区格式
&emsp;&emsp;一般来说，磁盘分区表有两种格式：MBR和GPT。
## 1.1 MBR
![1](https://www.github.com/liao20081228/blog/raw/master/图片/UEFI与BIOS、GPT与MBR的区别/1.jpg)

* 磁盘的0号扇区（第一个扇区）也叫主引导扇区，它包含主引导程序、分区表DPT、硬盘有效标志。* 早期磁盘的扇区大小为512B
	* **主引导程序**：记录主引导加载程序，也叫第一阶段引导加载程序（Initial Program Loader，IPL），446B。主要作用是：
		 * 检查硬盘分区表是否完好。
		 * 在分区表中寻找可引导的“活动”分区。
		 * 将活动分区的第一逻辑扇区内容（也叫分区引导记录，PBR）装入内存。在DOS分区中，此扇区内容称为DOS引导记录（DBR）。
	 * **分区表**：记录整块磁盘的分区状态，64B。
	 * **有效标志**：2B。

* **分区表（DPT）**：分区表只能记录4个记录，每个记录为16B。记录了每个分区的起始和结束柱面号磁头号、扇区号、柱面号，分区激活标志，文件系统类型，相对扇区号，总扇区数目。因此磁盘最多只能有4个主分区，其中的任何一个主分区都可以划分为若干个逻辑分区。主分区划分逻辑分区后就叫做**扩展分区**，**扩展分区不能格式化且最多只能有一个**，在扩展分区前几个扇区记录了逻辑分区的信息。DPT的每个记录的格式如下：

|起始字节|偏移量|内容|
|--|--|--|
|0|1|分区的激活标志，表示系统可引导；一般为80
|1|3|起始磁头号、起始扇区号、起始柱面号
|4|1| 分区的系统类型，0B（FAT32），04(FAT16)、07(NTFS)；
|5|3|结束磁头号、结束扇区、结束柱面号
|8|4|相对扇区号，从磁盘开始到该分区开始的位移，以扇区计算
|12|4|总扇区数，最大容量为2<sup>32</sup>x512B=2TB


* **MBR分区的缺点**：
	* MBR分区表不支持容量大于2.2TB的分区(一些硬盘制造商将他们的容量较大的磁盘升级到了4KB的扇区,这意味着MBR的有效容量上限提升到了16 TB)
	* MBR 仅有一个扇区，若被破坏后，经常很难恢复。
	* MBR 内的存放开机管理程序的区块仅 446bytes，无法容纳较多的程序代码。

## 1.2 GPT

&emsp;&emsp;因为过去一个扇区大小就是512bytes 而已，不过目前已经有 4K 的扇区设计出现！为了兼容于所有的磁盘，因此在扇区的定义上面，大多会使用所谓的**逻辑区块地址**( LBA)来处理。GPT 将磁盘所有区块以此 LBA(预设为 512B！) 来规划，而第一个 LBA 称为 LBA0 (从0 开始编号)。
&emsp;&emsp;与 MBR 仅使用第一个 512bytes 区块来记录不同， GPT 使用了 33 个 LBA 区块来纪录分区信息！同时与过去MBR仅有一个扇区，被干掉就死光光的情况不同， GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为备份！

![2](https://www.github.com/liao20081228/blog/raw/master/图片/UEFI与BIOS、GPT与MBR的区别/2.jpg)

* **LBA0 (PMBR)**
&emsp;&emsp;在GPT分区表的最开头，处于兼容性考虑仍然存储了一份传统的MBR（LBA 0），这个MBR叫做保护性MBR（Protective MBR）。
&emsp;&emsp;保护性MBR保护GPT磁盘不受以前发布的MBR磁盘工具的危害。这些工具不能感知GPT，也无法正确地访问GPT磁盘。这些工具通过解释保护性MBR，将GPT磁盘看成一个封装的（可能无法识别）分区，而不是错误地当成一个未分区的磁盘，并且拒绝对硬盘进行操作。这就避免了意外删除分区的危险。（只支持MBR）
&emsp;&emsp;在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。（只支持GPT）
&emsp;&emsp;在使用MBR/GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。（支持GPT和MBR）



* **LBA1 (GPT 表头)**
&emsp;&emsp;分区表头（LBA 1）定义了硬盘的可用空间以及组成分区表的项的大小和数量。在使用64位Windows Server2003的机器上，最多可以创建128个分区，即分区表中保留了128个项，其中每个都是128字节。（EFI标准要求分区表最小要有16,384字节，即128个分区项的大小）
&emsp;&emsp;分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。以下是分区表头结构的具体信息：

>|起始字节|偏移量|内容|
>|--|--|--|
>|0|8|签名（"EFI PART"）
>|8|4|修订
>|12|4|分区表头的大小
>|16|4|分区表头（92B）的CRC32校验，在计算时，先把这个字段写作0处理，然后计算出所有分区表项的CRC32校验后再计算这个CRC32
>|20|4|保留，必须是 0
>|24|8|当前LBA（这个分区表头的位置）
>|32|8|备份LBA（另一个分区表头的位置）
>|40|8|第一个可用于分区的LBA（主分区表的最后一个LBA + 1）
>|48|8|最后一个可用于分区的LBA（备份分区表的第一个LBA - 1）
>|56|16|硬盘GUID（在类UNIX系统中也叫UUID）
>|72|8|分区表项的起始LBA（在主分区表中是2）
>|80|4|最大分区表项的数量（windows是128，没有这么多也先占着空间）
>|84|4|一个分区表项的大小（通常是128）
>|88|4|分区表项的CRC32校验（计算的是所有分区表项的检验和即128*128字节）
>|92|420|保留，剩余字节必须是0（420字节针对512字节的LBA硬盘）
>|&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;|

* **LBA2-33 (GPT分区表)**
&emsp;&emsp;从LBA2区块开始，每个LBA都可以有4个分区记录，所以在默认的情况下，总共可以有 4*32=128个分区记录（默认最多128个分区）！因为每个LBA有512B，因此每个记录可使用128B的空间。
&emsp;&emsp;一个分区表项的前16字节是分区类型GUID。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。格式如下：

>|起始字节|偏移量|内容
>|--|--|--|
>|0|16|分区类型GUID
>|16|16|分区GUID
>|32|8|起始LBA（小端格式）
>|40|8|末尾LBA
>|48|8|分区属性，
>|||
>&emsp;&emsp;
>&emsp;&emsp;
>&emsp;&emsp;类型GUID为固定值，查阅资料可得。下图列举Windows、Linux下常见几种：
>
>![3](https://www.github.com/liao20081228/blog/raw/master/图片/UEFI与BIOS、GPT与MBR的区别/3.png)
>
>![4](https://www.github.com/liao20081228/blog/raw/master/图片/UEFI与BIOS、GPT与MBR的区别/4.png)
>&emsp;&emsp;以Windows下基本数据分区为例说明：EBD0A0A2-B9E5-4433-87C0-68B6B72699C7。上述表示形式采用小端表示，其16位的串行表示为：A2A0D0EBE5B9334487C068B6B72699C7,即前三部分倒序表示。
>&emsp;&emsp;
>&emsp;&emsp;分区属性低位4字节表示与分区类型无关的属性，高位4字节表示与分区类型有关的属性。具体见下图：
>
>![5](https://www.github.com/liao20081228/blog/raw/master/图片/UEFI与BIOS、GPT与MBR的区别/5.png)

* **GPT分区优点**：
	 * 可以在GPT分区表头自定义最大分区数； 
	 * LBA为64位，支持的磁盘容量大；
	 * 分区表和分区表头有备份。

# 2 Leagcy BIOS和UEFI BIOS 的区别
## 2.1 Leagcy BIOS

&emsp;&emsp;BIOS读入CMOS参数，并识别可开机的设备，POST通过后，找到MBR，并执行初级引导加载程序。初级引导加载程序（放在MBR分区中），检查分区表的完整性，然后确定活动分区，并载入活动分区的PBR，PBR最主要的内容就是启动管理器（bootmgr或者grub），启动管理器根据定位信息找到二级引导加载程序，二级引导加载程序加载内核。如果要启动的系统安装再其他分区则将权力转交给其它分区的二级引导加载程序。

&emsp;&emsp;如果你的分区表为 GPT 格式的话，那么BIOS也能够从 LBA0 的 MBR 兼容区块读取第一阶段的开机管理程序代码， 如果你的开机管理程序能够认识 GPT 的话，那么使用BIOS同样加载内核，如果开机管理程序不懂GPT，例如WindowsXP的环境，那自然就无法加载内核，开机就失败了。

## 2.2 UEFI BIOS
&emsp;&emsp;虽然GPT可寻址8ZB，也能用较大的区块来处理开机管理程序。但是BIOS不懂GPT！还得要通过GPT提供兼容模式才能够读写这磁盘，而且**BIOS仅为16位**的程序，在与现阶段新的操作系统接轨方面有点弱掉了！为了解决这个问题，因此就有了UEFI这个统一可延伸固件接口的产生。
&emsp;&emsp;UEFI主要是想要取代BIOS这个固件接口，因此我们也称UEFI为 UEFI BIOS。UEFI 使用C程序语言，比起使用汇编语言的传统BIOS要更容易开发！也因为使 C语言来撰写，因此如果开发者够厉害，甚至可以在UEFI开机阶段就让该系统了解TCP/IP而直接上网！根本不需要进入操作系统耶！这让小型系统的开发充满各式各样的可能性！基本上，传统BIOS与UEFI的差异如下：
|比较项目| 传 BIOS| UEFI
|--|--|--|
|使用程序语言| 汇编语言 |C 语言
|硬件资源控制|使用中断管理、不可变内存与IO存取|使用驱动程序与协议|
|处理器运作环境| 16 位| CPU 保护模式|
|扩充方式 |透过 IRQ 连结| 直接加载驱动程序|
|第三方厂商支持 |较差 |较佳且可支持多平台|
|图形化能力 |较差| 较佳|
|内建简化操作系统前环境| 不支援 |支援|

&emsp;&emsp;与传统的BIOS不同，UEFI简直就像是一个低阶的操作系统，甚至于连主板上面的硬件资源的管理，也跟操作系统相当类似，只需要加载驱动程序即可控制操作。同时由于程控得宜，一般来说，使用UEFI接口的主机，在开机的速度上要比BIOS来的快上许多！因此很多人都觉得UEFI似乎可以发展成为一个很有用的操作系统耶，不过，关于这个，你无须担心未来除了 Linux 之外，还得要增加学一个 UEFI 的操作系统啦！为啥呢？
&emsp;&emsp;UEFI当初在发展的时候，就制定一些控制在里头，包括硬件资源的管理使用轮询 (polling)的方式来管理，与BIOS直接了解CPU以中断的方式来管理比较， 这种 polling的效率是稍微慢一些的，另外，UEFI并不能提供完整的快取功能，因此执行效率也没有办法提升。不过由于加载所有的UEFI驱动程序之后， 系统会开启一个类似操作系统的shell环境，用户可以此环境中执行任意的UEFI应用程序，而且效果比MSDOS更好。
&emsp;&emsp;所以，因为效果华丽但效能不佳，因此这个UEFI大多用来作为启动操作系统之前的硬件检测、开机管理、软件设定等目的，基本上作为OS是比较难的。 同时，当加载操作系统后，一般来说，UEFI就会停止工作，并将系统交给操作系统，这与早期的BIOS差异不大。比较特别的是，某些特定的环境下，这些UEFI程序是可以部份继续执行的，以协助某些操作系统无法找到特定装置时，该装置还是可以持续运作。
&emsp;&emsp;此外，由于过去cracker经常藉由BIOS开机阶段来破坏系统，并取得系统的控制权，因此UEFI加入了一个所谓的安全启动 (secure boot) 机制， 这个机制代表着即将开机的操作系统必须要被UEFI所验证，否则就无法顺利开机！微软用了很多这样的机制来管理硬件。 不过加入这个机制后，许多的操作系统，包括Linux，就很有可能无法顺利开机喔！所以，某些时刻，你可能得要将UEFI的secure boot 功能关闭， 才能够顺利的进入 Linux 哩！ 
&emsp;&emsp;另外，与BIOS模式相比，虽然UEFI可以直接取得GPT的分区表，不过最好依旧拥有BIOS boot的支持，同时，为了与windows兼容，并且提供其他第三方厂商所使用的UEFI应用程序储存的空间，你必须要格式化一个vfat的文件系统， 大约提供512MB到1G左右的容量，以让其他 UEFI 执行较为方便。
&emsp;&emsp;由于UEFI已经克服了BIOS的1024柱面的问题，因此你的开机管理程序与内核可以放置在磁盘开始的前2TB位置内即可！加上之前提到的 BIOS boot 以及 UEFI 支持的分区槽，基本上你的/boot目录几乎都是/dev/sda3之后的号码了！这样开机还是没有问题的！所以要注意喔！与以前熟悉的分区状况已经不同，/boot不再是/dev/sda1 ！

>所以BIOS也可以支持mbr和gpt，uefi也可以支持mbr和gpt，但是操作系统有一定要求，比如window使用uefi时只能用gpt，而linux则都可以。

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：<font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------